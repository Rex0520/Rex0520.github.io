[{"content":"Gradle构建工具 身边有学习安卓的大佬强烈推荐我学习了解下Gradle这款构建工具，说是将会是未来的主流，所以来此学习并记录下。\n货比三家 Ant Maven Gradle 公司 Apache Apache Google 语言 xml xml Groovy 构建性能 速度最快 速度最低 中间 依赖管理 ivy管理 GAV管理 GNV管理 插件管理 简单 复杂 简单 侧重 小型项目构建 项目包管理 大型项目构建 流行程度(2022) 低 高 中（未来趋势） 总结：各有各的优缺点，虽然gradle结合了ant和maven的优点，但是现在的兼容性还比较查\nGradle目录构结 目录 功能 /build 封装编译后的文件、测试报告 /gradle/wrapper/ 封装包装器文件夹 /src 速度最快｜ /gradlew mac/linux端包装器启动脚本 /gradlew.bat windows端包装器启动脚本 /build.gradle 构建脚本（类似maven的pom） /setting.gradle 设置项目信息 文件结构与maven极其相似🫤，都是基于约定大于配置（Convention over configuration）的设定\n常用命令 命令 作用 gradle clean gradle classes 编译业务代码和配置文件 gradle test 编译测试代码，生成测试报告｜ gradle build 构建项目 gradle build -x test 跳过测试构建 下载源配置 在gradle安转目录的init.d文件夹下新建一个init.gradle文件 init.gradle\nallprojects { repositories { mavenLocal() maven { name \u0026#34;Alibaba\u0026#34;; url \u0026#34;https://maven.aliyun.com/repository/public\u0026#34; } maven { name \u0026#34;Spring\u0026#34;; url \u0026#34;http://repo.spring.io/libs-milestone/\u0026#34; } mavenCentral() } buildscript { repositories { maven { name \u0026#34;Alibaba\u0026#34;; url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; } maven { name \u0026#34;Spring\u0026#34;; url \u0026#39;http://repo.spring.io/plugins-release/\u0026#39; } maven { name \u0026#34;M2\u0026#34;; url \u0026#39;https://plugins.gradle.org/m2/\u0026#39; } } } } 说明（从上至下搜索）\nmavenLocal() 从本地maven找，需配置M2_HOME环境变量，变量值为maven地址 Alibaba 阿里下载源 mavenCentral() maven中央仓库 tip: 配置源参考阿里云官方 Wrapper包装器 GradlerWrapper为解决没有gradle的环境下使用gradle项目的问题。只需要使用构建项目时生成的gradlew/gradlew.bat，需注意的是使用gradlew的命令需要依赖于jdk\n运行的依赖包在gradle/wrapper下 Gradle的使用方式和gradlew是一样的 可使用gradle wrapper指定参数控制wrapper版本（升级项目的gradle）， 参数 说明 \u0026ndash;gradle-version 用于指定使用的Gradle版本 \u0026ndash;gradle-distribution-url 用于指定下载Gradle发行的url地址 ","permalink":"https://rexhub.space/posts/back/java/build_tool/gradle/","summary":"Gradle构建工具 身边有学习安卓的大佬强烈推荐我学习了解下Gradle这款构建工具，说是将会是未来的主流，所以来此学习并记录下。\n货比三家 Ant Maven Gradle 公司 Apache Apache Google 语言 xml xml Groovy 构建性能 速度最快 速度最低 中间 依赖管理 ivy管理 GAV管理 GNV管理 插件管理 简单 复杂 简单 侧重 小型项目构建 项目包管理 大型项目构建 流行程度(2022) 低 高 中（未来趋势） 总结：各有各的优缺点，虽然gradle结合了ant和maven的优点，但是现在的兼容性还比较查\nGradle目录构结 目录 功能 /build 封装编译后的文件、测试报告 /gradle/wrapper/ 封装包装器文件夹 /src 速度最快｜ /gradlew mac/linux端包装器启动脚本 /gradlew.bat windows端包装器启动脚本 /build.gradle 构建脚本（类似maven的pom） /setting.gradle 设置项目信息 文件结构与maven极其相似🫤，都是基于约定大于配置（Convention over configuration）的设定\n常用命令 命令 作用 gradle clean gradle classes 编译业务代码和配置文件 gradle test 编译测试代码，生成测试报告｜ gradle build 构建项目 gradle build -x test 跳过测试构建 下载源配置 在gradle安转目录的init.","title":"Gradle构建工具"},{"content":"SpringBoot配置启动 背景 在实际开发的过程中，常常会有这样的需求，项目打包上线后需要更改一些配置，如果每次都需要重新在自己的电脑上打包后上线，这样的操作其实是非常繁琐的，所以需要有些自定义的配置文件，让项目以自定义的配置文件来启动项目。 之前自己在实际的开发中其实也遇到过这样的情况，项目是用在Windows server上的，需要对方来实时观测数据的准确性来调整配置数据，那时候因为只有这个小需求，也就没有写个web前端来做调整了，所以就想着用配置文件的方式，在这个过程中踩了很多坑，csdn也没有很全面的说明，这次进行了深入的学习，这边的配置是针对于springboot项目的\n关于Profile application-profile使用 指定配置环境application-{env}.yml，env是我们的环境，一般application-prod.yml为生产环境下运行、application-test.yml为测试环境下运行 激活指定环境 配置文件激活 在application.yml中配置spring.profiles.active来激活制定的{env}环境 命令行激活 java -jar xxx.jar \u0026ndash;spring.profiles.active=prod \u0026ndash; person.name=haha tips: 默认配置和环境变量同时生效 同名配置按优先级覆盖，优先级：命令行参数 \u0026gt; 命令行指定的环境配置 \u0026gt; 默认配置环境 SpringBoot中的@Profile注解 @Profile注解主要是用于条件装配，它的参数为制定的环境\nimport lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; import space.rexhub.boot05webadmin.bean.ConfigProperties; @Profile(\u0026#34;prod\u0026#34;) @Configuration @Slf4j public class ProdConfigure { @Value(\u0026#34;${rexhub.username}\u0026#34;) private String username; @Value(\u0026#34;${rexhub.password}\u0026#34;) private String password; @Bean public ConfigProperties configProperties(){ ConfigProperties configProperties = new ConfigProperties(); configProperties.setUsername(username); configProperties.setPassword(password); log.info(\u0026#34;prod: \u0026#34;+ configProperties); return configProperties; } } 如上述代码所示，当profile激活了prod时，才会把下面的配置加载到容器中，这种配置方式可以针对于不同的环境配置特定环境下特定的配置信息，不需要写在外边频繁修改的。\nProfile分组 在配置文件中，还有种分组的概念，可以将配置环境按组的形式使用。 使用:\n在配置文件中分好配置组 spring: profiles: group: prodGroup[1]: prod prodGroup[2]: tencent 在命令行制定需要激活的配置组 java -jar xxx.jar --spring.profiles.active=prodGroup 关于外部配置 官方说明\n外部配置源 Java属性文件 YAML文件 系统环境变量 命令行参数 配置文件查找的位置（从里到外查找，外的覆盖里面的） classpath, 根路径(src下，resource下) classpath根路径下的config目录 jar包当前目录下 jar包路径下的config路径下 系统根目录下的config的直接子目录 配置文件加载顺序 当前项目内的application.yml、application.properties 当前项目内指定激活的application-{env}.yml、application-{env}.properties jar包外部的application.yml、application.properties jar包外部指定激活的application-{env}.yml、application-{env}.properties ","permalink":"https://rexhub.space/posts/back/java/framework/springboot/springboot%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8/","summary":"SpringBoot配置启动 背景 在实际开发的过程中，常常会有这样的需求，项目打包上线后需要更改一些配置，如果每次都需要重新在自己的电脑上打包后上线，这样的操作其实是非常繁琐的，所以需要有些自定义的配置文件，让项目以自定义的配置文件来启动项目。 之前自己在实际的开发中其实也遇到过这样的情况，项目是用在Windows server上的，需要对方来实时观测数据的准确性来调整配置数据，那时候因为只有这个小需求，也就没有写个web前端来做调整了，所以就想着用配置文件的方式，在这个过程中踩了很多坑，csdn也没有很全面的说明，这次进行了深入的学习，这边的配置是针对于springboot项目的\n关于Profile application-profile使用 指定配置环境application-{env}.yml，env是我们的环境，一般application-prod.yml为生产环境下运行、application-test.yml为测试环境下运行 激活指定环境 配置文件激活 在application.yml中配置spring.profiles.active来激活制定的{env}环境 命令行激活 java -jar xxx.jar \u0026ndash;spring.profiles.active=prod \u0026ndash; person.name=haha tips: 默认配置和环境变量同时生效 同名配置按优先级覆盖，优先级：命令行参数 \u0026gt; 命令行指定的环境配置 \u0026gt; 默认配置环境 SpringBoot中的@Profile注解 @Profile注解主要是用于条件装配，它的参数为制定的环境\nimport lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; import space.rexhub.boot05webadmin.bean.ConfigProperties; @Profile(\u0026#34;prod\u0026#34;) @Configuration @Slf4j public class ProdConfigure { @Value(\u0026#34;${rexhub.username}\u0026#34;) private String username; @Value(\u0026#34;${rexhub.password}\u0026#34;) private String password; @Bean public ConfigProperties configProperties(){ ConfigProperties configProperties = new ConfigProperties(); configProperties.setUsername(username); configProperties.setPassword(password); log.info(\u0026#34;prod: \u0026#34;+ configProperties); return configProperties; } } 如上述代码所示，当profile激活了prod时，才会把下面的配置加载到容器中，这种配置方式可以针对于不同的环境配置特定环境下特定的配置信息，不需要写在外边频繁修改的。","title":"SpringBoot配置启动"},{"content":"Druid数据库连接池 概述 什么是连接池？🤔 Java连接数据库有很多中方式，最原始的方式就是直接使用数据库驱动连接数据库，但是这种方式有很多的弊端，如每次执行sql都需要创建和关闭数据库连接器，需要消耗大量的资源，如果没关闭成功还会导致内存泄漏的问题，以及一些线程问题。而数据库连接池主要做的是，预先创建好一定量的数据库连接放到池子中，当需要执行sql语句的时候取出一个数据库连接执行sql语句，用完了放回去，如果系统关闭则断开所有的数据库连接，并释放内存。\n常见的数据库连接池的配置参数 url 数据库地址 username 数据库账号 password 数据库密码 driverClassName 数据库驱动 maxActive 池子中支持的最大连接数（一般是可能的并发的数量） maxIdle 池子中连接最大的空闲数。（即使没有使用连接，池子里也会有maxIdle个连接） minIdle 池子中连接最小的空闲数。（当连接少于这个值，池子会自动创建连接补充到这个值） initialSize 池子中一开始的连接数 maxWait 连接最大的等待时间，如果超过这个时间会报错，-1的话就是无限等待 常见的数据库连接池 HikariCP Hikari在日语中是光的意思，主打高性能高效率。SpringBoot默认的数据库连接池使用的就是HikariCP。他的优点在于 有精简的字节码(代码量比较少) 优化了代理和拦截器 定义了集合类型：ConcurrentBag提高并发读写效率 Druid Druid是Alibaba的一个开源的数据库连接池，😲官方自称Java最好的数据库连接池，（但是实测HikariCP的性能要更强🤪）不过我觉得除了性能之外也要综合考虑其他的功能。Druid集成了强大的监控功能（SQL、Web、Session等等）、黑白名单拦截，这点我觉得在真实的生产环节中有很大优势，可以根据监控的信息调整项目使之变得更高效。 DBCP、C3P0 这俩款用的好像比较少，就不多介绍了。 Druid 正片开始，这几天学习了Druid发现，Druid不仅仅是在数据库连接池的性能方面做的很好，而且还有强大的监控功能，所以在此记录下他和SpringBoot的搭配。配置参考Druid的官方文档，官方介绍的确实很详细了，不过我这边记录的会和官方有点不一样，使用的有自动装配的druid\n集成SpringBoot 配置Maven，引入druid \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在里面的DruidDataSourceAutoConfigure文件已经对druid做了大量配置，按照官方还需要写配置类来配置druid一些连接信息（数据库连接信息、监控配置等等），而这边大部分的配置只需要写在application.yml/application.properties里就好了，剩下的就让DruidDataSourceAutoConfigure来将这些配置绑定在druid上就好。所以接下来的一步也非常的简单，就是写配置文件 编写配置信息 spring: datasource: url: jdbc:mysql://localhost:3306/proj_template?serverTimezone=Asia/Shanghai\u0026amp;useUnicode=true\u0026amp;charsetEncoding=utf-8\u0026amp;useSSL=true\u0026amp;allowPublicKeyRetrieval=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver druid: filter: slf4j: enabled: true # 开启日志功能 wall: enabled: true # 开启防火墙功能 stat: enabled: true # 开启sql监控功能 slow-sql-millis: 1000 # 配置SQL慢的标准 log-slow-sql: true # 是否开启记录执行慢的sql stat-view-servlet: enabled: true # 开启监控页功能 login-username: rex # 监控页登录账号 login-password: pwdofrex # 监控页登录密码 reset-enable: false # 配置是否允许重置监控信息 web-stat-filter: enabled: true # 开启web监控 exclusions: \u0026#34;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\u0026#34; # web监控白名单 ","permalink":"https://rexhub.space/posts/back/java/jdbctool/druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","summary":"Druid数据库连接池 概述 什么是连接池？🤔 Java连接数据库有很多中方式，最原始的方式就是直接使用数据库驱动连接数据库，但是这种方式有很多的弊端，如每次执行sql都需要创建和关闭数据库连接器，需要消耗大量的资源，如果没关闭成功还会导致内存泄漏的问题，以及一些线程问题。而数据库连接池主要做的是，预先创建好一定量的数据库连接放到池子中，当需要执行sql语句的时候取出一个数据库连接执行sql语句，用完了放回去，如果系统关闭则断开所有的数据库连接，并释放内存。\n常见的数据库连接池的配置参数 url 数据库地址 username 数据库账号 password 数据库密码 driverClassName 数据库驱动 maxActive 池子中支持的最大连接数（一般是可能的并发的数量） maxIdle 池子中连接最大的空闲数。（即使没有使用连接，池子里也会有maxIdle个连接） minIdle 池子中连接最小的空闲数。（当连接少于这个值，池子会自动创建连接补充到这个值） initialSize 池子中一开始的连接数 maxWait 连接最大的等待时间，如果超过这个时间会报错，-1的话就是无限等待 常见的数据库连接池 HikariCP Hikari在日语中是光的意思，主打高性能高效率。SpringBoot默认的数据库连接池使用的就是HikariCP。他的优点在于 有精简的字节码(代码量比较少) 优化了代理和拦截器 定义了集合类型：ConcurrentBag提高并发读写效率 Druid Druid是Alibaba的一个开源的数据库连接池，😲官方自称Java最好的数据库连接池，（但是实测HikariCP的性能要更强🤪）不过我觉得除了性能之外也要综合考虑其他的功能。Druid集成了强大的监控功能（SQL、Web、Session等等）、黑白名单拦截，这点我觉得在真实的生产环节中有很大优势，可以根据监控的信息调整项目使之变得更高效。 DBCP、C3P0 这俩款用的好像比较少，就不多介绍了。 Druid 正片开始，这几天学习了Druid发现，Druid不仅仅是在数据库连接池的性能方面做的很好，而且还有强大的监控功能，所以在此记录下他和SpringBoot的搭配。配置参考Druid的官方文档，官方介绍的确实很详细了，不过我这边记录的会和官方有点不一样，使用的有自动装配的druid\n集成SpringBoot 配置Maven，引入druid \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在里面的DruidDataSourceAutoConfigure文件已经对druid做了大量配置，按照官方还需要写配置类来配置druid一些连接信息（数据库连接信息、监控配置等等），而这边大部分的配置只需要写在application.yml/application.properties里就好了，剩下的就让DruidDataSourceAutoConfigure来将这些配置绑定在druid上就好。所以接下来的一步也非常的简单，就是写配置文件 编写配置信息 spring: datasource: url: jdbc:mysql://localhost:3306/proj_template?serverTimezone=Asia/Shanghai\u0026amp;useUnicode=true\u0026amp;charsetEncoding=utf-8\u0026amp;useSSL=true\u0026amp;allowPublicKeyRetrieval=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver druid: filter: slf4j: enabled: true # 开启日志功能 wall: enabled: true # 开启防火墙功能 stat: enabled: true # 开启sql监控功能 slow-sql-millis: 1000 # 配置SQL慢的标准 log-slow-sql: true # 是否开启记录执行慢的sql stat-view-servlet: enabled: true # 开启监控页功能 login-username: rex # 监控页登录账号 login-password: pwdofrex # 监控页登录密码 reset-enable: false # 配置是否允许重置监控信息 web-stat-filter: enabled: true # 开启web监控 exclusions: \u0026#34;*.","title":"Druid数据库连接池"},{"content":"SpringBoot源码分析（请求部分） 引言 👀看了尚硅谷雷神的SpringBoot2源码分析，颇有感触🤙，请求处理这部分的源码真的是太精彩了，决定自己在好好的debug几次，再记录下笔记！以前不理解什么叫作“框架 = 设计模式 + 反射 + 注解”，觉得设计模式不就是一些代码风格，反射不就是运行时动态获取类的内部信息并执行其的一些方法，注解不就是定义补充么。但看了SpringBoot源码后才知道如果没有设计模式，有些复杂逻辑的代码不做一些封装📦处理的话就会变成💩山代码，效率低、难理解、难扩展。而通过反射，可以使得框架有更高的灵活性和扩展性。使用注解则可以使代码更加简洁。\n接口创建 SpringBoot的特点开箱即用，即内部已经为我们做了大量的配置，包括请求参数解析、数据响应、内容协商等等，如果是用传统的servlet(SpringBoot底层已经封装了tomcat)会变得极其复杂，而springboot我们只需要几个注解就可以完成一个简单的接口。 Example:\n@GetMapping(\u0026#34;/girl\u0026#34;) public String getGirlFriend(@RequestParam String girlfriend){ return String.format(\u0026#34;Get a girlfriend: %s\u0026#34;, girlfriend); } 这样就成功创建了一个简单的接口，使用GetMapping来说明请求方式(\u0026ldquo;get\u0026rdquo;)和请求路径(\u0026quot;/girl\u0026quot;), 可以用url拼接参数的方式传参数（\u0026quot;/girl?girlfriend=xxx\u0026quot;）。按照以前sevlet，获取参数需要request.getParameter(\u0026ldquo;girlfriend\u0026rdquo;),post方法则要从request.getInputStream()获取BufferReader后再做处理；返回值想要返回json格式，需要用工具类，将对象拼接成json格式，然后用response.getWriter().println(girlfriend)写出，如果是中文还需要进行编码处理。而现在这些繁琐并且重复的操作springboot全做了处理，使我们在开发的过程中只需要注意业务部分的代码实现。\n请求处理过程概览 请求映射 处理并获取请求参数 调用目标方法 数据响应与内容协商 请求映射 请求进来会进到DispatchServlet.doDispatch()(Tips: DispatchServlet是HttpServlet的一个子类，由Spring进行封装)中，SpringMVC功能分析都从这个类开始分析 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 找到当前请求使用哪个Handler（Controller的方法）处理 // Determine handler for the current request. mappedHandler = getHandler(processedRequest); //HandlerMapping：处理器映射。 .... getHandler(processedRequest)：找到可以处理当前请求的handler 在spring中已经预定义了5个常用的请求处理器 1. RequestMappingHandlerMapping: 用于请求，保存了所有@RequestMapping 和handler的映射规则。 2. WelcomPageHandlerMapping: 用于处理欢迎页 3. BeanNameUrlHandlerMapping: 处理容器中以/开头的bean 4. RouterFuntionMapping: 处理RouterFunction发起的请求 5. SimpleUrlHandlerMapping: 处理请求的映射关系 getHandler: 挨个尝试所有的HandlerMapping看是否有请求信息 protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { if (this.handlerMappings != null) { for (HandlerMapping mapping : this.handlerMappings) { // 挨个尝试HandlerMapping看看是否有请求信息 HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) { return handler; } } } return null; } 处理并获取请求参数 大体思路 为当前Handler找一个适配器HandlerAdapter 适配器执行目标方法的同时解析每个参数 详解 预定义了常用的五个适配器 RequestMappingHandlerAdapter: 支持方法上标注@RequestMapping HandlerFunctionAdapter: 支持函数式编程的 HttpRequestHandlerAdapter: http请求处理器适配器 SimpleControllerHandlerAdapter: 简单控制器处理器适配器 doDispatch调用getHandlerAdapter protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { ... // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); ... } getHandlerAdapter，找到可以处理当前请求的handler protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException { if (this.handlerAdapters != null) { for (HandlerAdapter adapter: this.handlerAdapters) { // 遍历系统中的适配器，看看哪种支持处理当前请求的handler if (adapter.supports(handler)) { return adapter; } } } } 执行目标方法 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { ... // 调用处理器执行目标方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... } ha.handle(\u0026hellip;) → AbstractHandlerMethodAdapter.handleInternal(\u0026hellip;) → RequestMappingHandlerAdapter.invokeHandlerMethod(\u0026hellip;) → ServletInvocableHandlerMethod.invokeAndHandle(\u0026hellip;) → InvocableHandlerMethod.getMethodArgumentValues(\u0026hellip;) 找到合适的参数解析器-HandlerMethodArgumentResolver 用于解析参数的值 预定义的参数解析器有27种 RequestParamMethodArgumentResolver: 用于解析@Param的参数 RequestParamMapMethodArgumentResolver: 用于解析@Param Map格式的参数 PathVariableMethodArgumentResolver: 用于解析@PathVariable路径变量 \u0026hellip; 判断是否支持该参数解析器 protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { ... for (int i = 0; i \u0026lt; parameters.length; i++) { MethodParameter parameter = parameters[i]; ... // 判断解析器是否支持解析该参数 if (!this.resolvers.supportsParameter(parameter)) { throw new IllegalStateException(formatArgumentError(parameter, \u0026#34;No suitable resolver\u0026#34;)); } } } 如果支持则调用参数解析器的resolveArgument()方法 protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { ... // 解析指定参数 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); ... } public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception { // 获取可以解析该参数的参数解析器 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) { throw new IllegalArgumentException(\u0026#34;Unsupported parameter type [\u0026#34; + parameter.getParameterType().getName() + \u0026#34;]. supportsParameter should be called first.\u0026#34;); } // 解析方法的参数 return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory); } 又。。。在getArgumentResolver()里获取合适的解析器，感觉这边做的有点重复了(里面校验是否支持参数解析器)，找到了参数解析器后再执行解析器的resolveArgument（\u0026hellip;) 这边演示调用的是AbstractNamedValueMethodArgumentResolver中的解析参数的方法（其他类型参数解析器不一样） public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception { // 参数名称信息对象 NamedValueInfo namedValueInfo = getNamedValueInfo(parameter); MethodParameter nestedParameter = parameter.nestedIfOptional(); // 获取参数名称 Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name); if (resolvedName == null) { throw new IllegalArgumentException( \u0026#34;Specified name must not resolve to null: [\u0026#34; + namedValueInfo.name + \u0026#34;]\u0026#34;); } // 根据参数名获取参数值 Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); .... return arg; } 这边演示的是@Param参数获取的流程，自定义POJO的话是由ModelAttributeMethodProcessor这个参数解析器来处理，他解析的原理是通过反射 解析部分代码 public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception { ... // 获取参数名称 String name = ModelFactory.getNameForParameter(parameter); ... Object attribute = null; BindingResult bindingResult = null; if (mavContainer.containsAttribute(name)) { attribute = mavContainer.getModel().get(name); }else { // 创建属性实例, 即需要绑定属性的对象 try { attribute = createAttribute(name, parameter, binderFactory, webRequest); } catch (BindException ex) { ... } } if (bindingResult == null) { // 创建数据绑定器 WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); if (binder.getTarget() != null) { if (!mavContainer.isBindingDisabled(name)) { // 将webRequest中的请求数据绑定在对象中 bindRequestParameters(binder, webRequest); } ... } ... } // 将数据绑定在ModelAndViewContainer中 Map\u0026lt;String, Object\u0026gt; bindingResultModel = bindingResult.getModel(); mavContainer.removeAttributes(bindingResultModel); mavContainer.addAllAttributes(bindingResultModel); return attribute; } 这里面有个WebDataBinder，即数据绑定器，用于将请求参数的值绑定到指定的JavaBean里面，利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中 2. 他这里的数据绑定器默认的有124种（也可以在WebMvcConfigurer中自定义😏） @Override public void addFormatters(FormatterRegistry registry) { // 用lambda会报错 // 添加一个格式转换器 registry.addConverter(new Converter\u0026lt;String, Pet\u0026gt;() { @Override public Pet convert(String source) { if (StringUtils.hasLength(source)){ Pet pet = new Pet(); String[] args = source.split(\u0026#34;,\u0026#34;); pet.setName(args[0]); pet.setAge(Integer.valueOf(args[1])); return pet; } return null; } }); WebMvcConfigurer.super.addFormatters(registry); } 获取好参数之后就是调用目标方法了\u0026hellip; 调用目标方法 调用方法部分比较简单，原理就是通过反射工具获取目标类中的方法并执行 @Nullable protected Object doInvoke(Object... args) throws Exception { // 获取目标方法 Method method = getBridgedMethod(); try { if (KotlinDetector.isSuspendingFunction(method)) { return CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args); } // 执行目标方法 return method.invoke(getBean(), args); } catch (InvocationTargetException ex) { ... } } method.invoke(getBean(), args)执行目标方法 数据响应与内容协商 数据响应 数据响应分为响应页面和响应数据，页面一般都是用重定向或者请求转发，响应数据就是将指定的字符串、json、xml等特定格式返回\n目标函数执行完后，会返回一个参数 public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { //执行目标方法，并获取返回值 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); ... } 处理请求结果 ServletInvocableHandlerMethod public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { ... // 处理返回参数 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); ... } HandlerMethodReturnValueHandlerComposite.handleReturnValue(\u0026hellip;) public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception { // 获取匹配的返回值处理器 HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) { throw new IllegalArgumentException(\u0026#34;Unknown return value type: \u0026#34; + returnType.getParameterType().getName()); } // 用得到的返回值处理器处理返回结果 handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); } selectHandler(\u0026hellip;)获取适合处理制定类型的处理器 预定义的返回值处理器有15种 ModelAndViewMethodReturnValueHandler ModelMethodProcessor ViewMethodReturnValueHandler ResponseBodyEmitterReturnValueHandler \u0026hellip; ServletModelAttributeMethodProcessor 获取匹配的返回值处理器(与参数解析器的匹配的设计思路类似) private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) { boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) { if (isAsyncValue \u0026amp;\u0026amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) { continue; } if (handler.supportsReturnType(returnType)) { return handler; } } return null; } 用指定的返回值处理器处理返回参数 处理返回参数 @Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException { ... // 使用MessageConverters转换数据后将数据写出 writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage); } 由于我们这个是@ResponseBody的返回值处理器，这个处理器会调用RequestResponseBodyMethodProcessor的writeWithMessageConverters(\u0026hellip;)来处理参数 protected \u0026lt;T\u0026gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException { ... // 获取请求需要返回的媒体类型 MediaType selectedMediaType = null; MediaType contentType = outputMessage.getHeaders() // 服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据， ... // SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter if (selectedMediaType != null) { selectedMediaType = selectedMediaType.removeQualityValue(); for (HttpMessageConverter\u0026lt;?\u0026gt; converter : this.messageConverters) { GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u0026lt;?\u0026gt;) converter : null); // 判断该转换器能否转换数据 if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) { ... if (body != null) { ... if (genericConverter != null) { // 使用指定的转换器将数据写入body中 genericConverter.write(body, targetType, selectedMediaType, outputMessage); } else { // 使用默认的转换器写入body ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage); } } ... return; } } } ... } 每个converter实现了HttpMessageConverter接口，接口里有read()、writer()方法等，convter需要重写这些方法，将制定参数按照特定的方法写出。😏一般可以重写的都可以让我们自定义，我们可以自定义一些Convter放到SpringMVC的配置中，会在内容协商部分详细say。 内容协商 内容协商主要做的就是根据客户端的需求返回制定格式的数据(json、xml。。。)\n开启浏览器参数方式内容协商功能 在分析内容原理之前，得特别提一下springboot对内容协商的配置\nspring: mvc: contentnegotiation: favor-parameter: true #开启请求参数内容协商模式 做了这样的配置之后只需要在url的参数中带着format参数，如\nhttp://localhost:8080/test/person?format=json，将数据转换为json格式 http://localhost:8080/test/person?format=xml，将数据转换为xml格式 原理 部分原理在上述数据响应的有提过，所以会有一点重复\n判断当前响应头中是否已经有确定的媒体类型，MediaType属性 获取客户端支持接收的内容类型，Accept属性 contentNegotiationManager内容协商管理，使用内容协商管理器里的策略来获取处理策略（是选择将数据转为json/xml/\u0026hellip;），默认使用的是ParameterContentNegotiationStrategy策略 遍历所有的MessageConverter，找出支持处理该对象的转换器 将该convter支持处理的媒体类型统计出来 进行内容协商的最佳匹配媒体类型 protected \u0026lt;T\u0026gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException { ... // 进行内容协商的最佳匹配 MediaType.sortBySpecificityAndQuality(mediaTypesToUse); ... } 自定义内容协商 实现多协议数据兼容: json、xml、x-rex。从原理上看，只需要在WebMvcConfigurer加入自定义转换器。代码如下 MyMessageConverter.java\n/** * Description: 自定义Converter * * @author rex * @date 2022-09-25 16:37 */ public class MyMessageConverter implements HttpMessageConverter\u0026lt;Person\u0026gt; { /** * 读取数据的规则 */ public boolean canRead(Class\u0026lt;?\u0026gt; clazz, MediaType mediaType) { return false; } /** * 写入数据的规则 */ public boolean canWrite(Class\u0026lt;?\u0026gt; clazz, MediaType mediaType) { return clazz.isAssignableFrom(Person.class); } /** * 服务器要统计MessageConverter都能写出那些类型 * application/x-rex */ @Override public List\u0026lt;MediaType\u0026gt; getSupportedMediaTypes() { return MediaType.parseMediaTypes(\u0026#34;application/x-rex\u0026#34;); } /** * 读取数据 */ @Override public Person read(Class\u0026lt;? extends Person\u0026gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException { return null; } /** * 写入数据 */ @Override public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException { //自定义内容写出 String data = person.getName() + \u0026#34;;\u0026#34; + person.getAge() + \u0026#34;;\u0026#34; + person.getBirth(); outputMessage.getBody().write(data.getBytes()); } } WebConfig.java\n@Configuration(proxyBeanMethods = false) public class WebConfig implements WebMvcConfigurer { @Override public void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { // 加入自定义的消息转换器 converters.add(new MyMessageConverter()); } } ","permalink":"https://rexhub.space/posts/back/java/framework/springboot/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AF%B7%E6%B1%82%E9%83%A8%E5%88%86/","summary":"SpringBoot源码分析（请求部分） 引言 👀看了尚硅谷雷神的SpringBoot2源码分析，颇有感触🤙，请求处理这部分的源码真的是太精彩了，决定自己在好好的debug几次，再记录下笔记！以前不理解什么叫作“框架 = 设计模式 + 反射 + 注解”，觉得设计模式不就是一些代码风格，反射不就是运行时动态获取类的内部信息并执行其的一些方法，注解不就是定义补充么。但看了SpringBoot源码后才知道如果没有设计模式，有些复杂逻辑的代码不做一些封装📦处理的话就会变成💩山代码，效率低、难理解、难扩展。而通过反射，可以使得框架有更高的灵活性和扩展性。使用注解则可以使代码更加简洁。\n接口创建 SpringBoot的特点开箱即用，即内部已经为我们做了大量的配置，包括请求参数解析、数据响应、内容协商等等，如果是用传统的servlet(SpringBoot底层已经封装了tomcat)会变得极其复杂，而springboot我们只需要几个注解就可以完成一个简单的接口。 Example:\n@GetMapping(\u0026#34;/girl\u0026#34;) public String getGirlFriend(@RequestParam String girlfriend){ return String.format(\u0026#34;Get a girlfriend: %s\u0026#34;, girlfriend); } 这样就成功创建了一个简单的接口，使用GetMapping来说明请求方式(\u0026ldquo;get\u0026rdquo;)和请求路径(\u0026quot;/girl\u0026quot;), 可以用url拼接参数的方式传参数（\u0026quot;/girl?girlfriend=xxx\u0026quot;）。按照以前sevlet，获取参数需要request.getParameter(\u0026ldquo;girlfriend\u0026rdquo;),post方法则要从request.getInputStream()获取BufferReader后再做处理；返回值想要返回json格式，需要用工具类，将对象拼接成json格式，然后用response.getWriter().println(girlfriend)写出，如果是中文还需要进行编码处理。而现在这些繁琐并且重复的操作springboot全做了处理，使我们在开发的过程中只需要注意业务部分的代码实现。\n请求处理过程概览 请求映射 处理并获取请求参数 调用目标方法 数据响应与内容协商 请求映射 请求进来会进到DispatchServlet.doDispatch()(Tips: DispatchServlet是HttpServlet的一个子类，由Spring进行封装)中，SpringMVC功能分析都从这个类开始分析 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest !","title":"SpringBoot源码分析（请求部分）"},{"content":"SpringBoot学习（入门篇） 简单使用 浏览器中输入http://127.0.0.1:8080/hello, 显示hello, springboot2的字样\n创建maven工程\n生成pom.xml文件，引入相关依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;xyz.rexhub\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;boot-01-helloworld\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--项目打包文件格式--\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;!--springboot框架基础依赖--\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--springboot web依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--maven构建工具插件--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 创建主程序\npackage xyz.rexhub.boot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * Description: 主程序类 * * @author rex * @date 2022-07-06 23:21 */ @SpringBootApplication public class MainApplication { public static void main(String[] args) { SpringApplication.run(MainApplication.class, args); } } 业务代码\npackage xyz.rexhub.boot.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.Mapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * Description: * * @author rex * @date 2022-07-06 23:32 */ @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String handle01(){ return \u0026#34;hello, springboot2\u0026#34;; } } 测试：运行main方法\n简化配置,application.properties\nserver.port=8888 简化部署\n使用maven的clean和package命令，生成对应的jar包\n自动配置原理 依赖管理 父项目做依赖管理，典型例子：spring-boot-starter引入了spring-boot项目开发的各种基础包\n开发导入starter场景启动器\n1、见到很多 spring-boot-starter-* ： *就某种场景 2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入 3、SpringBoot所有支持的场景https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter 4、见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。 5、所有场景启动器最底层的依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 无须关注版本号，自动版本仲裁，在spring-boot-starter中定义了很多工具的版本号变量，如：mysql-connector.version, 导mysql驱动的时候就无需注名version；如果需要导入特定版本的，需要写明版本号\n自动配置 特性 自动引入并配置了Tomcat大部分的信息，如端口号、上下文路径\n自动引入SpringMVC常用组件（功能），并且自动配好常见功能: 字符编码问题\n默认的包结构\n主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来\n无需以前的包扫描配置\n想要改变扫描路径，@SpringBootApplication(scanBasePackages=\u0026ldquo;com.atguigu\u0026rdquo;)\n或者@ComponentScan 指定扫描路径\n@SpringBootApplication 等同于 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(\u0026#34;com.atguigu.boot\u0026#34;) 各种配置拥有默认值\n默认配置最终都是映射到某个类上，如：MultipartProperties 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象 按需加载所有自动配置项\n非常多的starter 引入了哪些场景这个场景的自动配置才会开启 SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面 \u0026hellip;\n容器功能 组件添加 @Configuration\n告诉Springboot是一个配置类\n配置类本身也是组件\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration { @AliasFor(annotation = Component.class) String value() default \u0026#34;\u0026#34;; boolean proxyBeanMethods() default true; } proxyBeanMethods: 代理bean的方法\nFull(proxyBeanMethods = true): 保证每个@Bean方法被调用多少次返回的组件都是单实例 Full(proxyBeanMethods = false): 每个@Bean方法被调用多少次返回的组件都是新创建的 组件依赖必须使用Full模式默认。 示例\n#############################Configuration使用示例###################################################### /** * Description:spring配置文件 * @author rex * @date 2022-07-07 23:26 */ @Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件 public class MyConfig { /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01(){ User zhangsan = new User(\u0026#34;zhangsan\u0026#34;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; } @Bean(\u0026#34;tom\u0026#34;) public Pet tomcatPet(){ return new Pet(\u0026#34;tomcat\u0026#34;); } } ################################@Configuration测试代码如下######################################## @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(\u0026#34;com.atguigu.boot\u0026#34;) public class MainApplication { public static void main(String[] args) { //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) { System.out.println(name); } //3、从容器中获取组件 Pet tom01 = run.getBean(\u0026#34;tom\u0026#34;, Pet.class); Pet tom02 = run.getBean(\u0026#34;tom\u0026#34;, Pet.class); System.out.println(\u0026#34;组件：\u0026#34;+(tom01 == tom02)); //4、xyz.rexhub.boot.config.MyConfig$$EnhancerBySpringCGLIB$$36f113b4@6c000e0c MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); User user01 = run.getBean(\u0026#34;user01\u0026#34;, User.class); Pet tom = run.getBean(\u0026#34;tom\u0026#34;, Pet.class); System.out.println(\u0026#34;用户的宠物：\u0026#34;+(user01.getPet() == tom)); } } @Bean、@Component、@Controller、@Service、@Repository\n@ComponetScan、@Import\n@ComponentScan将检查制定包下的组件，加到容器 @SpringBootApplication自带一个@ComponentScan, @Import() 给容器自动创建组件，默认组件的名字就是全类名 @Conditional\n条件装配注解，满足Conditional指定的条件，则进行组件注入\n其派生注解有@ConditionalOnBean、@ConditionalOnMissingBean、@ConditionalOnClass\u0026hellip; 使用\n=====================测试条件装配========================== @Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件 //@ConditionalOnBean(name = \u0026#34;tom\u0026#34;) @ConditionalOnMissingBean(name = \u0026#34;tom\u0026#34;) public class MyConfig { /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01(){ User zhangsan = new User(\u0026#34;zhangsan\u0026#34;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; } @Bean(\u0026#34;tom22\u0026#34;) public Pet tomcatPet(){ return new Pet(\u0026#34;tomcat\u0026#34;); } } public static void main(String[] args) { //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) { System.out.println(name); } boolean tom = run.containsBean(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;容器中Tom组件：\u0026#34;+tom); boolean user01 = run.containsBean(\u0026#34;user01\u0026#34;); System.out.println(\u0026#34;容器中user01组件：\u0026#34;+user01); boolean tom22 = run.containsBean(\u0026#34;tom22\u0026#34;); System.out.println(\u0026#34;容器中tom22组件：\u0026#34;+tom22); } 引入原生配置文件 @ImportResource\n示例\n======================beans.xml========================= \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;haha\u0026#34; class=\u0026#34;com.atguigu.boot.bean.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;zhangsan\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;hehe\u0026#34; class=\u0026#34;com.atguigu.boot.bean.Pet\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;tomcat\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; @ImportResource(\u0026#34;classpath:beans.xml\u0026#34;) public class MyConfig {} ======================测试================= boolean haha = run.containsBean(\u0026#34;haha\u0026#34;); boolean hehe = run.containsBean(\u0026#34;hehe\u0026#34;); System.out.println(\u0026#34;haha：\u0026#34;+haha);//true System.out.println(\u0026#34;hehe：\u0026#34;+hehe);//true 配置绑定 读取properties中的内容，并封装至JavaBean中\npublic class getProperties { public static void main(String[] args) throws FileNotFoundException, IOException { Properties pps = new Properties(); pps.load(new FileInputStream(\u0026#34;a.properties\u0026#34;)); Enumeration enum1 = pps.propertyNames();//得到配置文件的名字 while(enum1.hasMoreElements()) { String strKey = (String) enum1.nextElement(); String strValue = pps.getProperty(strKey); System.out.println(strKey + \u0026#34;=\u0026#34; + strValue); //封装到JavaBean。 } } } @ConfiguratinoProperties\n/** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 */ @Component @ConfigurationProperties(prefix = \u0026#34;mycar\u0026#34;) public class Car { private String brand; private Integer price; public String getBrand() { return brand; } public void setBrand(String brand) { } public Integer getPrice() { return price; } public void setPrice(Integer price) { this.price = price; } @Override public String toString() { return \u0026#34;Car{\u0026#34; + \u0026#34;brand=\u0026#39;\u0026#34; + brand + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } @EnableConfigurationProperties + @ConfigurationProperties\n@Component + @ConfigurationProperties\n源码分析 引导加载自动装配 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { ... } @SpringBootConfiguration里面就是一个@Configuration注解，提醒spring需要将其加载到容器中\n@ComponentScan是一个component包扫描器，\n@EnableAutoConfiguration\n@AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { ... } @AutoConfigurationPackage\n他做的事就是将application所在包下的组件进行自动配置\n其源码\n@Import({AutoConfigurationPackages.Registrar.class}) public @interface AutoConfigurationPackage { ... } static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { Registrar() { } public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])); } public Set\u0026lt;Object\u0026gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImports(metadata)); } } (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]) 会从注解元信息中获取包名数组\n@Import({AutoConfigurationImportSelector.class})\n1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件 2、调用List\u0026lt;String\u0026gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类 3、利用工厂加载 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件 4、从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 按需开启自动配置 ​\t虽然有127个自动配置类需要装载，但是springboot通过@Conditional注解来做条件装配，只装配有需要的注解\n修改默认配置 示例servlet的文件解析器\n@Bean @ConditionalOnBean(MultipartResolver.class) //容器中有这个类型组件 @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件 public MultipartResolver multipartResolver(MultipartResolver resolver) { //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; } 总结\nSpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定 生效的配置类就会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能就有了 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改。 ","permalink":"https://rexhub.space/posts/back/java/framework/springboot/springboot%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AF%87/","summary":"SpringBoot学习（入门篇） 简单使用 浏览器中输入http://127.0.0.1:8080/hello, 显示hello, springboot2的字样\n创建maven工程\n生成pom.xml文件，引入相关依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;xyz.rexhub\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;boot-01-helloworld\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--项目打包文件格式--\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;!--springboot框架基础依赖--\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--springboot web依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--maven构建工具插件--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 创建主程序\npackage xyz.rexhub.boot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * Description: 主程序类 * * @author rex * @date 2022-07-06 23:21 */ @SpringBootApplication public class MainApplication { public static void main(String[] args) { SpringApplication.","title":"SpringBoot学习（入门篇）"},{"content":"SpringBoot学习（核心功能篇-配置功能） properties yaml YAML 是 \u0026ldquo;YAML Ain\u0026rsquo;t Markup Language\u0026rdquo;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\u0026ldquo;Yet Another Markup Language\u0026rdquo;（仍是一种标记语言）。\n非常适合用来做以数据为中心的配置文件\n基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 \u0026lsquo;#\u0026lsquo;表示注释 字符串无需加引号，如果要加，\u0026lsquo;\u0026lsquo;与\u0026quot;\u0026ldquo;表示字符串内容 会被 转义/不转义 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null\nk: v 对象：键值对的集合。map、hash、set、object\n行内写法：k: (k1:v1, k2:v2, k3:v3) # 或 k: k1: v1 k2: v2 k3: v3 数组：一组按次序排序的值。array、list、queue\n行内写法：k: [v1, v3, v4] # 或 k: - v1 - v2 - v3 示例 ​\tjava\npackage xyz.rexhub.xyz.bean; import lombok.Data; import lombok.ToString; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.Date; import java.util.List; import java.util.Map; import java.util.Set; /** * Description: 人 * * @author rex * @date 2022-07-19 21:20 */ @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) @Component @ToString @Data public class Person { private String userName; private Boolean boss; private Date birth; private Integer age; private Pet pet; private String[] interests; private List\u0026lt;String\u0026gt; animal; private Map\u0026lt;String, Object\u0026gt; score; private Set\u0026lt;Double\u0026gt; salarys; private Map\u0026lt;String, List\u0026lt;Pet\u0026gt;\u0026gt; allPets; } package xyz.rexhub.xyz.bean; import lombok.Data; import lombok.ToString; /** * Description: 宠物 * * @author rex * @date 2022-07-19 21:22 */ @Data @ToString public class Pet { private String name; private Double weight; } application.yml\nperson: userName: 张三 boss: true birth: 2019/12/9 age: 18 # interests: [🏀, ⚽️] interests: - 🏀 - ⚽️ animal: [🐱, 🐶] # score: # english: 80 # math: 90 score: {english: 80, math: 90} salarys: - 9999.98 - 9999.99 pet: name: 阿狗 weight: 99.99 allPets: sick: - {name: 阿狗, weight: 99.99} - name: 阿猫 weight: 88.88 - name: 阿虫 weight: 77.77 health: [{name: 阿花, weight: 199.99}, {name: 阿明, weight: 199.99}] ","permalink":"https://rexhub.space/posts/back/java/framework/springboot/springboot%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E7%AF%87-%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD/","summary":"SpringBoot学习（核心功能篇-配置功能） properties yaml YAML 是 \u0026ldquo;YAML Ain\u0026rsquo;t Markup Language\u0026rdquo;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\u0026ldquo;Yet Another Markup Language\u0026rdquo;（仍是一种标记语言）。\n非常适合用来做以数据为中心的配置文件\n基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 \u0026lsquo;#\u0026lsquo;表示注释 字符串无需加引号，如果要加，\u0026lsquo;\u0026lsquo;与\u0026quot;\u0026ldquo;表示字符串内容 会被 转义/不转义 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null\nk: v 对象：键值对的集合。map、hash、set、object\n行内写法：k: (k1:v1, k2:v2, k3:v3) # 或 k: k1: v1 k2: v2 k3: v3 数组：一组按次序排序的值。array、list、queue\n行内写法：k: [v1, v3, v4] # 或 k: - v1 - v2 - v3 示例 ​\tjava\npackage xyz.rexhub.xyz.bean; import lombok.Data; import lombok.ToString; import org.springframework.boot.context.properties.ConfigurationProperties; import org.","title":"SpringBoot学习（核心功能篇-配置功能）"},{"content":"启动项目脚本 #!/bin/sh if [ -z $1 ];then echo \u0026#34;请输入可运行的jar名称\u0026#34; exit 1 fi appName=$1 logFileName=runlog ## 检查jar包是否存在 if [ ! -f $appName ];then echo \u0026#34;当前路径[`pwd`]不存在[$appName]\u0026#34; #\techo \u0026#34;$appName不存在\u0026#34; exit 1 fi ## 如果原先已在运行，则先停止该进程 pid=`jps -l|grep $appName|awk \u0026#39;{print $1}\u0026#39;` if [ -n \u0026#34;$pid\u0026#34; ];then echo \u0026#34;已存在进程[$pid]\u0026#34; kill -9 $pid echo \u0026#34;已停止进程[$pid]，重新启动应用\u0026#34; fi ## 删除控制台日志文件 if [ -f \u0026#34;$logFileName\u0026#34; ];then rm -rf $logFileName fi ## 启动应用 nohup java -Xms128m -Xmx256m -jar $appName --spring.profiles.active=prod \u0026gt; ./$logFileName 2\u0026gt;\u0026amp;1 \u0026amp; ## 再次查询新的进程号 pid=`jps -l|grep $appName|awk \u0026#39;{print $1}\u0026#39;` if [ -n \u0026#34;$pid\u0026#34; ];then echo \u0026#34;新进程[$pid]正在启动\u0026#34; echo \u0026#34;请注意查看控制台日志[$logFileName]\u0026#34; else echo \u0026#34;新进程启动失败！\u0026#34; fi ","permalink":"https://rexhub.space/posts/linux/%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%9C%AC/","summary":"启动项目脚本 #!/bin/sh if [ -z $1 ];then echo \u0026#34;请输入可运行的jar名称\u0026#34; exit 1 fi appName=$1 logFileName=runlog ## 检查jar包是否存在 if [ ! -f $appName ];then echo \u0026#34;当前路径[`pwd`]不存在[$appName]\u0026#34; #\techo \u0026#34;$appName不存在\u0026#34; exit 1 fi ## 如果原先已在运行，则先停止该进程 pid=`jps -l|grep $appName|awk \u0026#39;{print $1}\u0026#39;` if [ -n \u0026#34;$pid\u0026#34; ];then echo \u0026#34;已存在进程[$pid]\u0026#34; kill -9 $pid echo \u0026#34;已停止进程[$pid]，重新启动应用\u0026#34; fi ## 删除控制台日志文件 if [ -f \u0026#34;$logFileName\u0026#34; ];then rm -rf $logFileName fi ## 启动应用 nohup java -Xms128m -Xmx256m -jar $appName --spring.profiles.active=prod \u0026gt; .","title":"启动项目脚本"},{"content":"Git Git概述 Git是一个免费的，开源的分布式版本控制系统， 可以快速高效地处理从小型到大型的各种项目\nGit易于学习，占地面积小，性能极快，它具有廉价的本地库，方便的暂存区域和多个工作该分支等特性，其性能优于Subversion, CSV, Perforce和Clearcase等版本控制工具\n版本控制 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统\n版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换\n版本控制工具 集中化的版本控制系统（sv、svn）\n集中化的版本控制系统诸如csv、svn等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n优点：管理员可轻松掌控每个开发者的权限\n缺点：中央服务器单点故障\n分布式版本控制工具（Git、Mercurial、Bazaar、Darcs）\n像Git这种分不少版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)。\nGit和代码托管中心 代码托管中心是基于网络服务器的远程代码仓库，一般简单称为远程库。\n局域网\nGitLab\nGitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 GitLab由乌克兰程序员DmitriyZaporozhets 和ValerySizov开发，它使用Ruby语言写成。后来，一些部分用Go语言重写。截止2018年5月，该公司约有290名团队成员，以及2000多名开源贡献者。GitLab 被IBM，Sony, NASA, Alibaba, Invincea, O\u0026rsquo;ReillyMedia, Leibniz-Rechenzentrum(LRZ)， CERN, SpaceX 等组织使用。\n官网 安装文档\n互联网\nGithub（外网）\nGitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目Ruby on Rails、jQuery、python等。\n官网\nGitee码云（国内服务器）\n众所周知, GitHub服务器在国外,使用GitHub作为项目托管网站,如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。\n官网\nGit 常用命令 命令名称 作用 git config \u0026ndash;global user.name 用户名 设置用户签名 git config \u0026ndash;global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m \u0026ldquo;日志信息\u0026rdquo; 文件名 提交到本地库 git reflog 查看历史记录 git reset \u0026ndash;hard 版本号 版本穿梭 分支操作 理解 在版本控制中。同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。\n优点 并行推进多个功能开发，提高开发效率 如果一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可 操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 产生冲突 合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容。\n解决冲突 如以下情况：master分支对倒数第二行代码添加了一段内容：master test，添加暂存区并提交，hot-fix分支添加了一段内容：“hot-fix test”，添加暂存区并提交。 合并的时候会报以下提示：\n自动合并 hello.txt 冲突（内容）：合并冲突于 hello.txt 自动合并失败，修正冲突然后提交修正的结果。 在查看hello.txt\nello atguigu! hello git! 2222222222 hello atguigu! hello git! fix hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD hello atguigu! hello git! master test! ======= hello atguigu! hello git! hot-fix test! \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; hot-fix hello atguigu! hello git! 手动解决冲突后hello.txt\nhello atguigu! hello git! 2222222222 hello atguigu! hello git! fix hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! hello atguigu! hello git! master test! hello atguigu! hello git! hot-fix test! hello atguigu! hello git! 添加暂存区\u0026amp;提交本地库(不带文件名)\ngit add hello.txt git commit -m \u0026#34;merge test\u0026#34; Git团队协作机制 团队内协作 跨团队协作 远程仓库操作 查看远程库别名 git remote -v 创建远程仓库别名 git remote add [别名] 推送本地分支到远程库 git push [别名] [分支] 拉取远程仓库内容 git pull [别名] [分支] 克隆远程仓库到本地 git clone [url] Tip: clone会做如下操作。1、拉取代码。2、初始化本地仓库。3、创建别名\n","permalink":"https://rexhub.space/posts/git/git%E5%AD%A6%E4%B9%A0/","summary":"Git Git概述 Git是一个免费的，开源的分布式版本控制系统， 可以快速高效地处理从小型到大型的各种项目\nGit易于学习，占地面积小，性能极快，它具有廉价的本地库，方便的暂存区域和多个工作该分支等特性，其性能优于Subversion, CSV, Perforce和Clearcase等版本控制工具\n版本控制 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统\n版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换\n版本控制工具 集中化的版本控制系统（sv、svn）\n集中化的版本控制系统诸如csv、svn等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n优点：管理员可轻松掌控每个开发者的权限\n缺点：中央服务器单点故障\n分布式版本控制工具（Git、Mercurial、Bazaar、Darcs）\n像Git这种分不少版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)。\nGit和代码托管中心 代码托管中心是基于网络服务器的远程代码仓库，一般简单称为远程库。\n局域网\nGitLab\nGitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 GitLab由乌克兰程序员DmitriyZaporozhets 和ValerySizov开发，它使用Ruby语言写成。后来，一些部分用Go语言重写。截止2018年5月，该公司约有290名团队成员，以及2000多名开源贡献者。GitLab 被IBM，Sony, NASA, Alibaba, Invincea, O\u0026rsquo;ReillyMedia, Leibniz-Rechenzentrum(LRZ)， CERN, SpaceX 等组织使用。\n官网 安装文档\n互联网\nGithub（外网）\nGitHub于2008年4月10日正式上线，除了Git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目Ruby on Rails、jQuery、python等。\n官网\nGitee码云（国内服务器）\n众所周知, GitHub服务器在国外,使用GitHub作为项目托管网站,如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。\n官网\nGit 常用命令 命令名称 作用 git config \u0026ndash;global user.name 用户名 设置用户签名 git config \u0026ndash;global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m \u0026ldquo;日志信息\u0026rdquo; 文件名 提交到本地库 git reflog 查看历史记录 git reset \u0026ndash;hard 版本号 版本穿梭 分支操作 理解 在版本控制中。同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。","title":"Git学习"},{"content":"小程序数据表 模块表 字段名 类型 注释 id int 模块编号 module_code varchar(50) 模块码 module_name varchar(50) 模块名 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 行为表 字段名 类型 注释 id int 行为编号 action_code varchar(50) 行为码 action_name varchar(50) 行为名 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 用户表 字段名 类型 注释 id bigname 用户编号 real_name varchar(20) 实名 nick_name varchar(20) 用户昵称 password varchar(20) 用户密码 avatar_url varchar(255) 用户头像 gender tinyint 用户性别，0-男生，1-女生 tel varchar(20) 手机号 email varchar(20) 邮箱 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 角色表 字段名 类型 注释 id bigint 角色编号 name varchar(20) 角色名称 desc varchar(20) 角色描述 systemic tinyint 是否为系统内置 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 权限表 字段名 类型 注释 id bigint 权限编号 permission_code varchar(255) 权限码 module_id int 模块编号 action_id int 行为编号(增、删、改、查) create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 用户角色表 字段名 类型 注释 id bigint 用户角色编号 user_id bigint 用户编号 role_id bigint 角色编号 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 角色权限表 字段名 类型 注释 id bigint 角色权限编号 role_id bigint 角色编号 permission_id bigint 权限编号 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 微信用户模块 字段名 类型 注释 id bigint 用户编号 open_id varchar(50) 微信用户唯一标识符 auth_ token varchar(50) 用户登录时的token union_id varchar(50) 用户在开放平台下的唯一标识符 avatar_url varchar(255) 用户头像 tel varchar(255) 用户手机号 real_name varchar(20) 实名 gender tinyint 用户性别，0-男生，1-女生 id_card varchar(20) 身份证号 last_location varchar(20) 上次登录地点 create_time datetime 创建时间 update_time datetime 更新时间,可当作上次登录时间使用 creator bigint 创建人编号 updater bigint 更新人编号 ","permalink":"https://rexhub.space/posts/proj/doc/%E6%B8%A9%E5%B7%A5%E7%BE%8E%E9%99%A2/%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"小程序数据表 模块表 字段名 类型 注释 id int 模块编号 module_code varchar(50) 模块码 module_name varchar(50) 模块名 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 行为表 字段名 类型 注释 id int 行为编号 action_code varchar(50) 行为码 action_name varchar(50) 行为名 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 用户表 字段名 类型 注释 id bigname 用户编号 real_name varchar(20) 实名 nick_name varchar(20) 用户昵称 password varchar(20) 用户密码 avatar_url varchar(255) 用户头像 gender tinyint 用户性别，0-男生，1-女生 tel varchar(20) 手机号 email varchar(20) 邮箱 create_time datetime 创建时间 update_time datetime 更新时间 creator datetime 创建人 updater datetime 更新人 角色表 字段名 类型 注释 id bigint 角色编号 name varchar(20) 角色名称 desc varchar(20) 角色描述 systemic tinyint 是否为系统内置 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 权限表 字段名 类型 注释 id bigint 权限编号 permission_code varchar(255) 权限码 module_id int 模块编号 action_id int 行为编号(增、删、改、查) create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 用户角色表 字段名 类型 注释 id bigint 用户角色编号 user_id bigint 用户编号 role_id bigint 角色编号 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 角色权限表 字段名 类型 注释 id bigint 角色权限编号 role_id bigint 角色编号 permission_id bigint 权限编号 create_time datetime 创建时间 update_time datetime 更新时间 creator bigint 创建人编号 updater bigint 更新人编号 微信用户模块 字段名 类型 注释 id bigint 用户编号 open_id varchar(50) 微信用户唯一标识符 auth_ token varchar(50) 用户登录时的token union_id varchar(50) 用户在开放平台下的唯一标识符 avatar_url varchar(255) 用户头像 tel varchar(255) 用户手机号 real_name varchar(20) 实名 gender tinyint 用户性别，0-男生，1-女生 id_card varchar(20) 身份证号 last_location varchar(20) 上次登录地点 create_time datetime 创建时间 update_time datetime 更新时间,可当作上次登录时间使用 creator bigint 创建人编号 updater bigint 更新人编号 ","title":"温工美院数据库"},{"content":"内网穿透工具 开发中用到内网穿透做一些开发时的搭配或者线上环境的演示还是挺多的，目前先记录下各种内网穿透的特点以及使用的方式（因为frpc的操作我老是会忘记，所以这里记录下😅）\nNgrok ngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以ngrok可以很方便地协助服务端程序测试。详情见文档\n这玩意可以免费使用，但是自定义域名需要收费，免费使用的ngrok每个隧道只能由40个连接\n特点 稳定 跨平台 记录流量 操作简单 使用 进入官网，并拿到authtoken 下载安装所需要的工具 配置authtoken：ngrok authtoken [token]， 开启隧道: ngrok http 80[所需的端口] frp[还没操作过有空操作一波] zeroTier[老师推荐也还没操作过，有空操作一波] ","permalink":"https://rexhub.space/posts/tools/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","summary":"内网穿透工具 开发中用到内网穿透做一些开发时的搭配或者线上环境的演示还是挺多的，目前先记录下各种内网穿透的特点以及使用的方式（因为frpc的操作我老是会忘记，所以这里记录下😅）\nNgrok ngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以ngrok可以很方便地协助服务端程序测试。详情见文档\n这玩意可以免费使用，但是自定义域名需要收费，免费使用的ngrok每个隧道只能由40个连接\n特点 稳定 跨平台 记录流量 操作简单 使用 进入官网，并拿到authtoken 下载安装所需要的工具 配置authtoken：ngrok authtoken [token]， 开启隧道: ngrok http 80[所需的端口] frp[还没操作过有空操作一波] zeroTier[老师推荐也还没操作过，有空操作一波] ","title":"内网穿透"},{"content":"运算符【Go学习之路】 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等（特别注意go语言里无三元运算符）\n分类 算术运算符 用于对数值类型的变量进行运算\n运算符 运算 范例 结果 + 正号 +3 3 - 负号 -4 -4 + 加 5 + 5 10 - 减 6 - 4 2 * 乘 3 * 4 12 / 除 5 / 5 1 % 取模(取余) 7 % 5 2 ++ 自增 a = 2 a++ a = 3 \u0026ndash; 自减 a= 2 a\u0026ndash; a = 1 + 字符串拼接 \u0026ldquo;He\u0026rdquo; + \u0026ldquo;llo\u0026rdquo; \u0026ldquo;Hello\u0026rdquo; 基本使用\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { //特别注意\u0026#34;/\u0026#34;、\u0026#34;%\u0026#34;、\u0026#34;++\u0026#34;、\u0026#34;--\u0026#34; // \u0026#34;/\u0026#34;的使用 // 说明，如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分 fmt.Println(10 / 4) // 2 var n1 float32 = 10 / 4 fmt.Println(n1) // 2 // 如果我们希望保留小数部分，则需要有浮点数参与运算 var n2 float32 = 10.0 / 4 fmt.Println(n2) // 2.5 // \u0026#34;%\u0026#34;的使用 // 取余公式 a % b = a - (a / b * b) fmt.Println(\u0026#34;10 % 3 =\u0026#34;, 10%3) // 1 fmt.Println(\u0026#34;-10 % 3 =\u0026#34;, -10%3) // -1 fmt.Println(\u0026#34;10 % -3 =\u0026#34;, 10%-3) // 1 fmt.Println(\u0026#34;-10 % -3 =\u0026#34;, -10%-3) //-1 // ++ 和 --的使用 var i int = 10 i++ // 等价i = i + 1 fmt.Println(\u0026#34;i =\u0026#34;, i) // 11 i-- // 等价 i = i - 1 fmt.Println(\u0026#34;i =\u0026#34;, i) // 10 } 细节说明\n对于除号“/”，它的整数除和小数除是有区别的：整数除法，只保留整数部分而舍弃小数部分\n当对一个数取模时，可以等价a % b = a - (a / b * b)\nGolang的设计者去掉C / Java中自增自减容易混淆的写法，让Golang更加简洁，统一。（强制性的，太搞笑了，估计是汤普森看不下C语言的八股文考试了）\nGolang的自增自减只能当作一个独立语句使用，b := a++ 或者 b:=a \u0026ndash;都是错的，在其他的语言里是被允许的 Golang的++和\u0026ndash;只能写在变量的后面，不能写在变量的前面，++a，\u0026ndash;a都是错的，在其他的语言里是被允许的 if i++ \u0026gt; 0 {xxx}的 写法也是不被允许的 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var i int = 1 // var b int = i++ //语法错误 i++ var b int = i fmt.Println(\u0026#34;b =\u0026#34;, b) // ++i //语法错误 fmt.Println(\u0026#34;b =\u0026#34;, b) if i++ \u0026gt; 0 { //语法错误 fmt.Println(\u0026#34;i =\u0026#34;, i) } } 赋值运算符 赋值运算符就是将某个运算后的值，赋给指定的变量\n运算符 描述 示例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 c = a + b，将a+b表达式结果赋给c += 相加后再赋值 c += a 等价于 c = c + a -= 相减后再赋值 c -= a 等价于 c = c-a *= 相乘后再赋值 c *= a 等价于 c = c * a /= 相除后再赋值 c /= a 等价于 c = c / a %= 求余后再赋值 c % a 等价于 c = c % a \u0026laquo;= 左移后赋值 c \u0026laquo;= a 等价于c = c \u0026laquo; a \u0026raquo;= 右移后赋值 c \u0026raquo;= a等价于c = c \u0026raquo; a \u0026amp;= 按位与后赋值 c \u0026amp;= a等价于 c = c \u0026amp; a ^= 按位异或后赋值 c ^= a 等价于 c = c ^ a != 按位或后赋值 c != 2 等于c = c | 2 基本使用\npackage main import \u0026#34;fmt\u0026#34; func main() { // 赋值运算符的使用演示 // var i int // i = 10 // 基本赋值 // 有两个变量，a和b，要求将其进行交换，最终打印结果 // a = 9, b = 2 == \u0026gt; a = 2, b = 9 a, b := 9, 2 fmt.Println(\u0026#34;========交换前===========\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) t := a a = b b = t fmt.Println(\u0026#34;========交换后===========\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Println(\u0026#34;======复合赋值的操作======\u0026#34;) //复合赋值的操作 a += 17 //等价于a = a + 17 fmt.Println(\u0026#34;a =\u0026#34;, a) } // 结果 //========交换前=========== //a = 9 //b = 2 //========交换后=========== //a = 2 //b = 9 //======复合赋值的操作====== //a = 19 细节说明\n运算顺序从右往左 赋值运算符的左边，只能是变量，右边可以说变量、表达式、常量值 比较运算符/关系运算符 关系运算符的结果都是bool类型，也就是要么是true，要么是false，关系表达式经常用在if结构的条件中或循环结构条件中\n运算符 运算 范例 结果 == 相等 4==3 false != 不等于 4!=3 true \u0026lt; 小于 4 \u0026lt; 3 false \u0026gt; 大于 4 \u0026gt; 3 true \u0026lt;= 小于等于 4 \u0026lt;= 3 false \u0026gt;= 大于等于 4 \u0026gt;= 3 true 基本使用\npackage main import \u0026#34;fmt\u0026#34; func main() { var n1 int = 9 var n2 int = 8 fmt.Println(n1 == n2) // false fmt.Println(n1 != n2) // true fmt.Println(n1 \u0026gt; n2) // true fmt.Println(n1 \u0026lt; n2) // false fmt.Println(n1 \u0026gt;= n2) // true fmt.Println(n1 \u0026lt;= n2) // false flag := n1 \u0026gt; n2 fmt.Println(\u0026#34;flag =\u0026#34;, flag) // true } 细节说明\n关系运算符的结果都是bool型，也就是要么true，要么是false 关系运算符组成的表达式，我们称为\u0026quot;关系表达式\u0026quot;, a \u0026gt; b 比较运算符\u0026quot; == \u0026ldquo;不能写成 \u0026quot; = \u0026quot; 逻辑运算符 连接多个条件(关系表达式)，最终结果也是一个bool\n运算符 运算 范例 结果 \u0026amp;\u0026amp; 逻辑与运算符。操作符两边都为true则为true，反之则为false (1 == 1) \u0026amp;\u0026amp; (2 == 2) true || 逻辑或运算符。操作符两边有一个true则为true，反之则为false (1 == 2) \u0026amp;\u0026amp; (2 == 2) true ! 逻辑非运算符。如果条件为true，则逻辑为false，否则为true !(1 == 1) false 基本使用\npackage main import \u0026#34;fmt\u0026#34; func main() { // 演示逻辑运算符的使用 \u0026amp;\u0026amp; age := 40 if age \u0026gt; 30 \u0026amp;\u0026amp; age \u0026lt; 50 { fmt.Println(\u0026#34;ok1\u0026#34;) } if age \u0026gt; 30 \u0026amp;\u0026amp; age \u0026lt; 40 { fmt.Println(\u0026#34;ok1\u0026#34;) } // ok1 // 演示逻辑运算符的使用 || if age \u0026gt; 30 || age \u0026lt; 50 { fmt.Println(\u0026#34;ok3\u0026#34;) } if age \u0026gt; 30 || age \u0026lt; 40 { fmt.Println(\u0026#34;ok4\u0026#34;) } // ok3 // ok4 // 演示逻辑非的使用 ! if age \u0026gt; 30 { fmt.Println(\u0026#34;ok5\u0026#34;) } if !(age \u0026gt; 30) { fmt.Println(\u0026#34;ok6\u0026#34;) } //ok5 } 细节说明\n\u0026amp;\u0026amp;也叫短路与：如果第一个条件为false，则第二个条件不会判断，最终为false ||也叫短路或：如果第一个条件为true，则第二个条件不会判断，最终结果为true 位运算符 运算符 运算 范例 \u0026amp; 按位与 1 \u0026amp; 0 = 0 | 按位或 1 | 0 = 1 ^ 按位异或 1^0 = 1 ~ 按位取反 ~1 = 0 其他运算符 运算符 描述 范例 \u0026amp; 返回变量存储的地址 \u0026amp;a；将给出变量的实际地址 * 指针变量 *a；是一个指针变量 基本使用\npackage main import \u0026#34;fmt\u0026#34; func main() { // 演示 \u0026amp; 和 *的使用（指针） a := 100 fmt.Println(\u0026#34;a的地址\u0026#34;, \u0026amp;a) //0xc0000160b0 var ptr *int = \u0026amp;a fmt.Println(\u0026#34;ptr指向的值是\u0026#34;, *ptr) //100 } 运算符优先级 分类 描述 关联性 后缀 () [] -\u0026gt; . ++ \u0026ndash; 左到右 单目 + - ! ~ (type) * \u0026amp; sizeof 右到左 乘、除、取余 * / % 左到右 加、减 + - 左到右 移位 \u0026laquo; \u0026raquo; 左到右 比较(关系) \u0026lt; \u0026lt;= \u0026gt;= \u0026gt; 左到右 相等(关系) == != 左到右 按位AND \u0026amp; 左到右 按位XOR ^ 左到右 按位OR | 左到右 逻辑AND \u0026amp;\u0026amp; 左到右 逻辑OR || 左到右 赋值运算符 = += -= *= /= %= \u0026raquo;= \u0026laquo;= \u0026amp;= ^= != 右到左 逗号 , 左到右 ","permalink":"https://rexhub.space/posts/back/go/study/%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"运算符【Go学习之路】 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等（特别注意go语言里无三元运算符）\n分类 算术运算符 用于对数值类型的变量进行运算\n运算符 运算 范例 结果 + 正号 +3 3 - 负号 -4 -4 + 加 5 + 5 10 - 减 6 - 4 2 * 乘 3 * 4 12 / 除 5 / 5 1 % 取模(取余) 7 % 5 2 ++ 自增 a = 2 a++ a = 3 \u0026ndash; 自减 a= 2 a\u0026ndash; a = 1 + 字符串拼接 \u0026ldquo;He\u0026rdquo; + \u0026ldquo;llo\u0026rdquo; \u0026ldquo;Hello\u0026rdquo; 基本使用","title":"运算符【Go学习之路】"},{"content":"Go变量【Go学习之路】 概念 变量是程序的基本组成单位，变量相当于内存中一个数据存储空间的表示，可以将变量看作是一个房间的门牌号，通过门牌号可以找到房间并取出房间里的东西，同样的道理，通过变量名可以访问到变量的值\n变量使用的基本步骤 声明变量（定义变量）\n基本语法：var 变量名 数据类型\nvar a int 这就是声明了一个变量，变量名是a\nvar num1 float32 这也声明了一个变量，表示一个单精度类型的小数，变量名是num1\n赋值\n使用\n变量使用案例 代码：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 定义变量/声明变量 var i int // 给i赋值 i = 10 // 使用变量 fmt.Println(\u0026#34;i =\u0026#34;, i) } 输出：\nPS G:\\goproject\\src\\go_code\\chapter03\\demo01\u0026gt; go run .\\main.go i = 10 变量使用的注意事项 变量表示内存中的一个存储空间\n该区域有自己的名称（变量名）和类型（数据类型）\nGolang变量使用的三种方式\n第一种：指定变量类型，声明后若不赋值，使用默认值\n// golang的变量使用方式1 // 第一种：指定变量类型，声明后若不赋值，使用默认值 // int默认值为0 var i int fmt.Println(\u0026#34;i =\u0026#34;, i) 第二种：根据值自行判定变量类型(类型推导)\n// 第二种：根据值自行判定变量类型(类型推导) var num = 10.11 fmt.Println(\u0026#34;num =\u0026#34;, num) 第三种：省略var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误\n// 第三种：省略var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误 // 下面的方式等价var name string; name = \u0026#34;tom\u0026#34; // \u0026#34;:=\u0026#34;的\u0026#34;:\u0026#34;不能省略，否则报错 name := \u0026#34;tom\u0026#34; fmt.Println(\u0026#34;name =\u0026#34;, name) 多变量声明\n在编程中，有时我们需要一次性声明多个变量，Golang也提供这样的语法\npackage main import \u0026#34;fmt\u0026#34; func main() { // 该案例演示golang如何一次性声明多个变量 // var n1, n2, n3 int // fmt.Println(\u0026#34;n1 =\u0026#34;, n1, \u0026#34;n2 =\u0026#34;, n2, \u0026#34;n3 =\u0026#34;, n3) // 一次性声明多个变量的方式2 // var n1, name, n3 = 100, \u0026#34;tom\u0026#34;, 888 // fmt.Println(\u0026#34;n1 =\u0026#34;, n1, \u0026#34;name =\u0026#34;, name, \u0026#34;n3 =\u0026#34;, n3) // 一次性声明多个变量的方式3 n1, name, n3 := 100, \u0026#34;tom\u0026#34;, 888 fmt.Println(\u0026#34;n1 =\u0026#34;, n1, \u0026#34;name =\u0026#34;, name, \u0026#34;n3 =\u0026#34;, n3) } 如何一次性声明多个全局变量\n// 定义全局变量 var n1 = 100 var n2 = 200 var name = \u0026#34;jack\u0026#34; // 上面的声明方式，也可以改成一次性声明 var ( n3 = 300 n4 = 900 name2 = \u0026#34;mary\u0026#34; ) 该区域的数据值可以在同一类型范围内不断变化\npackage main import \u0026#34;fmt\u0026#34; // 变量使用的注意事项 func main() { // 该区域的数据值可以在同一类型范围内不断变化 var i int = 10 i = 30 fmt.Println(\u0026#34;i =\u0026#34;, i) i = 1.2 //int, 原因是不能改变数据类型 } 变量在同一个作用域(函数或代码块)不能重名\n// 变量在同一个作用域(函数或代码块)不能重名 // var i int = 50 i := 99 变量 = 变量名 + 值 + 数据类型\nGolang的变量如果没有赋初值，编译器会使用默认值，比如int默认值0，string默认值为空，小数默认值为0\n变量的数据类型 graph LR; A[\u0026#34;数据类型\u0026#34;]--\u0026gt;B[\u0026#34;基本数据类型\u0026#34;]; A--\u0026gt;C[\u0026#34;派生/复杂数据类型\u0026#34;]; B--\u0026gt;D[\u0026#34;数值型\u0026#34;]; D--\u0026gt;P[\u0026#34;整数类型(int, int8, int32, int64，\u0026lt;/br\u0026gt;uint, uint8, uint16, uint64, byte), \u0026lt;/br\u0026gt;rune(int32的别名,用unicode码值存放)\u0026#34;]; D--\u0026gt;Q[\u0026#34;*浮点类型(float32, float64)\u0026#34;]; D--\u0026gt;R[\u0026#34;复数类型(complex)\u0026#34;] B--\u0026gt;E[\u0026#34;字符型(没有专门的字符型，使用byte来保存\u0026lt;br\u0026gt;单个字母字符，无法存储汉字，使用的是utf-8编码)\u0026#34;]; B--\u0026gt;F[\u0026#34;布尔型(bool)\u0026#34;]; B--\u0026gt;G[\u0026#34;字符串(string)[官方将string归属到基本数据类型]\u0026#34;]; C--\u0026gt;H[\u0026#34;指针(Pointer)\u0026#34;]; C--\u0026gt;I[\u0026#34;数组\u0026#34;]; C--\u0026gt;J[\u0026#34;结构体(struct)\u0026#34;]; C--\u0026gt;K[\u0026#34;管道(Channel)\u0026#34;]; C--\u0026gt;L[\u0026#34;函数(也是一种类型)\u0026#34;]; C--\u0026gt;M[\u0026#34;切片(slice)\u0026#34;]; C--\u0026gt;N[\u0026#34;接口(interface)\u0026#34;]; C--\u0026gt;O[\u0026#34;map\u0026#34;]; 整数型 类型：\n类型 有无符号 占用存储空间 表数范围 备注 int8 有 1字节 -128~127 类似于java中的byte int16 有 2字节 -2^15~2^15-1 类似于java中的short int32 有 4字节 -2^31~2^31-1 类似于java中的int int64 有 8字节 -2^63~2^63-1 类似于java中的long uint8 无 1字节 0~255 uint16 无 2字节 0~2^16-1 uint32 无 4字节 0~2^32-1 uint64 无 8字节 0~2^64-1 int 有 32位系统4个字节，64位系统8个字节 -2^31~2^31-1\n-2^63~2^63-1 uint 有 32位系统4个字节，64位系统8个字节 0~2^32-10~2^64-1 rune 有 与int8等价 -2^31~2^31-1 等价int32，表示一个unicode码 byte 无 与uint8等价 0~255 当要存储字符时选用byte 使用\npackage main import \u0026#34;fmt\u0026#34; // 演示golang中整数类型的使用 func main() { var i int = 1 fmt.Println(\u0026#34;i =\u0026#34;, i) //测试一下int8的范围 -128~127 //其他的 int16. int32, int64以此类推 var j int8 = 127 fmt.Println(\u0026#34;j =\u0026#34;, j) //测试一下uint8的范围(0~255)，其他uint16，uint32，uint64以此类推 var k uint8 = 255 fmt.Println(\u0026#34;k =\u0026#34;, k) } 注意：Golang程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量使用占用空间小的数据类型。【如：年龄】\n浮点型 类型\n类型 占用存储空间 表数范围 单精度 4字节 -3.403E38~3.403E38 双精度 8字节 -1.798E308~1.798308 使用\n代码：\npackage main import ( \u0026#34;fmt\u0026#34; ) // 演示golang中小数类型的使用 func main() { var price float32 = 89.123 fmt.Println(\u0026#34;price =\u0026#34;, price) var num1 float32 = -0.00089 var num2 float64 = -7809656.09 fmt.Println(\u0026#34;num1 =\u0026#34;, num1, \u0026#34;num2 =\u0026#34;, num2) } 输出\nprice = 89.123 num1 = -0.00089 num2 = -7.80965609e+06 注意：\nGolang的浮点类型在存储的时候与其他语言类似，采用的是IEEE754浮点数表示的方式，符号位 + 指数位 + 尾数位 = 浮点数，所以在使用的时候容易出现精度丢失的问题\n代码：\n// 精度丢失 f1 := 1129.6 fmt.Println(f1 * 100) 输出：\n112959.99999999999 Golang的浮点型默认声明为float64类型\n代码：\nvar num5 = 0.1 fmt.Printf(\u0026#34;num5 的数据类型为%T\\n\u0026#34;, num5) 输出：\nnum5 的数据类型为float64 浮点型常量有两种表示形式\n十进制数形式：如：5.12 .512，必须有小数点\\\n代码：\n// 十进制数形式：如：5.12\t.512(必须有小数点) num6 := 5.12 num7 := .512 fmt.Println(\u0026#34;num6 =\u0026#34;, num6, \u0026#34;num7 =\u0026#34;, num7) 输出：\nnum6 = 5.12 num7 = 0.512 科学计数法：如5.1234e2 = 5.12 * 10 的2次方 5.12E-2=5.12/10的2次方\n代码：\n//科学计数法形式 num8 := 5.1234e2 //5.1234*10^2 num9 := 5.1234e2 //5.1234*10^2 num10 := 5.1234e-2 //5.1234*10^-2 fmt.Println(\u0026#34;num8 =\u0026#34;, num8, \u0026#34;num9 =\u0026#34;, num9, \u0026#34;num10 =\u0026#34;, num10) 输出：\nnum8 = 512.34 num9 = 512.34 num10 = 0.051234 通常情况，使用float64，因为精确度更高\n字符型 Golang没有专门的字符类型，如果要存储单个字符，一般使用byte来保存\n类型\n类型 占用存储空间 编码方式 byte 英文字母占用1个字节，汉字占用3个字节 UTF-8 使用\n代码：\npackage main import ( \u0026#34;fmt\u0026#34; ) // 演示golang中字符类型的使用 func main() { var c1 byte = \u0026#39;a\u0026#39; var c2 byte = \u0026#39;0\u0026#39; //字符的0 // 当我们直接输出byte，就是输出对应的ascii码值 fmt.Println(\u0026#34;c1 =\u0026#34;, c1) fmt.Println(\u0026#34;c2 =\u0026#34;, c2) // 如果我们希望输出对应的字符，需要使用格式化输出 fmt.Printf(\u0026#34;c1=%c c2=%c\\n\u0026#34;, c1, c2) // var c3 byte = \u0026#39;北\u0026#39; //overflow溢出 var c3 int = \u0026#39;北\u0026#39; //overflow溢出 fmt.Printf(\u0026#34;c3 = %c\\n\u0026#34;, c3) // 可以直接给某个变量赋一个数字，然后格式化输出。输出对应的unicode字符 var c4 int = 22269 fmt.Printf(\u0026#34;c4 = %c\\n\u0026#34;, c4) // 字符类型是可以进行运算的，相当于一个整数，运算时是按照码值运行 var n1 = 10 + \u0026#39;a\u0026#39; fmt.Println(\u0026#34;n1 =\u0026#34;, n1) } 输出：\nc1 = 97 c2 = 48 c1=a c2=0 c3 = 北 c4 = 国 n1 = 107 布尔型 类型\n类型 占用存储空间 取值 bool 1个字节 true|false 使用\n代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // 演示golang中布尔型的使用 func main() { var b = false fmt.Println(\u0026#34;b =\u0026#34;, b) // 注意事项 // 1.bool类型占用存储空间是一个字节 fmt.Println(\u0026#34;bool 占用的空间为\u0026#34;, unsafe.Sizeof(b)) } 输出：\nb = false bool 占用的空间为 1 说明：特别注意，bool类型和c++不一样，bool只能取true和false，不能取0或1\n字符串 字符串是由固定长度的字符连接起来的字符序列\n使用\n代码：\npackage main import ( \u0026#34;fmt\u0026#34; ) // 演示golang中string的使用 func main() { //string的基本舒勇 var address string = \u0026#34;北京长城 110 hello world!\u0026#34; fmt.Println(\u0026#34;address =\u0026#34;, address) } 输出\naddress = 北京长城 说明\nGo的字符串是由单个字节连接起来的。使用UTF-8编码标识Unicode文本（Golang统一使用UTF-8编码，不容易出现中文乱码问题）\n字符串一旦赋值了，字符串就不能修改了，在Go中字符串是不可变的\n代码：\nvar str = \u0026#34;hello\u0026#34; str[0] = \u0026#39;a\u0026#39; //这里就不能去修改str的内容，cannot assign to str[0] 输出:\ncannot assign to str[0] 字符串的两种表示形式\n双引号(\u0026quot;\u0026quot;): 会识别转义字符 反引号(``)：以字符串的原生形式输出 代码：\nstr1 := \u0026#34;\\n\\n123\\n\u0026#34; str2 := `\\n\\n123\\n` str3 := ` \u0026lt;html\u0026gt; \u0026lt;div\u0026gt; HTML \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt;` fmt.Println(\u0026#34;str1 =\u0026#34;, str1) fmt.Println(\u0026#34;str2 =\u0026#34;, str2) fmt.Println(\u0026#34;str3 =\u0026#34;, str3) 输出\nstr1 = 123 str2 = \\n\\n123\\n str3 = \u0026lt;html\u0026gt; \u0026lt;div\u0026gt; HTML \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; 当拼接长度过长时，可换行，但是加号要留在上一行末尾\n代码：\nstr5 := \u0026#34;hello \u0026#34; + \u0026#34;world \u0026#34; + \u0026#34;haha!\u0026#34; fmt.Println(\u0026#34;str5 =\u0026#34;, str5) 示例：\nstr5 = hello world haha! 基本数据类型的默认值 在Go中，数据类型都有一个默认值，当程序员没有赋值时，会保留默认值，在Go中，默认值又叫零值\n数据类型 默认值 整型 0 浮点型 0 字符串 \u0026quot;\u0026quot; 布尔类型 false 基本数据类型的转换 Golang和Java/C不同，在不同类型转换时需显式转换。也就是说不能进行自动转换\n基本语法\n表达式T(v)将值v转换为类型T T: 数据类型, 比如int32,int64,float32等等 v:就是需要转换的变量 基本使用\n代码:\npackage main import \u0026#34;fmt\u0026#34; // 演示golang中基本类型的转换 func main() { var i int = 1000 // 希望将i =\u0026gt; float var n1 float32 = float32(i) var n2 int8 = int8(i) var n3 int64 = int64(i) //低精度 -\u0026gt; 高精度 fmt.Printf(\u0026#34;i的类型为%T，值为 %v, n1的类型为%T，值为 %v\\n\u0026#34;, i, i, n1, n1) fmt.Printf(\u0026#34;i的类型为%T，值为 %v, n2的类型为%T，值为 %v\\n\u0026#34;, i, i, n2, n2) fmt.Printf(\u0026#34;i的类型为%T，值为 %v, n3的类型为%T，值为 %v\\n\u0026#34;, i, i, n3, n3) } 输出:\ni的类型为int，值为 1000, n1的类型为float32，值为 1000 i的类型为int，值为 1000, n2的类型为int8，值为 -24 i的类型为int，值为 1000, n3的类型为int64，值为 1000 细节说明\nGo中, 数据类型转换既可以从低精度到高精度,也可以从高精度到低精度(通常不会闲着没事这么干,容易出现溢出问题) 基本数据类型和string类型转换 基本数据类型转string类型 fmt.Sprintf(\u0026quot;%参数\u0026quot;, 表达式)(强推)\n声明:\nfunc Sprintf(format string, a ...interface{}) string 说明:Sprintf根据format参数生成格式化的字符串并返回该字符串。\n使用: 代码:\nvar num1 int = 99 var num2 float64 = 23.456 var b bool = true var myChar byte = \u0026#39;h\u0026#39; var str string = \u0026#34;\u0026#34; // 使用第一种方式来转换，fmt.Sprintf方法 str = fmt.Sprintf(\u0026#34;%d\u0026#34;, num1) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) str = fmt.Sprintf(\u0026#34;%f\u0026#34;, num2) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) str = fmt.Sprintf(\u0026#34;%t\u0026#34;, b) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) str = fmt.Sprintf(\u0026#34;%c\u0026#34;, myChar) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) 输出:\nstr type string str = \u0026#34;99\u0026#34; str type string str = \u0026#34;23.456000\u0026#34; str type string str = \u0026#34;true\u0026#34; str type string str = \u0026#34;h\u0026#34; strconv包下的函数\n声明:\nfunc FormatBool(b bool) string\n根据b的值返回\u0026quot;true\u0026quot;或\u0026quot;false\u0026quot;。\nfunc FormatInt(i int64, base int) string\n返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母\u0026rsquo;a\u0026rsquo;到\u0026rsquo;z\u0026rsquo;表示大于10的数字。\nfunc FormatUint(i uint64, base int) string\n是FormatInt的无符号整数版本。\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n函数将浮点数表示为字符串并返回。\nbitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。\nfmt表示格式：\u0026lsquo;f\u0026rsquo;（-ddd.dddd）、\u0026lsquo;b\u0026rsquo;（-ddddp±ddd，指数为二进制）、\u0026rsquo;e\u0026rsquo;（-d.dddde±dd，十进制指数）、\u0026lsquo;E\u0026rsquo;（-d.ddddE±dd，十进制指数）、\u0026lsquo;g\u0026rsquo;（指数很大时用\u0026rsquo;e\u0026rsquo;格式，否则\u0026rsquo;f\u0026rsquo;格式）、\u0026lsquo;G\u0026rsquo;（指数很大时用\u0026rsquo;E\u0026rsquo;格式，否则\u0026rsquo;f\u0026rsquo;格式）。\nprec控制精度（排除指数部分）：对\u0026rsquo;f\u0026rsquo;、\u0026rsquo;e\u0026rsquo;、\u0026lsquo;E\u0026rsquo;，它表示小数点后的数字个数；对\u0026rsquo;g\u0026rsquo;、\u0026lsquo;G\u0026rsquo;，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。\nfunc Itoa(i int) string\nItoa是FormatInt(i, 10) 的简写。\n说明:strconv包实现了基本数据类型和其字符串表示的相互转换。\n使用:\n代码:\n// 使用第二种方式来转换，strconv下的包 var num3 int = 99 var num4 float64 = 23.456 var b2 bool = true str = strconv.FormatInt(int64(num3), 10) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) // strconv.FormatFloat(num4, \u0026#39;f\u0026#39;, 10, 64) // 说明: \u0026#39;f\u0026#39;格式 10: 表示小数位保留10位 64：表示这个小数是float64 str = strconv.FormatFloat(num4, \u0026#39;f\u0026#39;, 10, 64) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) str = strconv.FormatBool(b2) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) num5 := 4567 str = strconv.Itoa(num5) fmt.Printf(\u0026#34;str type %T str = %q\\n\u0026#34;, str, str) 输出:\nstr type string str = \u0026#34;99\u0026#34; str type string str = \u0026#34;23.4560000000\u0026#34; str type string str = \u0026#34;true\u0026#34; str type string str = \u0026#34;4567\u0026#34; string类型转基本数据类型 使用strconv包的函数\n声明:\nfunc ParseBool(str string) (value bool, err error)\n返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n返回字符串表示的整数值，接受正负号。\nbase指定进制（2到36），如果base为0，则会从字符串前置判断，\u0026ldquo;0x\u0026quot;是16进制，\u0026ldquo;0\u0026quot;是8进制，否则是10进制；\nbitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。\nfunc ParseUint(s string, base int, bitSize int) (n uint64, err error)\nParseUint类似ParseInt但不接受正负号，用于无符号整型。\nfunc ParseFloat(s string, bitSize int) (f float64, err error)\n解析一个表示浮点数的字符串并返回其值。\n如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。\nfunc Atoi(s string) (i int, err error)\nAtoi是ParseInt(s, 10, 0)的简写。\n说明:strconv包实现了基本数据类型和其字符串表示的相互转换。\n使用\n代码:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) // 演示golang中string转基本数据类型 func main() { var str string = \u0026#34;true\u0026#34; var b bool //b, _ = strconv.ParseBool(str) //说明 //1.strconv.ParseBool(str)函数会返回两个值(value bool, err error) //2.若只需要value bool，可使用\u0026#39;_\u0026#39;忽略err b, _ = strconv.ParseBool(str) fmt.Printf(\u0026#34;b type %T b = %v\\n\u0026#34;, b, b) str = \u0026#34;123\u0026#34; var n1 int n1, _ = strconv.Atoi(str) fmt.Printf(\u0026#34;n1 type %T n1 = %v\\n\u0026#34;, n1, n1) str = \u0026#34;123.456\u0026#34; var f1 float64 f1, _ = strconv.ParseFloat(str, 64) fmt.Printf(\u0026#34;f1 type %T f1 = %v\\n\u0026#34;, f1, f1) } 输出\nb type bool b = true n1 type int n1 = 123 f1 type float64 f1 = 123.456 注意:\n转换时需要注意字符串的有效性,若强转会转成对应类型的默认值\n代码\n//转换时需要注意字符串的有效性 str = \u0026#34;hello\u0026#34; n1, _ = strconv.ParseInt(str, 10, 0) fmt.Printf(\u0026#34;n1 type %T n1 = %v\\n\u0026#34;, n1, n1) 输出\nn1 type int64 n1 = 0 引用数据类型 基本数据类型存储的数据是值类型的\n指针(简要概述) 指针即指向基本数据类型变量的地址\n获取变量的地址，用\u0026rdquo;\u0026amp;\u0026ldquo;符号\n指针类型，指针变量存的是一个地址，这个地址指向的空间才是值\n比如：var ptr *int = \u0026amp;num\n获取指针类型所指向的值，使用：*，比如var ptr *int, 使用*ptr获取指向的值\n使用示例：\n代码：\npackage main import \u0026#34;fmt\u0026#34; // 演示golang中指针类型 func main() { // 基本数据类的内存布局 var i int = 10 // i 的地址是什么 fmt.Println(\u0026#34;i的地址=\u0026#34;, \u0026amp;i) // 下面var ptr*int = \u0026amp;i // 1. ptr 是一个指针变量 // 2. ptr 的类型 *int // 3. ptr 本身的值\u0026amp;i var ptr *int = \u0026amp;i fmt.Printf(\u0026#34;ptr=%v\\n\u0026#34;, ptr) fmt.Printf(\u0026#34;ptr的地址=%v\\n\u0026#34;, \u0026amp;ptr) fmt.Printf(\u0026#34;ptr指向的值=%v\\n\u0026#34;, *ptr) } 输出：\ni的地址= 0xc0000160c0 ptr=0xc0000160c0 ptr的地址=0xc000006030 ptr指向的值=10 值类型和引用数据类型的特点 值类型 变量直接存储值，内存通常在栈中分配（特殊情况：逃逸分析）\n值类型都有对应的指针类型，形式为*数据类型，比如int的对应的指针就是*int, float32对应的指针类型就是 *float，以此类推。\n值类型包括：基本数据类型int系列，float系列，bool，string，数组和结构体struct\n引用数据类型 变量存储的是一个地址，这个地址对应的空间才是真正存储数据(值)，内存通常在堆上分配（特殊情况：逃逸分析），当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。\nGo标识符 对各种变量、方法、函数等命名时使用的字符序列成为标识符，也就是说凡是可以起名字的地方都叫标识符\n命名规则 由26个英文字母大小写，0-9，\u0026rdquo;_\u0026ldquo;组成\n数字不可以开头\nGolang中严格区分大小写\nvar num int = 10 var Num int = 20 fmt.Printf(\u0026#34;num=%v, Num=%v\u0026#34;, num, Num)//num=10, Num=20 标识符不能包含空格\n//标识符不能包含空格 var ab c int = 30//expected \u0026#39;;\u0026#39;, found intsyntax 下划线\u0026rdquo;_\u0026ldquo;本身在Go中是一个特殊的标识符，称为空标识符。可以代表任何其他的标识符，但是它对应的值会被忽略（比如，返回某个返回值）、所以仅能被作为占位符使用，不能作为标识符使用\n// _ 是空标识符，用于占用 var _ int = 40 // fmt.Println(_)// cannot use _ as value or typecompiler 不能以系统保留关键字作为标识符(25个)，比如break，if等等\u0026hellip;\n注意事项 包名：保持package的名字和目录保持一致，尽量采取由意义的包名，简短，有意义，不要和标准库冲突 变量名、函数名、常量名：采用驼峰法 如果变量名、函数名、常量名首字母大写，则可以被其他的包访问：如果首字母小写，则只在本包中使用（注：可以简单理解为首字母大写是公有的，首字母小写是私有的） 系统保留关键字 在Go中，为了简化代码编译过程对代码的解析，其定义的保留关键字只有25个\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 预定义标识符 除了保留关键字外，Go还提供了36个预定的标识符，其包括基础数据类型和系统内嵌函数\nappend bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintprt ","permalink":"https://rexhub.space/posts/back/go/study/%E5%8F%98%E9%87%8F/","summary":"Go变量【Go学习之路】 概念 变量是程序的基本组成单位，变量相当于内存中一个数据存储空间的表示，可以将变量看作是一个房间的门牌号，通过门牌号可以找到房间并取出房间里的东西，同样的道理，通过变量名可以访问到变量的值\n变量使用的基本步骤 声明变量（定义变量）\n基本语法：var 变量名 数据类型\nvar a int 这就是声明了一个变量，变量名是a\nvar num1 float32 这也声明了一个变量，表示一个单精度类型的小数，变量名是num1\n赋值\n使用\n变量使用案例 代码：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 定义变量/声明变量 var i int // 给i赋值 i = 10 // 使用变量 fmt.Println(\u0026#34;i =\u0026#34;, i) } 输出：\nPS G:\\goproject\\src\\go_code\\chapter03\\demo01\u0026gt; go run .\\main.go i = 10 变量使用的注意事项 变量表示内存中的一个存储空间\n该区域有自己的名称（变量名）和类型（数据类型）\nGolang变量使用的三种方式\n第一种：指定变量类型，声明后若不赋值，使用默认值\n// golang的变量使用方式1 // 第一种：指定变量类型，声明后若不赋值，使用默认值 // int默认值为0 var i int fmt.Println(\u0026#34;i =\u0026#34;, i) 第二种：根据值自行判定变量类型(类型推导)","title":"变量【Go学习之路】"},{"content":"初识Golang【Go学习之旅】 👨‍💻一时兴起打算简略的学习一下golang，目前非常热门，有着高效率、高性能、高并发的特性，引起了朕极大的兴趣。简略的记录下学习记录✍，以便今后查阅与回顾。学习资源来自b站尚硅谷韩老师的课程\nGo语言诞生小故事 核心开发团队 Ken Thompson(肯·汤普森)： 图灵奖和美国国家技术奖获得者。他与Dennis Ritchie是Unix的原创者。Thomspson也发明了后来衍生出C语言和B语言程序语言，同时也是C语言的主要发明人 Rob Pike(罗布·派克)：曾是贝尔实验室(Bell Labs)的Unix团队，和Plan 9操作系统计划的成员。他与Thompson，并共创出广泛使用的UTF-8字元编码。奥运会射箭银奖、天文学家。。。。太强了 Robert Griesemer：曾协助制造Java的HotSpot编译器，和Chrome浏览器的Javascript引擎V8 Google为什么创造Go语言 计算机硬件技术更新频繁，性能提示很快。目前主流的编程语言明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能 软件系统复杂度越来越高，维护成本越来越高。目前缺乏一个足够简洁高效的编程语言【现有的编程语言：1.风格不统一 2.计算能力弱 3.处理大并发弱】 速度快的语言编译慢(C/C++)，开发效率高的语言运行慢(Python)，同时还存在内存泄漏的一系列的困扰。 Go语言发展历史 2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型 2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。 2015年8月19日，Go1.5版发布，本次更新中移除了“最后参与的C代码” 2017年2月17日，Go1.8发布 2017年8月24日，Go1.9发布 2018年2月16日 ，Go1.10发布 \u0026hellip;.. 至今2021.12.11 Go最新1.17 Go语言特点 从C语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针\n引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在\n垃圾回收机制，内存自动回收，不需要开发人员管理\n天然并发\n从语言层面支持并发，实现简单 goroutine，轻量级线程，可实现大并发处理，高效利用多核。 基于CPS并发模型(Communicating Sequential Processes)实现 吸收了管道通信机制，形成Go语言特有的管道channel\n通过管道channel，可以实现不同的goroute之间的相互通信\n函数返回多个值\nfunc getSumAndSub(n1 int, n2 int)(int, int){ sum := n1+n2 sub := n1 -n2 return sum, sub } 新的创意：切片(slice)、延时执行defer等\nGoLang执行流程分析 先编译在执行\ngraph LR A[.go] --\u0026gt;|go build| B[可执行文件] --\u0026gt;|运行| C[结果] 直接执行\ngraph LR; A[.go] --\u0026gt;|go run| B[结果]; 编译与运行说明 有了go源文件，编译器可将其编译成机器可以识别的二进制码文件\n在该源文件目录下，通过go build对hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。若程序有错误，编译时，会在错误的那行报错。\ntip: go build -o可以生成指定文件名的可执行文件\ngo build -o test.exe .\\hello.go 可直接运行生成可执行Go程序或用go run编译并运行源程序\nGolang官方编程指南 Golang官方网站：https://golang.org/ Golang官方文档：https://tour.go-zh.org/：介绍的较为简单，不适合初学者，适合有编程经验的人 Golang标准库API文档：https://studygolang.com/pkgdoc：国内golang文档 ","permalink":"https://rexhub.space/posts/back/go/study/%E5%88%9D%E8%AF%86golang/","summary":"初识Golang【Go学习之旅】 👨‍💻一时兴起打算简略的学习一下golang，目前非常热门，有着高效率、高性能、高并发的特性，引起了朕极大的兴趣。简略的记录下学习记录✍，以便今后查阅与回顾。学习资源来自b站尚硅谷韩老师的课程\nGo语言诞生小故事 核心开发团队 Ken Thompson(肯·汤普森)： 图灵奖和美国国家技术奖获得者。他与Dennis Ritchie是Unix的原创者。Thomspson也发明了后来衍生出C语言和B语言程序语言，同时也是C语言的主要发明人 Rob Pike(罗布·派克)：曾是贝尔实验室(Bell Labs)的Unix团队，和Plan 9操作系统计划的成员。他与Thompson，并共创出广泛使用的UTF-8字元编码。奥运会射箭银奖、天文学家。。。。太强了 Robert Griesemer：曾协助制造Java的HotSpot编译器，和Chrome浏览器的Javascript引擎V8 Google为什么创造Go语言 计算机硬件技术更新频繁，性能提示很快。目前主流的编程语言明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能 软件系统复杂度越来越高，维护成本越来越高。目前缺乏一个足够简洁高效的编程语言【现有的编程语言：1.风格不统一 2.计算能力弱 3.处理大并发弱】 速度快的语言编译慢(C/C++)，开发效率高的语言运行慢(Python)，同时还存在内存泄漏的一系列的困扰。 Go语言发展历史 2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型 2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。 2015年8月19日，Go1.5版发布，本次更新中移除了“最后参与的C代码” 2017年2月17日，Go1.8发布 2017年8月24日，Go1.9发布 2018年2月16日 ，Go1.10发布 \u0026hellip;.. 至今2021.12.11 Go最新1.17 Go语言特点 从C语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针\n引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在\n垃圾回收机制，内存自动回收，不需要开发人员管理\n天然并发\n从语言层面支持并发，实现简单 goroutine，轻量级线程，可实现大并发处理，高效利用多核。 基于CPS并发模型(Communicating Sequential Processes)实现 吸收了管道通信机制，形成Go语言特有的管道channel\n通过管道channel，可以实现不同的goroute之间的相互通信\n函数返回多个值\nfunc getSumAndSub(n1 int, n2 int)(int, int){ sum := n1+n2 sub := n1 -n2 return sum, sub } 新的创意：切片(slice)、延时执行defer等\nGoLang执行流程分析 先编译在执行\ngraph LR A[.go] --\u0026gt;|go build| B[可执行文件] --\u0026gt;|运行| C[结果] 直接执行","title":"初识Golang【Go学习之旅】"},{"content":"无诈校园微信小程序后端接口文档 baseUrl = “http://localhost:8090/fraud-prevention/api” 服务器Url=“http://1.117.91.88:52016/fraud-prevention/api” 用户模块 登录 url: /front/user/login\nmethod: Get\nrequest param: code\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:\u0026#34;98cb5a80-4199-44ce-a5f0-9f09c4bc438f\u0026#34; } 获取当前登录用户数据 url: /front/user/current\nmethod: Get\nrequest param: 空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1412572056239054850\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;15706753061\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;林瑞星(Rex)\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 350 } } 验证用户是否授权 url: /front/user/auth\nmethod: Get\nrequest param: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: false } 完善微信用户信息 url: /front/user/complete\nmethod: Put\nrequest body:\n参数 说明 示例 avatarUrl 必填，用户头像地址(以https开头) https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132 phone 必填，11位手机号 17777777777 number 必填，不超过50位 1900xxxxxxx name 必填，姓名，在2-10位之间 测试 gender 必填，性别，0-男生，1-女生 0 classId 必填，班级编号，(通过级联学校列表接口、系部列表接口、班级列表接口获得) 0 查询学校列表 url:/front/school/all\nmethod: Get\nrequest body: 无\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948512863797249\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1460132183478919170\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;宁波理工学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1461667934685483010\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州商学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1461667979283517441\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州大学\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1461685930590072834\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州医学院\u0026#34;, \u0026#34;depts\u0026#34;: null } ] } 查询系部列表 url: front/dept/all\nmethod: Get\nrequest param:\n参数 说明 示例 schoolId 必填，学校id 1412948512863797249 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;classes\u0026#34;: null } ] } 查询班级列表 url:/front/class/all\nmethod: Get\nrequest param:\n参数 说明 示例 deptId 必填，系部编号 1412948512863797249 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1410913678187843585\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412947735629869057\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;大数据1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948099783573506\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948245002862593\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1414833835378409474\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1414855420751523841\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1460221775330717697\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件2002\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null } ] } 获取近七天的学习记录 url: /front/user/score/week\nmethod: Get\nrequest param: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;dataPoints\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2021-12-01\u0026#34;, \u0026#34;score\u0026#34;: 0 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-02\u0026#34;, \u0026#34;score\u0026#34;: 0 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-03\u0026#34;, \u0026#34;score\u0026#34;: 0 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-04\u0026#34;, \u0026#34;score\u0026#34;: 0 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-05\u0026#34;, \u0026#34;score\u0026#34;: 10 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-06\u0026#34;, \u0026#34;score\u0026#34;: 0 }, { \u0026#34;date\u0026#34;: \u0026#34;2021-12-07\u0026#34;, \u0026#34;score\u0026#34;: 0 } ], \u0026#34;fromDate\u0026#34;: \u0026#34;2021-12-01\u0026#34;, \u0026#34;toDate\u0026#34;: \u0026#34;2021-12-07\u0026#34; } } 获取用户排名 url: /front/user/ranks\nmethod: Get\nrequest param:\n参数 说明 示例 range 非必填，查询排名的范围(class、dept、school)，不填的从所有的用户中排序，最多获得前20位用户 class response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1412572056239054850\u0026#34;, \u0026#34;schoolId\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;deptId\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;林瑞星(Rex)\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 350 }, { \u0026#34;id\u0026#34;: \u0026#34;1411968879850217474\u0026#34;, \u0026#34;schoolId\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;deptId\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;Rex\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 100 }, { \u0026#34;id\u0026#34;: \u0026#34;1415624376656605185\u0026#34;, \u0026#34;schoolId\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;deptId\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmhead/MAfiat4VDB3a5UmppLCgPyoSORqM3NJ5VSiavMFqItr6Y/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;陈雅婷\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1416600216089423874\u0026#34;, \u0026#34;schoolId\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;deptId\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmhead/rneMlzCiabb4AnIG0ibqGC9PwRrf0PSdSpFQehXNwHq0I/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;陈淑媛\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 } ] } 获取当前用户排名 url: /front/user/rank\nmethod: Get\nrequest param:\n参数 说明 示例 range 非必填，查询排名的范围(class、dept、school)，不填的从所有的用户中排序，最多获得前20位用户 class response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: 1 //为null 表示排名为100+ } 测试模块 分页查询测试列表 url: /front/exams\nmethod: Get\nrequest param:\n参数 说明 示例 type 非必填，测试类型 1-试卷(只有一次答题机会并且记录分数), 2-练习(有无数次答题机会，但不记录分数) 1 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1471393737744588802\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;24\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;234\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;done\u0026#34;: false,//判断试卷是不是已经完成过(仅限试卷模式使用)，true-已完成，false-未完成 \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-24 18:15:44\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-25 20:15:44\u0026#34;, \u0026#34;questions\u0026#34;: null, \u0026#34;totalNum\u0026#34;: null, \u0026#34;totalScore\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1469121243767672833\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;done\u0026#34;: false, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-23 12:45:54\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-24 19:45:54\u0026#34;, \u0026#34;questions\u0026#34;: null, \u0026#34;totalNum\u0026#34;: null, \u0026#34;totalScore\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;通用测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;每个用户都要参与的测试\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;done\u0026#34;: true, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-01 14:15:22\u0026#34;, \u0026#34;endTime\u0026#34;: null, \u0026#34;questions\u0026#34;: null, \u0026#34;totalNum\u0026#34;: null, \u0026#34;totalScore\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;通用练习\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;每个用户都能参与的练习\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;练习\u0026#34;, \u0026#34;done\u0026#34;: false, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-01 08:30:00\u0026#34;, \u0026#34;endTime\u0026#34;: null, \u0026#34;questions\u0026#34;: null, \u0026#34;totalNum\u0026#34;: null, \u0026#34;totalScore\u0026#34;: null } ], \u0026#34;total\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 查询测试详情 url: /front/exam/{examId}\nmethod: Get\nrequest param: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;通用测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;每个用户都要参与的测试\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;done\u0026#34;: true, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-01 14:15:22\u0026#34;, \u0026#34;endTime\u0026#34;: null, \u0026#34;questions\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1435444478465884162\u0026#34;, \u0026#34;category\u0026#34;: null, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;（智能语音）“您好，我是XX金融客服，请问您是否需要资金周转？您。。。。。。，你会？（新疆公安提供）\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;认真听，主动添加该手机号的微信\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;挂断电话，直接举报改号码\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;score\u0026#34;: 5 }, { \u0026#34;id\u0026#34;: \u0026#34;1435444479216664578\u0026#34;, \u0026#34;category\u0026#34;: null, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“xx，我是你二叔。我这边出了点急事需要周转，你转3000块给我吧。”当收到亲友发来的类似消息时，正确的做法是\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;与对方电话或视频确认身份\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;亲戚有难，立即转账\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;score\u0026#34;: 5 }, { \u0026#34;id\u0026#34;: \u0026#34;1435444480810500097\u0026#34;, \u0026#34;category\u0026#34;: null, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“法官”称你涉嫌犯罪，要你将钱转入安全账户，正确的做法是\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;先核实对方身份\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;立刻转钱\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;score\u0026#34;: 5 }, { \u0026#34;id\u0026#34;: \u0026#34;1435444480009388034\u0026#34;, \u0026#34;category\u0026#34;: null, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“xx您好，由于快递员疏忽，您的快递在运送途中丢失，我们将赔偿你2倍损失，点击以下链接填写个人信息。”接到类似电话，你会\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;联系官方客服查询快递信息\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;点击链接并按要求填写信息\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;score\u0026#34;: 5 } ], \u0026#34;totalNum\u0026#34;: 4, \u0026#34;totalScore\u0026#34;: 20 } } 提交答卷 url: /front/exam/do\nmethod: Post\nrequest body\n参数 说明 示例 examId 必填，试卷id 1 answers 必填，用户填写的答案，key-value形式，key试卷题目的id，value为数组，存储用户的选项 \u0026ldquo;answers\u0026rdquo;: {\u0026ldquo;1435444478465884162\u0026rdquo;: [\u0026ldquo;A\u0026rdquo;],\u0026ldquo;1435444480810500097\u0026rdquo;: [\u0026ldquo;B\u0026rdquo;],\u0026ldquo;1435444480009388034\u0026rdquo;: [\u0026ldquo;A\u0026rdquo;],\u0026ldquo;1435444479216664578\u0026rdquo;: [\u0026ldquo;A\u0026rdquo;]} response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;examId\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;score\u0026#34;: 20, \u0026#34;correctNum\u0026#34;: 4, \u0026#34;totalNum\u0026#34;: 4, \u0026#34;totalScore\u0026#34;: 20, \u0026#34;questions\u0026#34;: [ { \u0026#34;questionId\u0026#34;: \u0026#34;1435444478465884162\u0026#34;, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;score\u0026#34;: 5, \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;questionId\u0026#34;: \u0026#34;1435444479216664578\u0026#34;, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;score\u0026#34;: 5, \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;questionId\u0026#34;: \u0026#34;1435444480009388034\u0026#34;, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;score\u0026#34;: 5, \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;questionId\u0026#34;: \u0026#34;1435444480810500097\u0026#34;, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;score\u0026#34;: 5, \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;userAnswers\u0026#34;: [ \u0026#34;B\u0026#34; ] } ] } } 获取答题记录 url: /front/exam/history/{examId}\nmethod: Post\nrequest param: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;examId\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;score\u0026#34;: 20, \u0026#34;correctNum\u0026#34;: 4, \u0026#34;totalNum\u0026#34;: 4, \u0026#34;totalScore\u0026#34;: 20, \u0026#34;questions\u0026#34;: [ { \u0026#34;score\u0026#34;: 5.0, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;questionId\u0026#34;: 1.43544447846588416E18, \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;score\u0026#34;: 5.0, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;questionId\u0026#34;: 1.43544447921666458E18, \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;score\u0026#34;: 5.0, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;questionId\u0026#34;: 1.43544448000938803E18, \u0026#34;userAnswers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;A\u0026#34; ] }, { \u0026#34;score\u0026#34;: 5.0, \u0026#34;isCorrect\u0026#34;: true, \u0026#34;questionId\u0026#34;: 1.4354444808105001E18, \u0026#34;userAnswers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;correctAnswer\u0026#34;: [ \u0026#34;B\u0026#34; ] } ] } } 活动模块 分页查询活动 url:/front/activities\nmethod:Get\nrequest body:\n参数 说明 示例 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc respose body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1466978161962057729\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;signTime\u0026#34;: 1640836199000, \u0026#34;startTime\u0026#34;: 1641026999000, \u0026#34;endTime\u0026#34;: 1641134999000, \u0026#34;status\u0026#34;: 0, \u0026#34;number\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1465876559196704770\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试详情\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;signTime\u0026#34;: 1638405000000, \u0026#34;startTime\u0026#34;: 1638406800000, \u0026#34;endTime\u0026#34;: 1638417600000, \u0026#34;status\u0026#34;: 0, \u0026#34;number\u0026#34;: null } ], \u0026#34;total\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 查询活动详情 url: /front/activity/{id}\nmethod: Get\nrequest body:\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1466978161962057729\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;signTime\u0026#34;: 1640836199000, \u0026#34;startTime\u0026#34;: 1641026999000, \u0026#34;endTime\u0026#34;: 1641134999000, \u0026#34;status\u0026#34;: 0, \u0026#34;number\u0026#34;: 6 } } 签到URL url: /front/activity/sign\nmethod: Post\nrequest body:\n参数 说明 示例 activityId 必填，活动id 1 qrCode 必填，临时码 xxxxx response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } ","permalink":"https://rexhub.space/posts/proj/doc/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/","summary":"无诈校园微信小程序后端接口文档 baseUrl = “http://localhost:8090/fraud-prevention/api” 服务器Url=“http://1.117.91.88:52016/fraud-prevention/api” 用户模块 登录 url: /front/user/login\nmethod: Get\nrequest param: code\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:\u0026#34;98cb5a80-4199-44ce-a5f0-9f09c4bc438f\u0026#34; } 获取当前登录用户数据 url: /front/user/current\nmethod: Get\nrequest param: 空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1412572056239054850\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;15706753061\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;林瑞星(Rex)\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 350 } } 验证用户是否授权 url: /front/user/auth\nmethod: Get\nrequest param: 空","title":"无诈校园微信小程序后端接口文档"},{"content":"FraudPrevention后台管理系统开发文档 baseUrl = \u0026ldquo;http://localhost:8090/fraud-prevention/api\u0026rdquo;\n服务器Url=\u0026ldquo;http://1.117.91.88:52016/fraud-prevention/api\u0026rdquo;\n通用模块 获取验证码 url: /admin/captcha\nmethod: Get\nrequest body: 空\nresponse body\n\u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { token: \u0026#34;xxxxxx\u0026#34;, //验证码token captchaImg: \u0026#34;data:image/jpeg;base64,xxxxxx\u0026#34;, //base64格式的验证码图片 } } 获取所有模块信息 url: /admin/modules\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;moduleCode\u0026#34;: \u0026#34;USER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;moduleCode\u0026#34;: \u0026#34;ROLE\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;moduleCode\u0026#34;: \u0026#34;PERM\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;权限管理\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;moduleCode\u0026#34;: \u0026#34;TEACHER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34; } ] } 需提前登录\n获取所有行为(增删改查)信息 url: /admin/actions\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;actionCode\u0026#34;: \u0026#34;INSERT\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;actionCode\u0026#34;: \u0026#34;DELETE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;actionCode\u0026#34;: \u0026#34;UPDATE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;actionCode\u0026#34;: \u0026#34;SELETE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; } ] } 需提前登录\n上传图片（上传头像的时候需要）： url: /admin/image\nmethod: Post\nrequest body :\n参数 说明 示例 file 必填，图片 response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;https://cdn.rexhub.xyz/xxxx\u0026#34; } 删除图片（点击取消后需要） url: /admin/image\nmethod: Delete\nrequest param:\n参数 说明 示例 url 必填，图片的地址 https://cdn.rexhub.xyz/xxxx response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 用户模块 登录 url: /admin/login\nmethod: Post\nrequest body\n参数 说明 示例 username 用户名 admin password 密码 admin token 验证码的token code 验证码 cwca1 response header\n参数 说明 示例 Authorization 用户登录的token，其他的请求，请求头都要带上 xxxxx response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 获取当前登录用户信息 url:/admin/currentuser\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;password\u0026#34;: null, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexhub.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ], \u0026#34;perms\u0026#34;: [ \u0026#34;ROOT\u0026#34; ] } } 登出 url: /admin/logout\nmethod: Get\nrequest body：空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 新增用户（初始化密码88888888）： url: /admin/user\nmethod: Post\nrequest body:\n参数 说明 示例 username 必填，用户名 ceshi name 必填，名字，2-10位英文、中文、数字 测试 avatarUrl 非必填，头像地址，若无，有默认头像地址 https://xxx/xx.jpg sex 必填，性别，0-男，1-女 0 tel 必填，手机号，11位 17777777777 email 必填，邮箱 ceshi@163com roles 必填，数组，角色id [0] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除用户： url: /admin/users\nmethod: Delete\nrequest body:\n参数 说明 示例 ids 必填，用户的id [0] response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改用户： url: /admin/user\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，待修改用户编号 xxxxx name 非必填，名字 测试 avatarUrl 非必填，头像地址，若无，有默认头像地址 https://xxx/xx.jpg sex 非必填，性别，0-男，1-女 0 tel 非必填，手机号，11位 17777777777 email 非必填，邮箱 ceshi@163com response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 查询用户： url: /admin/user/{userId}\nmethod: Get\nrequest body:空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexhub.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ] } } 分页查询： url: /admin/users\nmethod: Get\nrequest params(url 路径传参)\n参数 说明 示例 page 非必填，页数，默认5 5 size 非必填，每页数量，默认10，不能超过50 10 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc username 非必填，用户名模糊查询 ce response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexhub.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ] } ], \u0026#34;total\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 分配用户角色： url:/admin/user/role\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，用户id 0 roles 必填，角色id数组 [1, 2, 3] response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 重置密码（88888888）： url: /admin/repass/{userId}\nmethod: Put\nrequest body：空\nresponse body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } tip：修改后，需重新登录，后端会使token失效；\n修改密码： url: /admin/user/updatepass\nmethod: Put\nrequest body：\n参数 说明 示例 newPassword 必填，新密码 xxxxxx oldPassword 必填，旧密码 xxxxx response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } tip：修改后，需重新登录，后端会使token失效；\n角色模块 查询所有角色（用于给用户分配权限） url:/admin/role/all\nmethod: Get\nrequest body\nresposne body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;createTime\u0026#34;: 1635994114000, \u0026#34;updateTime\u0026#34;: 1635994120000, \u0026#34;creator\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;updater\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;systemic\u0026#34;: 1 } ] } 分页查询角色 url: /admin/roles\nmethod: Get\nrequest param(注意这里用的url传参)\n参数 说明 示例 name 非必填，1-10位中文、英文组成 root page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;roleName\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;users\u0026#34;: 1, \u0026#34;permissions\u0026#34;: 1, \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;systemic\u0026#34;: 1 } ], \u0026#34;total\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 查询角色详情 url:/admin/role/{id}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;0\u0026#34; ], \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34; } } 新增角色 url:/admin/role\nmethod: Post\nrequest body\n参数 说明 示例 name 必填，角色名称，2-10位英文、中文、数字 test permissions 必填非空，权限数组 [0] desc 必填，角色描述，不能超过20个字符 test response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除角色 url: /admin/roles\nmethod: Delete\nrequest body:\n参数 说明 示例 ids 必填非空，但删除权限id数组 [1457736051796123650] response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改角色 url: /admin/role\nmethod: Put\nrequest body\n参数 说明 示例 id 必填，待修改的角色id name 非必填，角色名称，2-10位英文、中文、数字 test permissions 非必填，权限数组 [0] desc 非必填，角色描述，不能超过20个字符 test response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 权限模块 查询所有权限（用于给角色分配权限） url：/admin/perms\nmethod: Get\nrequest body: 空\nresponse body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;11\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; } ] } 学校管理模块 查询学校列表 url:/front/school/all\nmethod: Get\nrequest body: 无\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948512863797249\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1460131595630436353\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州医科大学\u0026#34;, \u0026#34;depts\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1460132183478919170\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;宁波理工学院\u0026#34;, \u0026#34;depts\u0026#34;: null } ] } 查询学校详情 url:/admin/school/{schoolId}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;depts\u0026#34;: null } } 分页查询 url:/admin/school\nmethod: Get\nrequest body\n参数 说明 示例 name 非必填，学校名称，1-20位中文、英文、数字组成，用于模糊匹配 温州 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410909562636140546\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;depts\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: \u0026#34;1412948512863797249\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;depts\u0026#34;: 2 }, { \u0026#34;id\u0026#34;: \u0026#34;1460131595630436353\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;温州医科大学\u0026#34;, \u0026#34;depts\u0026#34;: 0 } ], \u0026#34;total\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增学校信息 url: /admin/school\nmethod: Post\nrequest body:\n参数 说明 示例 name 必填，学校名称，2-20位中文、英文、数字组成 浙江大学 response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改学校信息 url: /admin/school\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，学校id 0 name 必填，学校名称，2-20位中文、英文、数字组成 浙江大学 response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除学校信息 url: /admin/schools\nmethod: Delete\nrequest body\n参数 说明 示例 ids 必填非空，待删除学校id数组 [1457736051796123650] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 系部管理模块 查询系部列表 url: front/dept/all\nmethod: Get\nrequest param:\n参数 说明 示例 schoolId 必填，学校id 1412948512863797249 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1412948697090220034\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;信息技术系\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;classes\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412949051445972994\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;工商系\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;classes\u0026#34;: null } ] } 查询系部详情 url:/admin/school/{schoolId}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1460183015209611266\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;计算机\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;classes\u0026#34;: null } } 分页查询 url: /admin/depts\nmethod: Get\nrequest body:\n参数 说明 示例 name 非必填，系部名称，1-20位中文、英文、数字组成，用于模糊匹配 信息 school 非必填，学校名称，1-20位中文、英文、数字组成，用于模糊匹配 温州 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410910929379442690\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;信息技术系\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;classes\u0026#34;: 8 }, { \u0026#34;id\u0026#34;: \u0026#34;1412948697090220034\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;信息技术系\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;classes\u0026#34;: 0 } ], \u0026#34;total\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增系部信息 url: /admin/dept\nmethod: Post\nrequest body:\n参数 说明 示例 name 必填，系部名称，2-20位中文、英文、数字组成 设计创意学院 schoolId 必填，学校编号 1410909562636140546 response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改系部信息 url: /admin/depts\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，系部id 1410910929379442690 name 必填，系部名称，2-20位中文、英文、数字组成 人工智能学院 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除系部信息 url: /admin/dept\nmethod: Delete\nrequest body\n参数 说明 示例 ids 必填非空，待删除系部id数组 [1460218569095688193] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 班级管理模块 查询班级列表 url:/front/class/all\nmethod: Get\nrequest param:\n参数 说明 示例 deptId 必填，系部编号 1412948512863797249 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1410913678187843585\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412947584844611586\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;大数据1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412947735629869057\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;大数据1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948099783573506\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1412948245002862593\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1414833835378409474\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1901\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1414855420751523841\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null } ] } 查询班级详情 url: /admin/class/{classId}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1414855420751523841\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1902\u0026#34;, \u0026#34;school\u0026#34;: null, \u0026#34;dept\u0026#34;: null, \u0026#34;students\u0026#34;: null, \u0026#34;teachers\u0026#34;: null } } 分页查询 url: /admin/classes\nmethod: Get\nrequest body:\n参数 说明 示例 name 非必填，系部名称，1-20位中文、英文、数字组成，用于模糊匹配 19 school 非必填，学校名称，1-20位中文、英文、数字组成，用于模糊匹配 温州 dept 非必填，班级名称，1-20位中文、英文、数字组成，用于模糊匹配 人工 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 2, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1410913678187843585\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1412947584844611586\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;大数据1902\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1412947735629869057\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;大数据1901\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1412948099783573506\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1901\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1412948245002862593\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;数媒1902\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1414833835378409474\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1901\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1414855420751523841\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;电子商务1902\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;dept\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;teachers\u0026#34;: 0 } ], \u0026#34;total\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增班级信息 url: /admin/classes\nmethod: Post\nrequest body:\n参数 说明 示例 name 必填，班级名称，2-20位中文、英文、数字组成 软件2001 deptId 必填，系部编号 1410910929379442690 response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改班级信息 url: /admin/class\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，班级id 1460221775330717697 name 必填，班级名称，2-20位中文、英文、数字组成 软件2002 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除班级信息 url: /admin/class\nmethod: Delete\nrequest body\n参数 说明 示例 ids 必填非空，待删除班级id数组 [1460221775330717697] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 教师管理模块 获取教师下的指定班级的用户id url: /admin/teacher/student/class\nmethod: Get\nrequest param:\nex: /admin/teacher/student/class?classIds=1410913476450226178\u0026amp;classIds=1410913678187843585\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ \u0026#34;1411968879850217474\u0026#34;, \u0026#34;1412572056239054850\u0026#34;, \u0026#34;1415575081450565634\u0026#34;, \u0026#34;1415580979342438401\u0026#34;, \u0026#34;1415591580143726594\u0026#34;, \u0026#34;1415624376656605185\u0026#34;, \u0026#34;1416319359520894977\u0026#34;, \u0026#34;1416600216089423874\u0026#34; ] } 分页查询教师管理的学生信息 url:/admin/teacher/students\nmethod: Get\nrequest param:\n参数 说明 示例 studentName 非必填，学生名称，不超过20个字符，用于模糊匹配 0 className 非必填，系部名称，不超过20个字符，用于模糊匹配 19 schoolName 非必填，学校名称，不超过20个字符，用于模糊匹配 温州 deptName 非必填，班级名称，不超过20个字符，用于模糊匹配 人工 number 非必填，学生学号，不超过50个字符 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1412572056239054850\u0026#34;, //学生id \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;林瑞星\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 350 }, { \u0026#34;id\u0026#34;: \u0026#34;1411968879850217474\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;Rex\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;19002090117\u0026#34;, \u0026#34;totalScore\u0026#34;: 100 }, { \u0026#34;id\u0026#34;: \u0026#34;1415575081450565634\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9Hb6AWXBqOtNWqia9IPa1pg1BGWwTvr9kqNc0vXocpFnChmn90JBZWKozYTZ9jziaxxiaiaNz8GpXzw/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;超级大可爱\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1415580979342438401\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;avatarUrl\u0026#34;: null, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: null, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1415591580143726594\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1902\u0026#34;, \u0026#34;avatarUrl\u0026#34;: null, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: null, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1415624376656605185\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmhead/MAfiat4VDB3a5UmppLCgPyoSORqM3NJ5VSiavMFqItr6Y/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;陈雅婷\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1416319359520894977\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: null, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: null, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1416600216089423874\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmhead/rneMlzCiabb4AnIG0ibqGC9PwRrf0PSdSpFQehXNwHq0I/132\u0026#34;, \u0026#34;phone\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;陈淑媛\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;女\u0026#34;, \u0026#34;number\u0026#34;: null, \u0026#34;totalScore\u0026#34;: 0 } ], \u0026#34;total\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 分页查询教师管理班级的信息 url:/admin/teacher/classes\nmethod: Get\nrequest body:\n参数 说明 示例 userId 非必填，用户id，查询指定用户的班级信息 0 className 非必填，系部名称，1-20位中文、英文、数字组成，用于模糊匹配 19 schoolName 非必填，学校名称，1-20位中文、英文、数字组成，用于模糊匹配 温州 deptName 非必填，班级名称，1-20位中文、英文、数字组成，用于模糊匹配 人工 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1462758787663269890\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1462756593480241154\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1462756205561647105\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;智能制造学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;test5213\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1462755029910818818\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1460221775330717697\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件2002\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1462754988815028225\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1412947735629869057\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;大数据1901\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1462754962114088962\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1412948099783573506\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;数媒1901\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1461714317027176450\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1461672241728188417\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州理工学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;建筑与能源工程\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;土木工程\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1461700754434813954\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913678187843585\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;教师测试账号\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1902\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1460808406588395522\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913678187843585\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1902\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;classId\u0026#34;: \u0026#34;1410913476450226178\u0026#34;, \u0026#34;teacherName\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;schoolName\u0026#34;: \u0026#34;温州职业技术学院\u0026#34;, \u0026#34;deptName\u0026#34;: \u0026#34;人工智能学院\u0026#34;, \u0026#34;className\u0026#34;: \u0026#34;软件1901\u0026#34; } ], \u0026#34;total\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增教师管理班级的信息 url: /admin/teacher/class\nmethod: Post\nrequest body:\n参数 说明 示例 userId 必填，用户id 0 classId 必填，班级id 1410910929379442690 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除教师管理班级的信息 url: /admin/teacher/classes\nmethod: Delete\nrequest body:\n参数 说明 示例 ids 必填非空，待删除班级id数组 [1460221775330717697] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 题库分类模块 查询题库分类列表 url: /question/category/all\nmethod: Get\nrequest param：空参\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1399952455299837953\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;仿冒身份欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399952768576548866\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;购物类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399952923354796033\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;利诱类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399953043047657474\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;虚构险情欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399953164586029058\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;日常生活消费类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399953275995070465\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;钓鱼、木马病毒类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;1399953451224756226\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;新型违法欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null } ] } 查询题库分类详情 url: /admin/question/category/{id}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1399952923354796033\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;利诱类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: null, \u0026#34;questions\u0026#34;: null } } 分页查询题库分类信息 url: /admin/question/categories\nmethod: Get\nrequest body:\n参数 说明 示例 name 非必填，题库分类名称，1-20位中文、英文、数字组成，用于模糊匹配 题目 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1399953451224756226\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;新型违法欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 3 }, { \u0026#34;id\u0026#34;: \u0026#34;1399953275995070465\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;钓鱼、木马病毒类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 3 }, { \u0026#34;id\u0026#34;: \u0026#34;1399953164586029058\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;日常生活消费类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 17 }, { \u0026#34;id\u0026#34;: \u0026#34;1399953043047657474\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;虚构险情欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;1399952923354796033\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;利诱类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 26 }, { \u0026#34;id\u0026#34;: \u0026#34;1399952768576548866\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;购物类欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 13 }, { \u0026#34;id\u0026#34;: \u0026#34;1399952455299837953\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;仿冒身份欺诈\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;questions\u0026#34;: 63 } ], \u0026#34;total\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增题库分类信息 url: /admin/question/category\nmethod: Post\nrequest body:\n参数 说明 示例 name 必填，题库名称，2-20位 测试类 response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 更新题库分类信息 url: /admin/question/category\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，题库分类id 1460221775330717697 name 必填，题库分类名称，2-20位 测试修改类 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除题库分类信息 url: /admin/question/categories\nmethod: Delete\nrequest body\n参数 说明 示例 ids 必填非空，待删除题库分类id数组 [1460221775330717697] response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 题库模块 查询题目分页数据 url: /admin/questions\nmethod: Get\nrequest body:\n参数 说明 示例 categoryId 选填，分类编号，从分类列表查询的接口中获取 0 content 选填，模糊查询题目内容 反诈 type 选填，题目类型，1-单选 2-多选 3-判断 1 level 选填，题目难度（1-10） 1 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1435444478465884162\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;（智能语音）“您好，我是XX金融客服，请问您是否需要资金周转？您。。。。。。，你会？（新疆公安提供）\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;认真听，主动添加该手机号的微信\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;挂断电话，直接举报改号码\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444479216664578\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“xx，我是你二叔。我这边出了点急事需要周转，你转3000块给我吧。”当收到亲友发来的类似消息时，正确的做法是\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;与对方电话或视频确认身份\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;亲戚有难，立即转账\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444480009388034\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“xx您好，由于快递员疏忽，您的快递在运送途中丢失，我们将赔偿你2倍损失，点击以下链接填写个人信息。”接到类似电话，你会\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;联系官方客服查询快递信息\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;点击链接并按要求填写信息\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444480810500097\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“法官”称你涉嫌犯罪，要你将钱转入安全账户，正确的做法是\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;先核实对方身份\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;立刻转钱\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444481439645698\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“高薪刷单，一天轻松赚300-400，联系加QQ：325xxx”收到类似短信，你会\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;不理会\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;加对方QQ，获得兼职机会\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444482240757762\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“理财经理人”建议你父母抵押房产，以房养老，你应该怎么做\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;先考察公司资质\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;抵押房产\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;A\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444483029286914\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“你确认收货以后我才会发货噢。”遇到这种卖方怎么做才是正确的？\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;赶快确认\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;坚持收货后确认\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444483708764162\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“您好，客服操作给您设置了铂金会员，24点前不取消每月银行自动扣款500元。您购买天猫超市享淘卡可以避免银行扣费。”此时正确做法是\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;赶紧购买，并提供给客服卡号和卡密\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;联系官方客服求证\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444484648288258\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“您好，您购买的XX服装因铅汞超标会致癌，我们正在收回商品并给您双倍赔偿哦~亲。”接到类似电话，你会？（天津公安提供）\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;赶紧要赔偿，按照对方指示操作\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;联系官方客服或卖家进行核实确认\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1435444485449400321\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;“您好，您在我店购买的港风大码上衣现已降价。请点击以下链接领取差价退款。”\\r\\n 接到类似短信，你会\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;点击链接填写信息 \u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;联系官方客服核实对方身份\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; } ], \u0026#34;total\u0026#34;: \u0026#34;125\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;13\u0026#34; } } 查询题目详情 url: /admin/question/{id}\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1435444478465884162\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;默认题库\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;（智能语音）“您好，我是XX金融客服，请问您是否需要资金周转？您。。。。。。，你会？（新疆公安提供）\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;A\u0026#34;: \u0026#34;认真听，主动添加该手机号的微信\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;挂断电话，直接举报改号码\u0026#34; }, \u0026#34;level\u0026#34;: 1, \u0026#34;answers\u0026#34;: [ \u0026#34;B\u0026#34; ], \u0026#34;creator\u0026#34;: null } } 批量新增题目（未实现） 新增题目数据 url: /admin/question\nmethod: Post\nrequest body:\n参数 说明 示例 type 必填，题目类型，1-单选，2-多选，3-判断 1 categoryId 必填，题目分类id 1461545162319601666 content 必填，题目内容,字数(1, 255) 选B options 必填，选项信息 {\u0026ldquo;A\u0026rdquo;:\u0026ldquo;123\u0026rdquo;, \u0026ldquo;B\u0026rdquo;:\u0026ldquo;456\u0026rdquo;} answers 必填，答案数组 [\u0026ldquo;A\u0026rdquo;] level 必填，难度(1-10) 1 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 更新题目数据 url: /admin/question\nmethod: Put\nrequest body\n参数 说明 示例 id 必填，题目编号 1461545228578779138 type 必填，题目类型，1-单选，2-多选，3-判断 1 categoryId 必填，题目分类id 1461545162319601666 content 必填，题目内容,字数(1, 255) 选B options 必填，选项信息 {\u0026ldquo;A\u0026rdquo;:\u0026ldquo;123\u0026rdquo;, \u0026ldquo;B\u0026rdquo;:\u0026ldquo;456\u0026rdquo;} answers 必填，答案数组 [\u0026ldquo;A\u0026rdquo;] level 必填，难度(1-10) 1 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除题目数据 url: /admin/questions\nmethod: Delete\nrequest body\n参数 说明 示例 ids 必填非空，待删除题库分类id数组 [1461545365652828161, 1461546703618969601] response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 组卷模块 获取要做试卷的学生id url: /admin/exam/users/{examId}\nmethod:Get\nrequest body: 空\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ \u0026#34;1411968879850217474\u0026#34; ] } 分配需要做试卷的学生 url:/admin/exam/students\nmethod: Post\nrequest body\n参数 说明 示例 examId 必填，试卷编号 1463340467169689601 studentIds 必填，学生编号 [\u0026ldquo;1411968879850217474\u0026rdquo;] 查询测试卷分页数据 url: /admin/exams\nmethod: Get\nrequest body:\n参数 说明 示例 tiltile 非必填，题目标题模糊匹配 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1462765532131049474\u0026#34;, \u0026#34;students\u0026#34;: 5, \u0026#34;title\u0026#34;: \u0026#34;测试卷\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;测试卷详情\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-01 08:30:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-01 09:30:00\u0026#34;, \u0026#34;questions\u0026#34;: null, \u0026#34;totalNum\u0026#34;: 5, \u0026#34;totalScore\u0026#34;: 26, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; } ], \u0026#34;total\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 查询测试卷详情（用于修改） url: /admin/exam/{id}\nmethod: Get\nrequest body: 空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1462765532131049474\u0026#34;, \u0026#34;students\u0026#34;: 5, \u0026#34;title\u0026#34;: \u0026#34;测试卷\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;测试卷详情\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;试卷\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-01 08:30:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-01 09:30:00\u0026#34;, \u0026#34;questions\u0026#34;: { \u0026#34;1435444478465884162\u0026#34;: 5, \u0026#34;1435444480810500097\u0026#34;: 5, \u0026#34;1435444479216664578\u0026#34;: 5, \u0026#34;1435444480009388034\u0026#34;: 5, \u0026#34;1435444481439645698\u0026#34;: 6 }, \u0026#34;totalNum\u0026#34;: 5, \u0026#34;totalScore\u0026#34;: 26, \u0026#34;creator\u0026#34;: null } } 统计用户的答题情况 url: /admin/exam/statistics/{examId}\nmethod: Get\nrequest parm: 空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;通用测试\u0026#34;, \u0026#34;correctQuestion\u0026#34;: 6, \u0026#34;avgScore\u0026#34;: 15.0000, \u0026#34;present\u0026#34;: 2, \u0026#34;absent\u0026#34;: 0, \u0026#34;totalScore\u0026#34;: 20, \u0026#34;totalQuestion\u0026#34;: 4, \u0026#34;total\u0026#34;: 2 } } 查询用户的答题情况 url: /admin/exam/detail/{examId}\nmethod: Get\nrequest param:\n参数 说明 示例 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;uid\u0026#34;: \u0026#34;1435625608666173441\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;RH......\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIxXJTVJvRmxBpMpXFQDzJdQzJIpj3NEr2xBqgbic4hlkOdjjcheR0TXGicrdEQWaCodYQkVfpzZosg/132\u0026#34;, \u0026#34;completed\u0026#34;: true, \u0026#34;score\u0026#34;: 10, \u0026#34;correctNum\u0026#34;: 2, \u0026#34;totalScore\u0026#34;: 20, \u0026#34;totalNum\u0026#34;: 4 }, { \u0026#34;uid\u0026#34;: \u0026#34;1412572056239054850\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;林瑞星(Rex)\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://thirdwx.qlogo.cn/mmopen/vi_32/LDUQrb7oLTQ4JiccNicdPhHQ0jTjs4ic0mVpUb8uP9ic4jS1ydEzeYuQDu9ZsJHLYDpMT6atMktQFEBSE1dBfIVlMw/132\u0026#34;, \u0026#34;completed\u0026#34;: true, \u0026#34;score\u0026#34;: 20, \u0026#34;correctNum\u0026#34;: 4, \u0026#34;totalScore\u0026#34;: 20, \u0026#34;totalNum\u0026#34;: 4 } ], \u0026#34;total\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 新增测试卷 url: /admin/exam\nmethod: Post\nrequest body:\n参数 说明 示例 students 必填，学生id数组 [1410913476450226178] title 必填，测试卷标题 测试卷 desc 必填，测试卷描述 测试卷详情 type 必填，测试类型 1-试卷(只有一次答题机会并且记录分数), 2-练习(有无数次答题机会，但不记录分数) 1 startTime 必填，开始时间，时间戳 1638318600000 endTime 必填，结束时间，时间戳 1638322200000 questions 必填，题目信息，key-题目id，value-题目分数 {\u0026ldquo;1435444478465884162\u0026rdquo;: 5,\u0026ldquo;1435444479216664578\u0026rdquo;: 5,\u0026ldquo;1435444480009388034\u0026rdquo;: 5,\u0026ldquo;1435444480810500097\u0026rdquo;: 5,\u0026ldquo;1435444481439645698\u0026rdquo;: 6} response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改测试卷 url: /admin/exam\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，测试卷id 1462796362854526978 title 必填，测试卷标题 测试卷 desc 必填，测试卷描述 测试卷详情 type 必填，测试类型 1-试卷(只有一次答题机会并且记录分数), 2-练习(有无数次答题机会，但不记录分数) 1 startTime 必填，开始时间，时间戳 1638318600000 endTime 必填，结束时间，时间戳 1638322200000 questions 必填，题目信息，key-题目id，value-题目分数 {\u0026ldquo;1435444478465884162\u0026rdquo;: 5,\u0026ldquo;1435444479216664578\u0026rdquo;: 5,\u0026ldquo;1435444480009388034\u0026rdquo;: 5,\u0026ldquo;1435444480810500097\u0026rdquo;: 5,\u0026ldquo;1435444481439645698\u0026rdquo;: 5} response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除测试卷 url: /admin/exam/{id}\nmethod: Delete\nrequest body：空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 活动模块 获取参与活动的学生id url: /admin/activity/users/{activityId}\nmethod: Get\nrequeset body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ \u0026#34;1412572056239054850\u0026#34; ] } 分配需要参与的学生 url: /admin/activity/students\nmethod: Post\nrequest body\n参数 说明 示例 activityId 必填，活动编号 1465876559196704770 studentIds 必填，学生编号 [\u0026ldquo;1412572056239054850\u0026rdquo;, \u0026ldquo;1420166661603852290\u0026rdquo;, \u0026ldquo;1416600216089423874\u0026rdquo;] response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 分页查询活动数据 url: /admin/activities\nmethod:Get\nrequest body\n参数 说明 示例 page 非必填，不能小于1 1 size 非必填，必须在10~50之间 20 orderFiled 非必填，排序字段，默认id id order 非必填，排序方式，可选值asc, desc，默认asc asc response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1474631279756939265\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;反诈公开课活动\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试详情2\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;测试地址\u0026#34;, \u0026#34;students\u0026#34;: 2, \u0026#34;signTime\u0026#34;: \u0026#34;2021-12-25 14:45:00\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2022-01-01 00:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2022-02-01 00:00:00\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1473846570607828993\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;测试二维码\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;测试\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;students\u0026#34;: 0, \u0026#34;signTime\u0026#34;: \u0026#34;2021-12-23 10:43:23\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-24 13:42:25\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-25 14:42:23\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;教师测试账号\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1466978161962057729\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;students\u0026#34;: 6, \u0026#34;signTime\u0026#34;: \u0026#34;2021-12-30 11:49:59\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2022-01-01 16:49:59\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2022-01-02 22:49:59\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;教师测试账号\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;1465876559196704770\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;活动测试\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试详情\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;students\u0026#34;: 3, \u0026#34;signTime\u0026#34;: \u0026#34;2021-12-02 08:30:00\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2021-12-02 09:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-12-02 12:00:00\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;超级管理员\u0026#34; } ], \u0026#34;total\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } } 查询活动详情（用于修改） url: /admin/activity/{id}\nmethod: Get\nrequest body: 空\nresponse body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1474631279756939265\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;反诈公开课活动\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;活动测试详情2\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;测试地址\u0026#34;, \u0026#34;students\u0026#34;: 2, \u0026#34;signTime\u0026#34;: \u0026#34;2021-12-25 14:45:00\u0026#34;, \u0026#34;startTime\u0026#34;: \u0026#34;2022-01-01 00:00:00\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2022-02-01 00:00:00\u0026#34;, \u0026#34;creator\u0026#34;: null//不能修改 } } 新增活动 url: /admin/activity\nmethod: Post\nrequest body:\n参数 说明 示例 students 必填，学生id [1412572056239054850, 1415624376656605185] title 必填，活动标题，不超过50个字 活动测试 address 非必填，活动地址，不超过255个字 活动测试地址 desc 非必填，活动描述，不超过255个字 活动测试详情 signTime 必填，签到时间 1638405000000 startTime 必填，活动开始时间 1638406800000 endTime 必填，活动结束时间 1638417600000 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 修改活动 url: /admin/activity\nmethod: Put\nrequest body:\n参数 说明 示例 id 必填，活动id 1465911854034108417 title 必填，活动标题，不超过50个字 活动测试 address 非必填，活动地址，不超过255个字 活动测试地址 desc 非必填，活动描述，不超过255个字 活动测试详情 signTime 必填，签到时间 1638405000000 startTime 必填，活动开始时间 1638406800000 endTime 必填，活动结束时间 1638417600000 response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 删除活动 url: /admin/activity/{id}\nmethod: Delete\nrequest body:空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null } 生成签到二维码 二维码中的qrcode有效期为1分钟\nurl: /admin/activity/qrcode/{activityId}\nmethod: Get\nrequest body:\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAIAAAD2HxkiAABKIklEQVR42uzd93NcSX4geP0jG7EXcT9e3N3+crt7cREnnW4Vq7jVakeakcZIPdM9M632js2mB0mQBAgQ3ntTKI/y3nvvvffee18F9OUrsFs9M9097QiSo8zJxoAIoOq9V/l5329mvpfvzz6FBRZYnmv5M3gIYIEFIoQFFogQFlhggQhhgQUihAUWWCBCWGCBCGGBBRaIEBZYIEJYYIEFIoQFFogQ....(此处省略好多好多字)\u0026#34; } ","permalink":"https://rexhub.space/posts/proj/doc/fraudprevention%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","summary":"FraudPrevention后台管理系统开发文档 baseUrl = \u0026ldquo;http://localhost:8090/fraud-prevention/api\u0026rdquo;\n服务器Url=\u0026ldquo;http://1.117.91.88:52016/fraud-prevention/api\u0026rdquo;\n通用模块 获取验证码 url: /admin/captcha\nmethod: Get\nrequest body: 空\nresponse body\n\u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { token: \u0026#34;xxxxxx\u0026#34;, //验证码token captchaImg: \u0026#34;data:image/jpeg;base64,xxxxxx\u0026#34;, //base64格式的验证码图片 } } 获取所有模块信息 url: /admin/modules\nmethod: Get\nrequest body: 空\nresponse body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;moduleCode\u0026#34;: \u0026#34;USER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;moduleCode\u0026#34;: \u0026#34;ROLE\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;moduleCode\u0026#34;: \u0026#34;PERM\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;权限管理\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;moduleCode\u0026#34;: \u0026#34;TEACHER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34; } ] } 需提前登录","title":"FraudPrevention后台管理系统开发文档"},{"content":"微信支付 微信支付功能的实现需要调用微信官方的支付接口，而微信支付也有多种形式，如:JSAPI支付、APP支付、Native支付、小程序支付等等，接口也有V2、V3版本，这里主要说明Native的V3版本的使用。特别需要注意的是，使用微信支付功能的接口需要有商户号。\n在支付的功能中，必不可少的是商品订单和支付订单，商品订单是本地后台系统生成的，而我这里使用的案例是用罚款单为例并非商品。支付订单是微信服务器生成的，只需要调用微信支付API\n微信支付官方文档\n微信支付前期准备 开通微信支付功能 对于商家来说，想要开通微信支付，必须要去微信商户平台注册（https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F），然后把工商登记证明、企业银行账户开户证明、组织机构代码证提交上去，经过半天的审核，如果没有问题，你就开通了微信支付功能。\n如果想要在网站或者小程序上面使用微信支付，还要在微信公众平台上面关联你自己的微信商户账号。前提是你的微信开发者账号必须是企业身份，个人身份的开发者账号是无法调用微信支付API的。\n引入官方的SDK包 说明下这里的微信官方sdk主要对签名方面、加密解密方面做了较好的支持，其他方面还是要自己构造参数、发送请求。\nsdk官方文档\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.wechatpay-apiv3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;wechatpay-apache-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; WechatPay.java\n这个是我对sdk做了个进一步的封装，这里是初始化\npackage com.example.emos.api.common.util; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import com.example.emos.api.common.exception.EmosException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder; import com.wechat.pay.contrib.apache.httpclient.auth.AutoUpdateCertificatesVerifier; import com.wechat.pay.contrib.apache.httpclient.auth.PrivateKeySigner; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Credentials; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Validator; import com.wechat.pay.contrib.apache.httpclient.util.AesUtil; import com.wechat.pay.contrib.apache.httpclient.util.PemUtil; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpEntity; import org.apache.http.StatusLine; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.util.EntityUtils; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.*; import java.net.URISyntaxException; import java.nio.charset.StandardCharsets; import java.security.*; /** * Description: 微信支付工具类 * * @author Rex * @date 2021-10-18 12:54 */ @Component @Slf4j public class WechatPay { /** * 微信支付APPID */ @Value(\u0026#34;${wx.pay.app-id}\u0026#34;) public String appId; /** * 微信商户id */ @Value(\u0026#34;${wx.pay.mch-id}\u0026#34;) public String mchId; /** * 序列号 */ @Value(\u0026#34;${wx.pay.serial-no}\u0026#34;) public String serialNo; /** * 数字密钥地址 */ @Value(\u0026#34;${wx.pay.private_key_path}\u0026#34;) private String privateKeyPath; /** * 私钥 */ @Value(\u0026#34;${wx.pay.api_v3_key}\u0026#34;) private String apiV3Key; @Value(\u0026#34;${wx.pay.notify_url}\u0026#34;) private String notifyUrl; private CloseableHttpClient getClient(){ WechatPayHttpClientBuilder builder; try { //生成签名 PrivateKey privateKey = PemUtil.loadPrivateKey(new FileInputStream(privateKeyPath)); AutoUpdateCertificatesVerifier verifier = new AutoUpdateCertificatesVerifier( new WechatPay2Credentials(mchId, new PrivateKeySigner(serialNo, privateKey)), apiV3Key.getBytes(StandardCharsets.UTF_8)); builder = WechatPayHttpClientBuilder.create() .withMerchant(mchId, serialNo, privateKey) .withValidator(new WechatPay2Validator(verifier)); } catch (FileNotFoundException e) { throw new EmosException(\u0026#34;数字签名路径有误：\u0026#34; + e.getMessage()); } return builder.build(); } ...... } application.yml文件中配置参数 提前在配置文件中配置好必要的参数\n# 我的 app-id: wx66f359799ea4bb7d app-secret: a8a27ab43054b6d7b2b28fbd0cc14137 # 老师的企业账户 pay: app-id: \u0026#34;xxxxxxxxxxxxx\u0026#34; # appId mch-id: \u0026#34;xxxxxxxx\u0026#34; # 商户id serial-no: \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; # 请求随机串 notify_url: \u0026#34;https://公网地址(可用内网穿透的地址)/emos-api/amect/receiveMessage\u0026#34; private_key_path: \u0026#34;src/main/resources/apiclient_key.pem\u0026#34; # 数字证书的地址 api_v3_key: \u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34; # apiV3key 使用内网穿透技术 因为我们在支付订单结束之后需要让微信系统告诉我们后台系统支付结果，那要怎么告诉微信呢，让他访问localhost吗？肯定访问不到，访问我们主机的ip吗？可是我们本地电脑的IP没有固定的公网ip，局域网下的ip虽然是固定的，但是微信系统也访问不到，他们又不在我们的局域网下，广域网的ip虽然是访问的到，但是不是固定的。我们可以把系统部署到云服务器上，让微信系统访问我们云服务上的后台系统，不过在测试阶段，我们都是用自己的本地上的系统，我们可以用内网穿透的技术，将自己系统的端口号映射到外网，这样微信系统就可以访问的到了。\n目前常见的内网穿透技术\n花生壳 Natapp 量子互联 ngrok(个人最常用)：免费 Frp：用自己的公网服务做代理，免费，但是需要一台云服务器 创建支付订单 这里需要着重说明创建支付订单的时候需要一个唯一ID，可以用UUID生成，若id重复了，微信服务器会提示商品ID已经用过一次了\nURL：https://api.mch.weixin.qq.com/v3/pay/transactions/native\n请求参数（必要）：\n参数 含义 类型 例子 appid 公众号ID String wxd678efh567hg6787 mch_id 商户号ID String 1230000109 description 商品描述 string Image形象店-深圳腾大-QQ公仔 out_trade_no 商品订单号 String 20150806125346 notify_url 通知地址 String https://www.weixin.qq.com/wxpay/pay.php amount 订单金额 Object {total: 100(单位分), currency: \u0026ldquo;CNY\u0026rdquo;} 响应：\n参数 含义 类型 例子 code_url 二维码链接 String weixin://wxpay/bizpayurl/up?pr=NwY5Mz9\u0026amp;groupid=00 以下是WechatPay.java中创建支付的示例代码\n/** * 生成订单 * @param outTradeNo 订单编号，相当于amect中的uuid * @param amount 金额 * @return 支付二维码 */ public String generateOrder(String outTradeNo, Integer amount){ ByteArrayOutputStream bos = null; try { //获取HTTP客户端 CloseableHttpClient client = getClient(); //构造请求 /** * 下单URL */ String generateOrder = \u0026#34;https://api.mch.weixin.qq.com/v3/pay/transactions/native\u0026#34;; URIBuilder uriBuilder = new URIBuilder(generateOrder); HttpPost httpPost = new HttpPost(uriBuilder.build()); httpPost.addHeader(\u0026#34;Content-type\u0026#34;,\u0026#34;application/json; charset=utf-8\u0026#34;); httpPost.addHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); bos = new ByteArrayOutputStream(); ObjectMapper objectMapper = new ObjectMapper(); ObjectNode rootNode = objectMapper.createObjectNode(); rootNode.put(\u0026#34;appid\u0026#34;, appId); rootNode.put(\u0026#34;mchid\u0026#34;, mchId); rootNode.put(\u0026#34;description\u0026#34;, \u0026#34;...发起的测试\u0026#34;); rootNode.put(\u0026#34;notify_url\u0026#34;, notifyUrl); rootNode.put(\u0026#34;out_trade_no\u0026#34;, outTradeNo); rootNode.putObject(\u0026#34;amount\u0026#34;) .put(\u0026#34;total\u0026#34;, amount); rootNode.putObject(\u0026#34;scene_info\u0026#34;) .put(\u0026#34;payer_client_ip\u0026#34;, \u0026#34;localhost\u0026#34;); objectMapper.writeValue(bos, rootNode); httpPost.setEntity(new StringEntity(bos.toString(\u0026#34;UTF-8\u0026#34;), StandardCharsets.UTF_8)); //执行并获取放回结果 CloseableHttpResponse response = client.execute(httpPost); JSONObject res = JSONUtil.parseObj(EntityUtils.toString(response.getEntity())); String codeUrl = (String) res.get(\u0026#34;code_url\u0026#34;); if (codeUrl == null){ throw new EmosException(\u0026#34;支付失败：\u0026#34; + res.get(\u0026#34;message\u0026#34;).toString()); } return codeUrl; } catch (Exception e) { log.error(\u0026#34;支付失败\u0026#34;, e); throw new EmosException(\u0026#34;支付失败: \u0026#34;+e.getMessage()); } finally { if (bos != null){ try { bos.close(); } catch (IOException e) { throw new EmosException(\u0026#34;关闭流失败: \u0026#34; + e.getMessage()); } } } } 执行付款 执行付款的时候需要用户向微信平台（注意是微信平台而不是自己的系统）发起查询支付订单的请求，核实订单信息，确定后再执行扣款。因此这个步骤就交给微信平台了。\n确认付款结果 成功支付后，需要回馈商家支付结果，可以直接通过微信系统的回调函数告诉商家系统，但是万一出现网络问题商家系统没收到回调呢，可以让商家主动查询付款结果，比如这里就可以点击支付成功按钮，前端页面就会向商户系统发起Ajax请求，商户系统会主动向微信服务器发起查询请求，核对是否支付成功，若支付成功就修改商品订单的状态为已付款。\n推送付款结果给前端页面 不仅仅商户系统需要确定支付状态，用户也需要知道，所以前端也需要发聩用户订单支付结果。那咋知道呢？\n一种方法就是通过轮询，前端弹出支付二维码以后，创建一个定时器，每隔几秒向商户系统发出请求，查询商品订单是否已付款。这个操作虽然简单，但是增大了网络开销，每次的http都需要创建连接和协议握手\n另一种方式就是通过WebSocket让前端和后端建立长连接。传统的HTTP协议是短链接，请求结束之后，HTTP连接就断开了。而WebSocket的长连接可以让前端后端使用某个连接反复发送和接受数据，很常见的也很基础的应用就是可以通过长连接创建一个聊天室。WebSocket省去了反复连接和协议握手的时间。若担心长时间建立长连接耗费资源，可以给WebSocket连接设置一个超时时间。\n服务器把每个WebSocket连接都缓存起来，然后想要推送数据给前端的时候，就从缓存中找到与之对应的连接即可。\n","permalink":"https://rexhub.space/posts/api/pay/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/","summary":"微信支付 微信支付功能的实现需要调用微信官方的支付接口，而微信支付也有多种形式，如:JSAPI支付、APP支付、Native支付、小程序支付等等，接口也有V2、V3版本，这里主要说明Native的V3版本的使用。特别需要注意的是，使用微信支付功能的接口需要有商户号。\n在支付的功能中，必不可少的是商品订单和支付订单，商品订单是本地后台系统生成的，而我这里使用的案例是用罚款单为例并非商品。支付订单是微信服务器生成的，只需要调用微信支付API\n微信支付官方文档\n微信支付前期准备 开通微信支付功能 对于商家来说，想要开通微信支付，必须要去微信商户平台注册（https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F），然后把工商登记证明、企业银行账户开户证明、组织机构代码证提交上去，经过半天的审核，如果没有问题，你就开通了微信支付功能。\n如果想要在网站或者小程序上面使用微信支付，还要在微信公众平台上面关联你自己的微信商户账号。前提是你的微信开发者账号必须是企业身份，个人身份的开发者账号是无法调用微信支付API的。\n引入官方的SDK包 说明下这里的微信官方sdk主要对签名方面、加密解密方面做了较好的支持，其他方面还是要自己构造参数、发送请求。\nsdk官方文档\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.wechatpay-apiv3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;wechatpay-apache-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; WechatPay.java\n这个是我对sdk做了个进一步的封装，这里是初始化\npackage com.example.emos.api.common.util; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import com.example.emos.api.common.exception.EmosException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder; import com.wechat.pay.contrib.apache.httpclient.auth.AutoUpdateCertificatesVerifier; import com.wechat.pay.contrib.apache.httpclient.auth.PrivateKeySigner; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Credentials; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Validator; import com.wechat.pay.contrib.apache.httpclient.util.AesUtil; import com.wechat.pay.contrib.apache.httpclient.util.PemUtil; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpEntity; import org.apache.http.StatusLine; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.util.EntityUtils; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.*; import java.","title":"微信支付接口"},{"content":"腾讯视频会议的使用-TRTC技术 概述： TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n后端的准备 首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n//UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥 usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire))) 关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\npackage com.example.emos.api.config.tencet; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import org.bson.internal.Base64; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.zip.Deflater; /** * Description: 腾讯TRTC工具类 * * @author Rex * @date 2021-09-29 10:48 */ import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; @Component public class TRTCUtil { @Value(\u0026#34;${tencent.trtc.appId}\u0026#34;) private int appId; @Value(\u0026#34;${tencent.trtc.expire}\u0026#34;) private int expire; @Value(\u0026#34;${tencent.trtc.secretKey}\u0026#34;) private String secretKey; /** * 计算UserSig签名 * 函数内部使用HMAC-SHA256 非对称加密算法，对SdkAppId、userID和ExpireTime进行加密。 * @param userId 用户id * @return 用户签名 */ public String genUserSig(String userId) { return GenTLSSignature(appId, userId, expire, null, secretKey); } /** * 生成TLS票据 * @param sdkappid 应用的id * @param userId 用户id * @param expire 有效期，单位是秒 * @param userbuf 默认填写null * @param priKeyContent 生成tls票据使用的私钥内容 * @return 如果出错，会返回为空，或者有异常打印，成功返回有效的票据 */ private String GenTLSSignature(long sdkappid, String userId, long expire, byte[] userbuf, String priKeyContent) { if (StrUtil.isEmpty(priKeyContent)) { return \u0026#34;\u0026#34;; } long currTime = System.currentTimeMillis() / 1000; JSONObject sigDoc = new JSONObject(); sigDoc.set(\u0026#34;TLS.ver\u0026#34;, \u0026#34;2.0\u0026#34;); sigDoc.set(\u0026#34;TLS.identifier\u0026#34;, userId); sigDoc.set(\u0026#34;TLS.sdkappid\u0026#34;, sdkappid); sigDoc.set(\u0026#34;TLS.expire\u0026#34;, expire); sigDoc.set(\u0026#34;TLS.time\u0026#34;, currTime); String base64UserBuf = null; if (null != userbuf) { base64UserBuf = Base64.encode(userbuf); sigDoc.set(\u0026#34;TLS.userbuf\u0026#34;, base64UserBuf); } String sig = hmacsha256(sdkappid, userId, currTime, expire, priKeyContent, base64UserBuf); if (sig.length() == 0) { return \u0026#34;\u0026#34;; } sigDoc.set(\u0026#34;TLS.sig\u0026#34;, sig); Deflater compressor = new Deflater(); compressor.setInput(sigDoc.toString().getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;))); compressor.finish(); byte[] compressedBytes = new byte[2048]; int compressedBytesLength = compressor.deflate(compressedBytes); compressor.end(); return new String(base64EncodeUrl(Arrays.copyOfRange(compressedBytes, 0, compressedBytesLength))); } /** * 用HmacSHA256算法进行加密 * @param sdkappid 应用id * @param userId 用户id * @param currTime 当前时间戳 * @param expire 有效期，单位秒 * @param priKeyContent 密钥内容 * @param base64Userbuf 默认填写null * @return 加密结果 */ private static String hmacsha256(long sdkappid, String userId, long currTime, long expire, String priKeyContent, String base64Userbuf) { String contentToBeSigned = \u0026#34;TLS.identifier:\u0026#34; + userId + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.sdkappid:\u0026#34; + sdkappid + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.time:\u0026#34; + currTime + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.expire:\u0026#34; + expire + \u0026#34;\\n\u0026#34;; if (null != base64Userbuf) { contentToBeSigned += \u0026#34;TLS.userbuf:\u0026#34; + base64Userbuf + \u0026#34;\\n\u0026#34;; } try { byte[] byteKey = priKeyContent.getBytes(\u0026#34;UTF-8\u0026#34;); Mac hmac = Mac.getInstance(\u0026#34;HmacSHA256\u0026#34;); SecretKeySpec keySpec = new SecretKeySpec(byteKey, \u0026#34;HmacSHA256\u0026#34;); hmac.init(keySpec); byte[] byteSig = hmac.doFinal(contentToBeSigned.getBytes(\u0026#34;UTF-8\u0026#34;)); return Base64.encode(byteSig); } catch (UnsupportedEncodingException e) { return \u0026#34;\u0026#34;; } catch (NoSuchAlgorithmException e) { return \u0026#34;\u0026#34;; } catch (InvalidKeyException e) { return \u0026#34;\u0026#34;; } } /** * 将base64字符串转换成URL格式的字符串 * @param input base64数据 * @return url可接受的base64数据 */ private static byte[] base64EncodeUrl(byte[] input) { byte[] base64 = Base64.encode(input).getBytes(); for (int i = 0; i \u0026lt; base64.length; ++i) switch (base64[i]) { case \u0026#39;+\u0026#39;: base64[i] = \u0026#39;*\u0026#39;; break; case \u0026#39;/\u0026#39;: base64[i] = \u0026#39;-\u0026#39;; break; case \u0026#39;=\u0026#39;: base64[i] = \u0026#39;_\u0026#39;; break; default: break; } return base64; } } 将UserSig返回给前端 接下的工作就非常简单了，将userId、appId、userSig生成返回给前端，接下来的写法就不多做说明，下面贴上返回的json格式\n{ \u0026#34;code\u0026#34;:200, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;userSig\u0026#34;:\u0026#34;eJyrVgrxCdZLrSjILEpVsrIwMzEw0AELlaUWKVkpGekZKEH4xSnZiQUFmSlKVoZANaZmlgZGUJWZKal5JZlpmRANJjD1melArmdhWUV6bnGZa3pVWZV5uXaqRZFbZlBJSopjuWNEYpZ-hllZqltiQEaUV7ktVGNJZi7QJYZmxiYGhuYmZqa1AFiAMM0_\u0026#34;, \u0026#34;userId\u0026#34;:24, \u0026#34;appId\u0026#34;:\u0026#34;1400569020\u0026#34; } } 前端 检查环境 Trtc.checkSystemRequirements() ，这个函数用于判断当前浏览器系统是否可以满足trtc的使用环境，在创建trtc之前要用这个方法检查一下，这个函数是异步的，要使用同步可以用\ntrtc.checkSystemRequirements().then(()=\u0026gt;{ // 同步的函数 }) 日志 Trtc.Logger.setLogLevel(Trtc.Logger.LogLevel.ERROR)，设置trtc的日志输出级别\n创建TrtcClient Trtc.createClient()，需要传入mode、sdkAppId、userId、userSig\n使用示例:\nlet client = TRTC.createClient({ mode: \u0026#39;rtc\u0026#39;, sdkAppId: that.appId, userId: that.userId + \u0026#39;\u0026#39;, userSig: that.userSig }); 监听新增远端流 client.on(\u0026ldquo;stream-add\u0026rdquo;, event=\u0026gt;{})，当远端用户发布流后触发，一般在这个回调函数里要订阅远端流。通过远端流来获取新增的用户id，再更新到用户列表里；订阅远端流需要调用client.subscribe(remoteStream)，这里的remote可以由remote.stream调用获取。订阅好了remoteStream，就可以通过remoteStream.getUserId()获取用户信息。以下是代码示例：\nclient.on(\u0026#39;stream-added\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //订阅远端流 client.subscribe(remoteStream); //从远端流获得远程用户userId(创建TrtcClient对象时候的参数) let userId = remoteStream.getUserId(); that.stream[userId] = remoteStream; }); 监听远端流订阅成功 client.on(\u0026ldquo;stream-subscribed\u0026rdquo;, event=\u0026gt;{}), 若检测到客户端也调用了subscribe()，订阅了远端流，则触发该回调函数。下面是使用示例，remoteStream.play(userId + \u0026ldquo;\u0026quot;)会播放该用户id的音视频讯号\nclient.on(\u0026#39;stream-subscribed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; let userId = remoteStream.getUserId(); //找到视频墙中某个远端用户的格子，把其中用于显示视频的DIV，置顶覆盖用户信息 $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: 1 }); //在这个置顶的DIV中播放远端音视频讯号 remoteStream.play(userId + \u0026#39;\u0026#39;); }); 监听远端删除流 client.on(\u0026ldquo;stream-remove\u0026rdquo;, event=\u0026gt;{}),当远端用户退出的时候调用该回调函数。一般的，再这个函数里会关闭和该用户有关的信息，以下是代码示例\n//订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //取消订阅该远端流 client.unsubscribe(remoteStream); let userId = remoteStream.getUserId(); //TODO 在页面右侧的用户列表中删除该用户 //停止播放远端流视频，并且关闭远端流 remoteStream.stop(); remoteStream.close(); //删除模型层JSON中保存的远端流对象 delete that.stream[userId]; //把视频墙中该用户格子的视频DIV控件置底，显示用户基本信息 $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); }); 加入会议室 client.join({ roomId: that.roomId})，加入会议，这个roomId一般由后端生成获得。因为这个函数也是异步函数，所以要进入会议室后创建本地流、播放本地音视频、配置信息之类的要在client.join({ roomId: that.roomId}).then()的then里面调用，以下是代码示例\nclient .join({ roomId: that.roomId }) .then(() =\u0026gt; { //成功进入会议室，然后创建本地流 let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: true, video: true }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); //设置分辨率 //初始化本地音视频流 localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }).then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //视频墙中第一个格子中的视频DIV置顶 $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); //播放本地音视频流 localStream.play(\u0026#39;localStream\u0026#39;); //向远端用户推送本地流 client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }).catch(error =\u0026gt; { console.error(\u0026#39;进入房间失败: \u0026#39; + error); }); 订阅语音音量事件 client.on(\u0026ldquo;audio-volumn\u0026rdquo;, event=\u0026gt;{})，可以监听本地和远端的麦克风音量变化，一般会配合client.enableAudioVolumeEvaluation(30)使用，他会指定每隔一段事件调用这个事件，这里是30ms。下面是使用示例\n//订阅语音事件（无论本地还是远端说话，都会触发这个事件） client.on(\u0026#39;audio-volume\u0026#39;, event =\u0026gt; { event.result.forEach(({ userId, audioVolume, stream }) =\u0026gt; { //说话声音超过5，就设置话筒音量动画 if (audioVolume \u0026gt; 5) { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `${100 - audioVolume * 3}%`); } else { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `100%`); } }); }); // 开启音量回调函数，并设置每 30ms 触发一次事件 client.enableAudioVolumeEvaluation(30); 监听远断流删除流 client.on(\u0026lsquo;stream-removed\u0026rsquo;, event-\u0026gt;{})，这个是监听到远端退出会议的时候调用的方法，以下是使用示例\n//订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; client.unsubscribe(remoteStream); //取消订阅该远端流的所有事件 let userId = remoteStream.getUserId(); //上线用户列表中删除该用户 let i = that.userList.findIndex(function(one) { return one.userId == userId; }); that.userList.splice(i, 1); //停止播放远端流视频，并且关闭远端流 remoteStream.stop(); remoteStream.close(); //把远端流从stream中删除 delete that.stream[userId]; //把远端视频播放界面设置为-1层 $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); }); 退出视频会议室 client.unpublish()，这也是一个异步函数，要在退出后清除一些信息也要在then方法里。下面是使用示例,里面的client.leave是离开里面的会议室\n//获取当前本地使用的流，有可能是本地流或者共享流 let stream = that.getStream(); that.client.unpublish(stream).then(() =\u0026gt; { // 取消发布本地流成功 that.client .leave() .then(() =\u0026gt; { console.log(\u0026#39;成功退出会议室\u0026#39;); //关闭本地流或者共享流 stream.stop(); stream.close(); //清空模型层的本地流 that.localStream = null; that.shareStream = null; //清空模型层的远端流 that.stream = {}; //销毁TrtcClient对象 that.client = null; that.userList = []; //清空用户列表 that.videoStatus = true; that.micStatus = true; that.shareStatus = false; //视频墙上本地流DIV区域置底 $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#localStream\u0026#39;).html(\u0026#39;\u0026#39;); //TODO 如果是播放大屏视频的时候退出会议，退出会议后需要隐藏大屏 }) .catch(error =\u0026gt; { console.error(\u0026#39;成功退出会议室失败\u0026#39; + error); }); }); 打开/关闭摄像头： localStream.unmuteVideo()/localStream.muteVideo()，localStream是本地流,在创建会议的时候生成\n打开/关闭麦克风 stream.unmuteAudio()/stream.muteAudio()，stream是本地流或共享流\n检测是否满足屏幕共享环境 TRTC.isScreenShareSupported()，与checkSystemRequirements类似\n创建屏幕共享 同样的也是调用TRTC.createStream创建共享流，需要传入screen:true参数，下面是使用示例\nlet shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId }); 设置屏幕的分辨率 shareStream.setScreenProfile(\u0026lsquo;1080p\u0026rsquo;);\n下面是屏幕共享的使用示例\nshareHandle: function() { let that = this; //判断用户是否进入视频会议室 if (!that.meetingStatus) { that.$alert(\u0026#39;请先进入视频会议才能共享屏幕\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } //检查浏览器是否支持屏幕共享 if (!TRTC.isScreenShareSupported()) { //提示当前浏览器不支持在线视频会议 this.$alert(\u0026#39;当前浏览器不支持屏幕共享\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } that.shareStatus = !that.shareStatus; //开启屏幕共享 if (that.shareStatus) { //创建共享流 let shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId }); shareStream.setScreenProfile(\u0026#39;1080p\u0026#39;); that.shareStream = shareStream; shareStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始共享流失败 \u0026#39; + error); }) .then(() =\u0026gt; { //取消推送本地视频流 that.client.unpublish(that.localStream).then(() =\u0026gt; { that.localStream.close(); //关闭本地流 that.localStream = null; //本地流设置为空 //隐藏本地视频窗口 $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: -1 }); that.client.publish(shareStream); //向远端推送共享流 }); }); } //关闭屏幕共享 else { //重建本地视频流 let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: that.micStatus, video: that.videoStatus }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //取消共享流的推流 that.client.unpublish(that.shareStream).then(() =\u0026gt; { that.shareStream.close(); //关闭共享流 that.shareStream = null; //共享流设置为空 //显示本地视频窗口 $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); localStream.play(\u0026#39;localStream\u0026#39;); //播放本地流 //向远端推送本地视频流 that.client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }); } }, ","permalink":"https://rexhub.space/posts/api/%E8%85%BE%E8%AE%AFtrtc/","summary":"腾讯视频会议的使用-TRTC技术 概述： TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n后端的准备 首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n//UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥 usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire))) 关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\npackage com.example.emos.api.config.tencet; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import org.bson.internal.Base64; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.zip.Deflater; /** * Description: 腾讯TRTC工具类 * * @author Rex * @date 2021-09-29 10:48 */ import java.","title":"腾讯TRTC"},{"content":"前端常用轮子 简介 这篇文章主要是记录下一些常见的组件库，以后开发的时候方便点。（持续更新中……）\nReact UI组件库 Ant Design 文档齐全、社区生态好 支持PC端和手机端 详情见官网\nReact Bootstrap 可用于快速搭建个人项目 详情见官网\nMATERIAL-UI(Mui) 实现了谷歌的Material Design github有超过50k的关注量，是目前最受欢迎的React组件库之一 详情见官网\nVue UI组件库 Element 饿了么旗下的组件库，国内最流行的Vue组件库 文档齐全 支持Vue3 同时有React版本和Angular版本 详情见官网\nVant 有赞公司旗下的开源组件库 适用于移动端开发 组件齐全，使用简单，UI美观 详情见官网\nView UI UI精美 含免费版和收费版 详情见官网\nVue工具类 vue-draggable：vue拖拽组件 详情见官网\nvue-qr：生成二维码组件 详情见官网\nvue-cropper：vue图片裁切工具 详情见官网\nvue-lazyload：图片懒加载 不会和vue其他组件库冲突 详情见官网\nvue-simple-upload：vue上传组件 详情见官网\n动画库 Animate.css：动画库 纯css的动画库，适用于各种框架 功能齐全 详情见官网\nswiper：轮播图组件 提供的轮播图效果多 文档齐全，社区强大 支持原生、React、Vue、Angular等任何前端开发场景 有PC端、移动端之分 缺点：官网广告较多…… 详情见官网\nmescroll.js：滚动插件 解决移动端滚动不流畅、延迟等问题 基于H5，侵入性很小，实用性很强，不依赖于其他前端框架 详情见官网\n工具类轮子 lodash.js：前端函数库 支持原生、React、Vue、Angular等任何前端开发场景 封装了常用的函数开发库 详情见官网\nDay.js：日期库 极简的JavaScript库 便于验证、操作、显示日期时间 详情见官网\ntimeago.js 显示几小时之前，网站和应用的更新 时效性强 如：显示15分钟之前创建了xxx文档 详情见官网\necharts：数据可视化插件 可以满足企业级的开发需求 详情见官网\nMeditor.md：Markdown编辑器插件 详情见官网\nvalidator.js：表单验证工具 详情见官网\n","permalink":"https://rexhub.space/posts/front/tools/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%BD%AE%E5%AD%90/","summary":"前端常用轮子 简介 这篇文章主要是记录下一些常见的组件库，以后开发的时候方便点。（持续更新中……）\nReact UI组件库 Ant Design 文档齐全、社区生态好 支持PC端和手机端 详情见官网\nReact Bootstrap 可用于快速搭建个人项目 详情见官网\nMATERIAL-UI(Mui) 实现了谷歌的Material Design github有超过50k的关注量，是目前最受欢迎的React组件库之一 详情见官网\nVue UI组件库 Element 饿了么旗下的组件库，国内最流行的Vue组件库 文档齐全 支持Vue3 同时有React版本和Angular版本 详情见官网\nVant 有赞公司旗下的开源组件库 适用于移动端开发 组件齐全，使用简单，UI美观 详情见官网\nView UI UI精美 含免费版和收费版 详情见官网\nVue工具类 vue-draggable：vue拖拽组件 详情见官网\nvue-qr：生成二维码组件 详情见官网\nvue-cropper：vue图片裁切工具 详情见官网\nvue-lazyload：图片懒加载 不会和vue其他组件库冲突 详情见官网\nvue-simple-upload：vue上传组件 详情见官网\n动画库 Animate.css：动画库 纯css的动画库，适用于各种框架 功能齐全 详情见官网\nswiper：轮播图组件 提供的轮播图效果多 文档齐全，社区强大 支持原生、React、Vue、Angular等任何前端开发场景 有PC端、移动端之分 缺点：官网广告较多…… 详情见官网\nmescroll.js：滚动插件 解决移动端滚动不流畅、延迟等问题 基于H5，侵入性很小，实用性很强，不依赖于其他前端框架 详情见官网\n工具类轮子 lodash.js：前端函数库 支持原生、React、Vue、Angular等任何前端开发场景 封装了常用的函数开发库 详情见官网","title":"前端常用轮子"},{"content":"Zookeeper 定义： Zookeeper：A Distributed Coordination Service for Distributed Applications(\nZookeeper是开源的高性能的分布式应用协调系统，一个高性能的分布式数据一致性解决方案\n5大特点 顺序一致性：发出去的顺序==执行的顺序 原子性：请求同步到各个节点要么都成果要么都失败 单一视图：多个节点无论连哪个看的东西都是一致的 可靠性：给节点写了数据，这个数据会一直保留，直到有另外的操作把数据写掉，才会发生变化 及时性：在一定的时间段（可接受的时间段）内能从服务器上读到最新的数据状态 架构图、集群、工作过程 Zookeeper和CAP的关系 CP：一致性+分区容错性 能得到一致的数据结果，同时系统对网络具备容错性 但是它不能保证每次服务请求的可用性 作用 分布式服务注册与订阅 统一配置文件 生成分布式唯一ID Master节点选举 分布式锁 节点znode 模型-树结构 节点性质 树形结构，也可以理解为linux的文件目录 每一个节点都是znode，里面可以包含数据，也可以有子节点 点分为永久节点和临时节点(session失效，也就是客户端段凯后，临时节点消失) 每个znode都有版本号，每当数据变化，版本号会累加（乐观锁） 删除或修改节点，版本号不匹配的话（版本号已过时），会报错 每个节点存储的数据不宜过大，几k即可 节点可以设置权限，来限制用户的访问 Zookeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入 节点类型 持久节点 临时节点 顺序节点 节点属性 dataVersion 数据版本号，每次对内容修改dataVersion+1 cversion 子节点版本号，如果子节点内容发送变化cversion+1 aclVersion acl-权限控制列表，权限发生变化的时候aclVersion+1 常用命令 查看节点ls 查看节点的数据和状态get 创建(create [-s 顺序节点] [-e 临时节点])、修改(set)、删除(delete)节点 Watcher机制 触发器、监督者\n事件类型\nEventType 触发条件 NodeCreated（节点创建） Watcher监听的对应数据节点被创建 NodeDeleted（节点删除） Watcher监听的对应数据节点被删除 NodeDataChanged（节点数据修改） Watcher监听的对应数据节点的数据内容发送变更 NodeChildrenChanged（子节点变更） Watcher监听的对应数据节点的子节点列表发送变更 ACL access control list 权限控制 它使用权限位来允许/禁止对节点极其所用域的各种操作 ACL仅与特点的znode有关，与子节点无关 Schema ACL:[schema采用的权限机制: id用户:permissions权限组合字符串] world id: anyone auth 需要设定对应的用户和密码（明文） digest 同auth，不同的是加密使用密文 ip 指定ip super 超级权限 权限字符串crdwa Created 创建子节点的权限 Read 读 Delete 删除子节点的权限 Write 写 Admin 最高权限 使用权限 区分开发/测试/运维环境，防止误操作 可以针对不同IP而产生具体的配置，更安全 代码 java原生 导入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写log4j.properties\nlog4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{HH:mm:ss} %p %c{2}: %m%n ZKConnect.java\npackage com.imooc.zkjavaapi; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import org.apache.zookeeper.ZooKeeper; import java.io.IOException; /** * Description: 连接到ZK服务端，打印连接状态 * Date 2021-07-22 16:00 * * @author Rex */ public class ZKConnect implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; public static void main(String[] args) throws IOException, InterruptedException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKConnect()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); System.out.println(zk.getState()); } @Override public void process(WatchedEvent event) { System.out.println(\u0026#34;收到了通知：\u0026#34; + event); } } 演示对节点的操作\nZKOperator.java\npackage com.imooc.zkjavaapi; import com.imooc.zkjavaapi.callback.DeleteCallBack; import org.apache.zookeeper.*; import java.io.IOException; import java.nio.charset.StandardCharsets; /** * Description: 演示对节点的操作 * Date 2021-07-22 16:24 * * @author Rex */ public class ZKOperator implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; public static void main(String[] args) throws IOException, InterruptedException, KeeperException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKConnect()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); /* * path: 创建的路径 * data: 存储的数据 * acl: 权限控制，开放 * createMode: 永久、临时、顺序 */ zk.create(\u0026#34;/imago-create-node\u0026#34;, \u0026#34;imooc\u0026#34;.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // zk.setData(\u0026#34;/imooc-create-node\u0026#34;, \u0026#34;imooc3\u0026#34;.getBytes(StandardCharsets.UTF_8), 1); String ctx = \u0026#34;删除成功\u0026#34;; zk.delete(\u0026#34;/imooc-create-node\u0026#34;, 0, new DeleteCallBack(), ctx); Thread.sleep(2000); // System.out.println(new String(zk.getData(\u0026#34;/imooc-create-node\u0026#34;, null, null))); } @Override public void process(WatchedEvent event) { } } DeleteCallBack.java\npackage com.imooc.zkjavaapi.callback; import org.apache.zookeeper.AsyncCallback; /** * Description: 删除后会运行的内容 * Date 2021-07-22 16:42 * * @author Rex */ public class DeleteCallBack implements AsyncCallback.VoidCallback { @Override public void processResult(int rc, String path, Object ctx) { System.out.println(\u0026#34;删除节点\u0026#34; + rc); System.out.println((String) ctx); } } Watcher\npackage com.imooc.zkjavaapi; import org.apache.zookeeper.KeeperException; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import org.apache.zookeeper.ZooKeeper; import java.io.IOException; import java.util.concurrent.CountDownLatch; /** * Description: 和节点相关：是否存在，获取数据，加上watche * Date 2021-07-22 16:53 * * @author Rex */ public class ZKGetNode implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) throws IOException, InterruptedException, KeeperException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKGetNode()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); System.out.println(zk.getState()); // Stat exists = zk.exists(\u0026#34;/imooc\u0026#34;, false); // if (exists != null) { // System.out.println(\u0026#34;节点的版本为：\u0026#34; + exists.getVersion()); // }else{ // System.out.println(\u0026#34;该节点不存在\u0026#34;); // } zk.getData(\u0026#34;/imooc\u0026#34;, true, null); countDownLatch.await(); } @Override public void process(WatchedEvent event) { if (event.getType() == Event.EventType.NodeDataChanged){ System.out.println(\u0026#34;数据被改变\u0026#34;); countDownLatch.countDown(); } System.out.println(\u0026#34;收到了通知：\u0026#34;+event); } } 缺点 不支持连接超时后的自动重连 Watcher注册一次后会失效 不支持递归创建节点 Apache Curator 解决了Watcher注册一次后会失效的问题\nAPI更加简单易用，提供了工具类\n使用\n引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-framework\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-recipes\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; package com.imooc.curator; import org.apache.curator.RetryPolicy; import org.apache.curator.framework.CuratorFramework; import org.apache.curator.framework.CuratorFrameworkFactory; import org.apache.curator.framework.api.CuratorEvent; import org.apache.curator.retry.ExponentialBackoffRetry; import org.apache.zookeeper.CreateMode; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import java.nio.charset.StandardCharsets; /** * Description: 用Curator来操作ZK * Date 2021-07-22 17:13 * * @author Rex */ public class CuratorTests { public static void main(String[] args) throws Exception { String connectString = \u0026#34;127.0.0.1:2181\u0026#34;; String path = \u0026#34;/curator2\u0026#34;; String data = \u0026#34;test\u0026#34;; RetryPolicy retry = new ExponentialBackoffRetry(1000, 3); CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry); client.start(); client.getCuratorListenable().addListener((CuratorFramework c , CuratorEvent event) -\u0026gt; { switch (event.getType()){ case WATCHED: WatchedEvent watchedEvent = event.getWatchedEvent(); if (watchedEvent.getType() == Watcher.Event.EventType.NodeDataChanged) { System.out.println(new String(c.getData().forPath(path))); break; } default: break; } }); client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes(StandardCharsets.UTF_8)); byte[] bytes = client.getData().watched().forPath(path); System.out.println(new String(bytes)); client.setData().forPath(path, \u0026#34;test2\u0026#34;.getBytes(StandardCharsets.UTF_8)); client.delete().forPath(path); } } ","permalink":"https://rexhub.space/posts/back/java/microservices/zookeeper/","summary":"Zookeeper 定义： Zookeeper：A Distributed Coordination Service for Distributed Applications(\nZookeeper是开源的高性能的分布式应用协调系统，一个高性能的分布式数据一致性解决方案\n5大特点 顺序一致性：发出去的顺序==执行的顺序 原子性：请求同步到各个节点要么都成果要么都失败 单一视图：多个节点无论连哪个看的东西都是一致的 可靠性：给节点写了数据，这个数据会一直保留，直到有另外的操作把数据写掉，才会发生变化 及时性：在一定的时间段（可接受的时间段）内能从服务器上读到最新的数据状态 架构图、集群、工作过程 Zookeeper和CAP的关系 CP：一致性+分区容错性 能得到一致的数据结果，同时系统对网络具备容错性 但是它不能保证每次服务请求的可用性 作用 分布式服务注册与订阅 统一配置文件 生成分布式唯一ID Master节点选举 分布式锁 节点znode 模型-树结构 节点性质 树形结构，也可以理解为linux的文件目录 每一个节点都是znode，里面可以包含数据，也可以有子节点 点分为永久节点和临时节点(session失效，也就是客户端段凯后，临时节点消失) 每个znode都有版本号，每当数据变化，版本号会累加（乐观锁） 删除或修改节点，版本号不匹配的话（版本号已过时），会报错 每个节点存储的数据不宜过大，几k即可 节点可以设置权限，来限制用户的访问 Zookeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入 节点类型 持久节点 临时节点 顺序节点 节点属性 dataVersion 数据版本号，每次对内容修改dataVersion+1 cversion 子节点版本号，如果子节点内容发送变化cversion+1 aclVersion acl-权限控制列表，权限发生变化的时候aclVersion+1 常用命令 查看节点ls 查看节点的数据和状态get 创建(create [-s 顺序节点] [-e 临时节点])、修改(set)、删除(delete)节点 Watcher机制 触发器、监督者\n事件类型\nEventType 触发条件 NodeCreated（节点创建） Watcher监听的对应数据节点被创建 NodeDeleted（节点删除） Watcher监听的对应数据节点被删除 NodeDataChanged（节点数据修改） Watcher监听的对应数据节点的数据内容发送变更 NodeChildrenChanged（子节点变更） Watcher监听的对应数据节点的子节点列表发送变更 ACL access control list 权限控制 它使用权限位来允许/禁止对节点极其所用域的各种操作 ACL仅与特点的znode有关，与子节点无关 Schema ACL:[schema采用的权限机制: id用户:permissions权限组合字符串] world id: anyone auth 需要设定对应的用户和密码（明文） digest 同auth，不同的是加密使用密文 ip 指定ip super 超级权限 权限字符串crdwa Created 创建子节点的权限 Read 读 Delete 删除子节点的权限 Write 写 Admin 最高权限 使用权限 区分开发/测试/运维环境，防止误操作 可以针对不同IP而产生具体的配置，更安全 代码 java原生 导入依赖","title":"Zookeeper"},{"content":"Dubbo 关于Dubbo 轻量级，高性能的RPC框架 并不是要成为一个微服务的全面解决发难 以Java语言而出名 Dubbo现状 全称是Apache Dubbo 微店，网易云音乐，考拉，滴滴，中国电信，人寿 star有30k+个，fork有20k+个 RPC RPC\u0026mdash;\u0026ndash;远程过程调用\n早期单机时代：IPC（Inter-Process Communication）\n单个电脑运行的各个进程之间相互通信\n网络时代：把IPC扩展到网络上，这就是RPC\n实现RPC很头疼，于是就有了RPC框架\n调用其他机器上的程序和调用本地的程序一样方便\n常见的RPC框架 阿里的Dubbo（性能好） 新浪的Montan（轻量级，项目架构复杂度低，适合RPC源码学习） Facebook的Thrift （可伸缩的跨语言框架，有很强的代码生成语言） HTTP和RPC对比 普通话（HTTP，规范\u0026ndash;效率低）和方言（RPC，传输效率和运行速度更高），普通话本质上也是一种方言，只不过它是官方的方言 传输效率：RPC可以自己定制，通过定制自己的请求，让整体传输的内容更少，这样的效率更高，而HTTP会传输一些无用的内容 性能消耗，主要在于序列化和反序列化的耗时：RPC可以实现高效的二进制传输，HTTP大部分要通过JSON格式来传输 负载均衡：RPC自带负载均衡策略，HTTP需要借助其他的组件，如Nginx Dubbo工作原理 模块 说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 服务容器负责启动，加载，运行服务提供者 服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅自己所需的服务 注册中心返回服务提供者地址列表给消费者 从提供者地址列表中，选一台提供者进行调用 定期发送一次统计数据到监控中心 ","permalink":"https://rexhub.space/posts/back/java/microservices/dubbo%E5%9F%BA%E7%A1%80/","summary":"Dubbo 关于Dubbo 轻量级，高性能的RPC框架 并不是要成为一个微服务的全面解决发难 以Java语言而出名 Dubbo现状 全称是Apache Dubbo 微店，网易云音乐，考拉，滴滴，中国电信，人寿 star有30k+个，fork有20k+个 RPC RPC\u0026mdash;\u0026ndash;远程过程调用\n早期单机时代：IPC（Inter-Process Communication）\n单个电脑运行的各个进程之间相互通信\n网络时代：把IPC扩展到网络上，这就是RPC\n实现RPC很头疼，于是就有了RPC框架\n调用其他机器上的程序和调用本地的程序一样方便\n常见的RPC框架 阿里的Dubbo（性能好） 新浪的Montan（轻量级，项目架构复杂度低，适合RPC源码学习） Facebook的Thrift （可伸缩的跨语言框架，有很强的代码生成语言） HTTP和RPC对比 普通话（HTTP，规范\u0026ndash;效率低）和方言（RPC，传输效率和运行速度更高），普通话本质上也是一种方言，只不过它是官方的方言 传输效率：RPC可以自己定制，通过定制自己的请求，让整体传输的内容更少，这样的效率更高，而HTTP会传输一些无用的内容 性能消耗，主要在于序列化和反序列化的耗时：RPC可以实现高效的二进制传输，HTTP大部分要通过JSON格式来传输 负载均衡：RPC自带负载均衡策略，HTTP需要借助其他的组件，如Nginx Dubbo工作原理 模块 说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 服务容器负责启动，加载，运行服务提供者 服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅自己所需的服务 注册中心返回服务提供者地址列表给消费者 从提供者地址列表中，选一台提供者进行调用 定期发送一次统计数据到监控中心 ","title":"Dubbo基础"},{"content":"MongoDB 简介： MongoDB是为快速开发互联网Web应用而设计的数据库系统。 MongoDB的设许目标是极简、灵活、作为Web应用栈的一部分。 MongoDB的数据模型是面向文档的,所谓文档是- - -种类似于JSON的结构,简单理解MongoDB这个数据库中存的是各种各样的JSON。 ( BSON ) 三个概念 数据库( database )\n数据库是-个仓库,在仓库中可以存放集合。\n集合( collection )\n集合类似于数组,在集合中可以存放文档。\n文档( dotument )\n文档数据库中的最小单位,我们存储和操作的 内容都是文档。\n基本指令 show dbs\n显示当前的所有数据库\nuse 数据库名\n进入指定的数据库中\ndb\n显示当前所处的数据库\nshow collections\n显示数据库中所有的集合\ndb.\u0026lt;collection\u0026gt;.insert(doc)\n向集合中插入一个文档\ndb.\u0026lt;collections\u0026gt;.find()\n查看数据库字段\n插入文档 /* 向数据库插入文档\tdb.\u0026lt;collection\u0026gt;.insert( \u0026lt;document or array of documents\u0026gt;， { wirteConcern: \u0026lt;document\u0026gt;, ordered: \u0026lt;boolean\u0026gt; } ) documents: 必填，表示需要插入的文档，可以是多个文档 writeConcern：可选项，写策略 ordered：可选，表示多个文档是否按照文档顺序写入 -- 向集合中插入一个或多个文档 -- 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id， 该属性用来作为文档的唯一标识 -- _id可以自己指定，如果指定了数据库就不会再添加了，如果自己指定_id，也必须确保他的唯一性 db.collection.insertOne() -- 插入一个文档对象 db.collection.insertMany() -- 插入多个文档对象 */ db.stus.insert({name: \u0026#34;zhubajie\u0026#34;, age: 28, gender:\u0026#34;男\u0026#34;}) db.stus.insert([ {name: \u0026#34;shasen\u0026#34;, age: 38, gender:\u0026#34;男\u0026#34;}, {name: \u0026#34;baigujing\u0026#34;, age: 16, gender:\u0026#34;女\u0026#34;}, {name: \u0026#34;zhizhujing\u0026#34;, age: 14, gender:\u0026#34;女\u0026#34;} ]) 查询文档 查询选择器 运算符类型 运算符 运算符含义 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $eq 等于 $lt 小于 比 $lte 小于等于 $gt 大于 $gte 大于等于 较 $in 判断元素是否在指定的集合范围里 $all 判断元素是否不在指定的集合范围里 $nin 判断元素是否不在指定的范围里 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $ne 不等于 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $not 不匹配结果 逻辑 $or 有一个条件成立则匹配 $nor 所有条件都必须匹配 运算 $and 所有条件都必须匹配 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $exists 判断元素是否存在 其 . 子文档匹配 他 $regex 正则表达式 一般查询 /* 查询 db.collection.find() -- find()用来查询所有符合条件的文档 -- find()可以接受一个对象作为条件参数 {} 表示查询集合中所有的文档 {属性：值} 查询属性是指定的文档 -- find() 返回的是一个数组 db.collection.findOne() -- 用来查询集合中符合条件的第一个文档 -- findOne() 返回的是一个文档对象 db.collection.find({}).count() -- 查询所有结果的数量 */ db.stus.insert({_id:\u0026#34;hello\u0026#34;, name:\u0026#34;zhubajie\u0026#34;, age:28, gender:\u0026#34;男\u0026#34;}) db.stus.find({age:28}) db.stus.findOne({age:28}).name db.stus.find({}).count() 查询其他条件 映射 字段选择：db.inventory.find({}, {\u0026lsquo;item\u0026rsquo;: 1}) 字段排除：db.inventory.find({}, {\u0026lsquo;item\u0026rsquo;: 0}) 数组子元素选择： db.inventory.find({}, {\u0026lsquo;favorites.movies\u0026rsquo;: {\u0026rsquo;$slice\u0026rsquo;: [1, 2]}, \u0026lsquo;favorites.cites\u0026rsquo;: 1}), $slice可以取俩个元素数组，分别表示跳过和限制的条数 排序 sort(): db.orders.find().sort({\u0026lsquo;orderTime\u0026rsquo;: 1, \u0026lsquo;price\u0026rsquo;: 1}) 1: 升序 2: 降序 跳过和限制 skip(n):跳过n条数据\nlimit(n):限制n条数据\ne.g：orders.find().sort({\u0026lsquo;orderTime\u0026rsquo;: -1}).limit(5).skip(5)\n查询唯一值 distinct()：查询指定字段的唯一值\ne.g：db.users.distinct(\u0026ldquo;age\u0026rdquo;)\n聚合查询 我们在查询时肯定回用到聚合，在MongoDB中聚合为aggregate，聚合函数主要用到$match，$group，$avg，$project，$concat，可以加\u0026quot;$match\u0026quot;也可以不加$match\n表达式 描述 $sum 计算总和 $avg 计算平均值 $min 获取集合中所有文档对应值的最小值 $max 获取集合中所有文档对应值的最大值 $push 在结果文档中插入值到一个数组中。 $addToSet 在文档中插入值到一个数组中，但不创建副本。 $first 根据资源文档的排序获取第一个文档数据。 $last 根据资源文档的排序获取最后一个文档数据。 Aggregate语法 基本格式： db.collection.aggregate(pipeline, options)\n参数说明：\n参数 类型 描述 pipeline array 一系列数据聚合操作或阶段。在版本2.6中更改：该方法仍然可以将流水线阶段作为单独的参数接受，而不是作为数组中的元素；但是如果不将管道指定为数组，则不能指定options参数。 options document 可选。aggregate()传递给聚合命令的其他选项。2.6版中的新增功能：仅当将管道指定为数组时才可用 $match和$group 相当于sql中的where和group by\n{\u0026quot;$match\u0026quot;: {\u0026ldquo;字段\u0026rdquo;: \u0026ldquo;条件\u0026rdquo;}}，可以使用任何常用查询操作符$gt，$lt，$in等\n{\u0026quot;$group\u0026quot;：{\u0026quot;_id\u0026quot;: 分组字段, \u0026ldquo;新的字段名\u0026rdquo;: \u0026ldquo;聚合操作符\u0026rdquo;}}\n将分组字段传给$group函数的_id字段即可 分组后聚合得到结果，类似于sql中聚合函数的聚合操作符：$sum、$avg、$max、$min、$first、$last # {\u0026#34;$match\u0026#34;: {\u0026#34;字段\u0026#34;: \u0026#34;条件\u0026#34;}}，可以使用任何常用查询操作符$gt, $lt, $in等 # select _id job, avg(sal) avg_salary from db.emp where depno=30 group by job; db.emp.aggregate([ {\u0026#34;$match\u0026#34;: {\u0026#34;depno\u0026#34;: {\u0026#34;$eq\u0026#34;: 30}}}, {\u0026#34;$group\u0026#34;: {\u0026#34;_id\u0026#34;: \u0026#34;$job\u0026#34;, \u0026#34;avg_salary\u0026#34;: {\u0026#34;$avg\u0026#34;: \u0026#34;$sal\u0026#34;}}} ]) # select _id job, avg(sal) avg_salary from db.emp where depno=30 group by job having avg_salary \u0026gt; 2000; db.emp.aggregate([ {\u0026#34;$match\u0026#34;: {\u0026#34;depno\u0026#34;: {\u0026#34;$eq\u0026#34;: 30}}}, {\u0026#34;$group\u0026#34;: {\u0026#34;_id\u0026#34;: \u0026#34;$job\u0026#34;, \u0026#34;avg_salary\u0026#34;: {\u0026#34;$avg\u0026#34;: \u0026#34;$sal\u0026#34;}}}, {\u0026#34;$match\u0026#34;: {\u0026#34;avg_salary\u0026#34;: {\u0026#34;$gt\u0026#34;: 2000}}} ]) $project 用于投射，即设定该键值对是否保留。1为保留，0为不保留，可对原有键值对做操作后增加自定义表达式(查询哪些要显示的列)\n{\u0026#34;$project\u0026#34;: {\u0026#34;要保留的字段名\u0026#34;: 1, \u0026#34;要去掉的字段名\u0026#34;: 1, \u0026#34;新增的字段名\u0026#34;: \u0026#34;表达式\u0026#34;}} db.emp.aggregate() # select ename, job, (sal+400) as new_sal from db.emp; db.emp.aggregate([{ $project: { \u0026#34;ename\u0026#34;: 1, \u0026#34;job\u0026#34;: 1, \u0026#34;new_sal\u0026#34;: { \u0026#34;$add\u0026#34;: [\u0026#34;$sal\u0026#34;, 400] } } }]) $sort和$limit和$skip 排序：{\u0026quot;$sort\u0026quot;: {\u0026ldquo;字段名\u0026rdquo;: 1, “字段名”: -1}} #1升序，-1降序\n限制：{\u0026quot;$limit\u0026quot;: n}\n跳过：{\u0026quot;$skip\u0026quot;: n} #跳过多少个文档\n# 例1、取平均工资最高的前两个工作 db.emp.aggregate([ { \u0026#34;$group\u0026#34;: {\u0026#34;_id\u0026#34;: \u0026#34;$job\u0026#34;, \u0026#34;avg_sal\u0026#34;: {\u0026#34;$avg\u0026#34;: \u0026#34;$sal\u0026#34;}} }, { \u0026#34;$sort\u0026#34;: {\u0026#34;avg_sal\u0026#34;: -1} }, { \u0026#34;$limit\u0026#34;: 2 } ]) # 例2、取平均工资最高的第二个部门 db.emp.aggregate([ { \u0026#34;$group\u0026#34;: {\u0026#34;_id\u0026#34;: \u0026#34;$job\u0026#34;, \u0026#34;avg_sal\u0026#34;: {\u0026#34;$avg\u0026#34;: \u0026#34;$sal\u0026#34;}} }, { \u0026#34;$sort\u0026#34;: {\u0026#34;avg_sal\u0026#34;: -1} }, { \u0026#34;$skip\u0026#34;:1 }, { \u0026#34;$limit\u0026#34;: 1 } ]) $sample 随机选取n个：$sample\ndb.emp.aggregate([ {\u0026#34;$sample\u0026#34;: {size: 3}} ]) 修改文档 /* 修改 db.collection.update(查询条件，新对象) - update()默认情况下会使用新对象来替换旧对象(旧版本) - update()旧版本新对象不写全或是不用$set，默认情况下会报错 (Invalid key \u0026#39;age\u0026#39;: update only works with $ operators and pipelines) - 如果需要修改指定的属性，而不是替换需要使用\u0026#34;修改操作符\u0026#34;来完成修改 $set 可以用来修改文档中的指定属性 $unset 可以用来删除文档中的指定属性 - update()默认只修改一个 db.collection.updateMany() - 同时修改多个符合条件的文档 db.collection.updateOne() - 修改一个符合条件的文档 */ db.stus.find() // 替换 db.stus.update({name:\u0026#34;shasen\u0026#34;}, {age: 28}) db.stus.update({name:\u0026#34;shasen\u0026#34;}, {$set: {age: 28}}) db.stus.update({_id: ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{$set: {name:\u0026#34;shaheshang\u0026#34;}}) db.stus.find({_id: ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)}) db.stus.update({_id: ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{ $set: { gender: \u0026#34;男\u0026#34;, address: \u0026#34;流沙河\u0026#34; } }) db.stus.update({_id: ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{ $unset: { address:1 } }) db.stus.updateMany( {name: \u0026#34;zhubajie\u0026#34;}, { $set: { address:\u0026#34;zhulaozhuang\u0026#34; } } ) db.stus.update( {name: \u0026#34;zhubajie\u0026#34;}, { $set: { address:\u0026#34;zhulaozhuang\u0026#34; } } ) db.stus.update( {name: \u0026#34;zhubajie\u0026#34;}, { $set: { address:\u0026#34;hehehe\u0026#34; } }, { multi: true } ) db.stus.find() 删除文档 /* 删除 db.collection.remove() -- 删除符合条件的所有文档(默认情况下会删除多个) 如果remove()第二个参数传递一个true，则只会删除一个 -- 如果值传递一个空对象作为参数，则会删除结合中的所有文档\tdb.collection.deleteOne() db.collection.deleteMany() -- remove()可以根据条件来删除文档，传递的条件方式和find()一样 db.collection.drop(); -- 删除集合 db.dropDatabase() 删除数据库 -- 数据库中的数据都并不会删除，所以删除的方法很少调用 一般会在数据中添加一个字段，来表示数据是否被删除 */ db.stus.remove({_id: \u0026#34;hello\u0026#34;}) db.stus.find() db.stus.insert([{age: 28}, {age: 28}]) db.stus.remove({age: 28}, true) // 清空集合(性能略差) db.stus.remove({}) show collections; db.stus.drop() show dbs; db.dropDatabase(); 文档关系 /* 文档之间的关系 一对一(one to one) -- 夫妻(一个丈夫 对应 一个妻子) -- 在MongoDB，可以通过内嵌文档的形式来体现出一对一的关系 一对多(one to many) / 多对一(many to one) -- 父母 - 孩子 用户 - 订单 文章 - 评论 - 也可以通过内嵌文档来映射一对多的关系 多对多(many to many) -- 分类 - 商品 老师 - 学生 */ db.wifeAndHusband.insert([ { name: \u0026#34;黄蓉\u0026#34;, husband: { name: \u0026#34;郭靖\u0026#34; } },{ name: \u0026#34;潘金莲\u0026#34;, husband: { name: \u0026#34;武大郎\u0026#34; } } ]); db.wifeAndHusband.find() // 一对多 用户(users) 和 订单() db.users.insert([ { username: \u0026#34;swk\u0026#34; },{ username: \u0026#34;zbj\u0026#34; } ]) db.users.find() db.order.insert({ list: [\u0026#34;牛肉\u0026#34;, \u0026#34;漫画\u0026#34;], user_id: ObjectId(\u0026#34;60dbc477c673000085000595\u0026#34;) }) db.order.find() // 查找用户swk的订单 var user_id = db.users.findOne({username: \u0026#34;zbj\u0026#34;})._id db.order.find({user_id: user_id}) // 多对多 db.teachers.insert([ {name: \u0026#34;洪七公\u0026#34;}, {name: \u0026#34;黄药师\u0026#34;}, {name: \u0026#34;龟仙人\u0026#34;} ]) db.stus.insert([{ name: \u0026#34;郭靖\u0026#34;, tech_ids: [ ObjectId(\u0026#34;60dbc694c67300008500059a\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059b\u0026#34;) ] },{ name: \u0026#34;孙悟空\u0026#34;, tech_ids: [ ObjectId(\u0026#34;60dbc694c67300008500059a\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059b\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059c\u0026#34;) ] } ]) db.teachers.find() db.stus.find() Test //17.向numbers中插入20000条数据 var arr = []; for(var i = 1; i \u0026lt;= 20000; i++){ arr.push({num: i}); } db.numbers.insert(arr) //18.查询numbers中num为500的文档 db.numbers.find({num: 500}) //19.查询numbers中num大于5000的文档 db.numbers.find({num: {$gt: 5000}}) //20.查询numbers中num小于30的文档 db.numbers.find({num: {$lt: 30}}) //21.查询numbers中num大于40小于50的文档 db.numbers.find({num: {$gt: 40, $lt: 50}}) //22.查询numbers中num大于19996的文档 db.numbers.find({num: {$gt: 19996}}) //23.查看numbers集合中的前10条数据 //limit()设置显示数据的上限 db.numbers.find({}).limit(10) //在开发时，我们绝对不会执行不带条件的查询 db.numbers.find({}) //24.查看numbers集合中的第11条到20条数据 //skip()用于跳过指定数量的数据 db.numbers.find({}).limit(10).skip(10) //25.查看numbers集合中的第21条到30条数据 db.numbers.find({}).limit(10).skip(20) //26.将dept和emp集合导入到数据库中 //27.查询工资小于2000的员工 db.emp.find({sal: {$lt: 2000}}) //28.查询工资在1000-2000之间的员工 db.emp.find({sal: {$gt: 1000, $lt: 2000}}) //29.查询工资小于1000或大于2500的员工 db.emp.find({ $or: [ {sal: {$lt: 1000}}, {sal: {$gt: 2500}} ] }); //30.查询财务部的所有员工 var deptno = db.dep.findOne({dname: \u0026#34;财务部\u0026#34;}).deptno db.emp.find({depno: deptno}) //31.查询销售部的所有员工 var deptno = db.dep.findOne({dname: \u0026#34;销售部\u0026#34;}).deptno db.emp.find({depno: deptno}) //32.查询所有mgr为7698的所有员工 db.emp.find({mgr: 7698}) //33.为所有薪资低于1000的员工增加工资400元 db.emp.updateMany({sal: {$lte: 1000}}, { $inc: { sal: 400 } } ) db.emp.find() emp:\n{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ac\u0026#34;), \u0026#34;empno\u0026#34; : 7369.0, \u0026#34;ename\u0026#34; : \u0026#34;林冲\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7902.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1980-12-16T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 800.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ad\u0026#34;), \u0026#34;empno\u0026#34; : 7499.0, \u0026#34;ename\u0026#34; : \u0026#34;孙二娘\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-02-19T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1600.0, \u0026#34;comm\u0026#34; : 300.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ae\u0026#34;), \u0026#34;empno\u0026#34; : 7521.0, \u0026#34;ename\u0026#34; : \u0026#34;扈三娘\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-02-21T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1250.0, \u0026#34;comm\u0026#34; : 500.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4af\u0026#34;), \u0026#34;empno\u0026#34; : 7566.0, \u0026#34;ename\u0026#34; : \u0026#34;卢俊义\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-04-01T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2975.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b0\u0026#34;), \u0026#34;empno\u0026#34; : 7654.0, \u0026#34;ename\u0026#34; : \u0026#34;潘金莲\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-09-27T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1250.0, \u0026#34;comm\u0026#34; : 1400.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b1\u0026#34;), \u0026#34;empno\u0026#34; : 7698.0, \u0026#34;ename\u0026#34; : \u0026#34;西门庆\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-04-30T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2850.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b2\u0026#34;), \u0026#34;empno\u0026#34; : 7782.0, \u0026#34;ename\u0026#34; : \u0026#34;柴进\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-06-08T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2450.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b3\u0026#34;), \u0026#34;empno\u0026#34; : 7788.0, \u0026#34;ename\u0026#34; : \u0026#34;公孙胜\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;分析师\u0026#34;, \u0026#34;mgr\u0026#34; : 7566.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1987-07-12T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 3000.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b4\u0026#34;), \u0026#34;empno\u0026#34; : 7839.0, \u0026#34;ename\u0026#34; : \u0026#34;宋江\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;董事长\u0026#34;, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-11-16T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 5000.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b5\u0026#34;), \u0026#34;empno\u0026#34; : 7844.0, \u0026#34;ename\u0026#34; : \u0026#34;阎婆惜\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-09-07T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1500.0, \u0026#34;comm\u0026#34; : 0.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b6\u0026#34;), \u0026#34;empno\u0026#34; : 7876.0, \u0026#34;ename\u0026#34; : \u0026#34;李逵\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7902.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1987-07-12T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1100.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b7\u0026#34;), \u0026#34;empno\u0026#34; : 7900.0, \u0026#34;ename\u0026#34; : \u0026#34;武松\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7782.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-12-02T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 950.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b8\u0026#34;), \u0026#34;empno\u0026#34; : 7902.0, \u0026#34;ename\u0026#34; : \u0026#34;吴用\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;分析师\u0026#34;, \u0026#34;mgr\u0026#34; : 7566.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-12-02T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 3000.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b9\u0026#34;), \u0026#34;empno\u0026#34; : 7934.0, \u0026#34;ename\u0026#34; : \u0026#34;鲁智深\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7782.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1982-01-22T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1300.0, \u0026#34;depno\u0026#34; : 10.0 } dept\n{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49a\u0026#34;), \u0026#34;deptno\u0026#34; : 10.0, \u0026#34;dname\u0026#34; : \u0026#34;财务部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;北京\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49b\u0026#34;), \u0026#34;deptno\u0026#34; : 20.0, \u0026#34;dname\u0026#34; : \u0026#34;办公室\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;上海\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49c\u0026#34;), \u0026#34;deptno\u0026#34; : 30.0, \u0026#34;dname\u0026#34; : \u0026#34;销售部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;广州\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49d\u0026#34;), \u0026#34;deptno\u0026#34; : 40.0, \u0026#34;dname\u0026#34; : \u0026#34;运营部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;深圳\u0026#34; } 排序和投影 // 查询文档时，默认情况下是按照_id的值进行排列(升序) //sort()可以用来指定文档的排序的规则，sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序 //limit skip sort 可以任意的顺序进行调用 db.emp.find({}).sort({sal: -1}) //在查询时，可以在第二个参数的位置来设置查询结果的 投影 db.emp.find({}, {ename: 1, _id: 0, sal: 1}); node整合mongodb- Mongoose http://mongoosejs.com/\n连接数据库 /* 1. 下载安装Mongoose npm i mongoose --save 2. 在项目中引入mongoose var mongoose = require(\u0026#34;mongoose\u0026#34;) 3. 连接MongoDB数据库 mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, {useMongoClient: true}); - 如果端口号是默认端口号(27017) 则可以省略不写 4. 断开数据库连接(一般不需要调用) - MongoDB数据库，一般情况下，只需要连接一次，连接一次以后，除非项目停止，服务器关闭，否则连接一般不会断开 mongoose.disconnect() - 监听MongoDB数据库的连接状态 - 在Mongoose对象中，有一个属性叫做Connection，该对象表示的就是数据库连接 通过监视该对象的状态，可以来监听数据库的连接与断开 数据库连接成功的事件 mongoose.connection.once(\u0026#34;open\u0026#34;, function()); 数据库断开的事件 mongoose.connection.once(\u0026#34;close\u0026#34;, function()); Schema Model Document */ // 引入 var mongoose = require(\u0026#34;mongoose\u0026#34;); // 连接数据库 // mongoose.connect(\u0026#34;mongodb://127.0.0.1/mongoose_test\u0026#34;, { useNewUrlParser: true } ); mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, { useNewUrlParser: true, useUnifiedTopology: true }); mongoose.connection.once(\u0026#34;open\u0026#34;, () =\u0026gt; { console.log(\u0026#34;数据库连接成功~~~~~\u0026#34;); }); mongoose.connection.once(\u0026#34;close\u0026#34;, () =\u0026gt; { console.log(\u0026#34;数据库已经断开~~~~~\u0026#34;); }); //断开数据库连接 mongoose.disconnect() 使用示例 var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) // 向数据库中插入一个文档 // StuModel.create(doc, function)); StuModel.create({ name: \u0026#34;白骨精\u0026#34;, age: 18, address: \u0026#34;白骨洞\u0026#34; }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;插入成功\u0026#34;); } }); Model使用 var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) /* - 有了Model，我们就可以用来对数据库进行增删改查的操作了 Model.create(doc(s), [callback]) - 用来创建一个或多个文档并添加到数据库中 - 参数： doc(s) 可以是一个文档对象，也可以是一个文档对象的数组 callback 当操作完成以后调用的回调函数 查询的: Model.find(conditions, [projection], [options], [callback]) - 查询所有符合条件的文档 Model.findById(id, [projection], [options], [callback]) - 根据文档的id属性查询文档 Model.findOne([conditions], [projection], [options], [callback]) - 查询符合条件的第一个文档，总会返回一个具体的文档 conditions 查询的条件 projection 投影 需要的字段 - 两种方式 {name: 1, _id: 0} \u0026#34;name -_id\u0026#34; options 查询选项(skip, limit) callback 回调函数，查询结果会通过回调函数返回 回调函数必须传，如果不传回调函数，不会查询 */ // StuModel.find({}, \u0026#34;name age\u0026#34;, { // skip: 3, // limit: 1 // }, (err, docs) =\u0026gt; { // if (!err) { // console.log(docs); // } // }) // StuModel.findOne({}, (err, docs) =\u0026gt; { // if (!err) { // console.log(docs); // } // }) // StuModel.findById(\u0026#34;60dbdbb2ecd64b4db4605b27\u0026#34;, (err, docs) =\u0026gt; { // if (!err) { // // console.log(docs); // // 通过find()查询的结果，返回的对象，就是Document，文档对象 // // Document对象是Model的实例 // console.log(docs instanceof StuModel); // } // }) // StuModel.create([{ // name: \u0026#34;沙和尚\u0026#34;, // age: 28, // gender: \u0026#34;male\u0026#34;, // address: \u0026#34;流沙河\u0026#34; // }], (error) =\u0026gt; { // if (!error) { // console.log(arguments); // } // }) /* 修改 Model.update(conditions, doc, [options], [callback]) Model.updateMany(conditions, doc, [options], [callback]) Model.updateOne(conditions, doc, [options], [callback]) Model.replaceOne(conditions, doc, [options], [callback]) - 用来修改一个或多个文档 - 参数： conditions 查询条件 doc 修改后的对象 options 配置参数 callback 回调函数 */ // 修改唐僧的年龄为20 // StuModel.updateOne({ // name: \u0026#34;唐僧\u0026#34; // }, { // $set: { // age: 20 // } // }, (err) =\u0026gt; { // if (!err) { // console.log(\u0026#34;修改成功\u0026#34;); // } // }) /* 删除 Model.remove(conditions, [callback]) Model.deleteOne(conditions, [callback]) Model.deleteMany(conditions, [callback]) */ // StuModel.deleteOne({ // name: \u0026#34;沙和尚\u0026#34; // }, // err =\u0026gt; { // if (!err) { // console.log(\u0026#34;删除成功\u0026#34;); // } // }) /* Model.count(conditions, [callback]) - 统计文档的数量的 */ StuModel.count({}, function (err, count) { if (!err) { console.log(count); } }); Document使用 /* Document 和 集合中的文档一一对应，Document是Model实例 通过Model查询到结果都是Document */ // 创建一个Document var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) var stu = new StuModel({ name: \u0026#34;奔波霸\u0026#34;, age: 48, gender: \u0026#34;male\u0026#34;, address: \u0026#34;碧波潭\u0026#34; }); /* document的方法 Model#save([options], [fn]) */ // stu.save(err =\u0026gt; { // if (!err) { // console.log(\u0026#34;保存成功\u0026#34;); // } // }) StuModel.findOne({}, (err, doc) =\u0026gt; { if (!err) { /* update(update,[options],[callback]) -- 修改对象 remove([callback]) -- 删除对象 */ // console.log(doc); // doc.update({ // $set: { // age: 28 // } // }, err =\u0026gt; { // if (!err) { // console.log(\u0026#34;修改成功\u0026#34;); // } // }) // doc.remove(err =\u0026gt; { // if (!err) { // console.log(\u0026#34;大师兄再见\u0026#34;); // } // }) /* get(name) -获取文档中的指定属性值 set() id - 获取文档的_id属性值 toJSON() - 转换为一个JSON字符串 toObject() - 将Document转换成普通的JSON对象 */ // console.log(doc.get(\u0026#34;age\u0026#34;)); // console.log(doc.age); // doc.set(\u0026#34;name\u0026#34;, \u0026#34;猪🐖\u0026#34;) // doc.name = \u0026#34;哈哈哈\u0026#34; doc = doc.toObject(); delete doc.address; console.log(doc); } }) ","permalink":"https://rexhub.space/posts/nosql/mongodb/","summary":"MongoDB 简介： MongoDB是为快速开发互联网Web应用而设计的数据库系统。 MongoDB的设许目标是极简、灵活、作为Web应用栈的一部分。 MongoDB的数据模型是面向文档的,所谓文档是- - -种类似于JSON的结构,简单理解MongoDB这个数据库中存的是各种各样的JSON。 ( BSON ) 三个概念 数据库( database )\n数据库是-个仓库,在仓库中可以存放集合。\n集合( collection )\n集合类似于数组,在集合中可以存放文档。\n文档( dotument )\n文档数据库中的最小单位,我们存储和操作的 内容都是文档。\n基本指令 show dbs\n显示当前的所有数据库\nuse 数据库名\n进入指定的数据库中\ndb\n显示当前所处的数据库\nshow collections\n显示数据库中所有的集合\ndb.\u0026lt;collection\u0026gt;.insert(doc)\n向集合中插入一个文档\ndb.\u0026lt;collections\u0026gt;.find()\n查看数据库字段\n插入文档 /* 向数据库插入文档\tdb.\u0026lt;collection\u0026gt;.insert( \u0026lt;document or array of documents\u0026gt;， { wirteConcern: \u0026lt;document\u0026gt;, ordered: \u0026lt;boolean\u0026gt; } ) documents: 必填，表示需要插入的文档，可以是多个文档 writeConcern：可选项，写策略 ordered：可选，表示多个文档是否按照文档顺序写入 -- 向集合中插入一个或多个文档 -- 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id， 该属性用来作为文档的唯一标识 -- _id可以自己指定，如果指定了数据库就不会再添加了，如果自己指定_id，也必须确保他的唯一性 db.collection.insertOne() -- 插入一个文档对象 db.","title":"Mongodb基础"},{"content":"Docker 概念 Docker是一个用来装程序及其环境的容器,属于Linux容器的 一种封装,提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。\n痛点 环境配置 虚拟机 资源占用多 冗余步骤多 启动时间慢 Docker的基础 \u0026mdash; Linux容器 启动快 占用资源少 体积小 用途 提供统一的环境 提供快速拓展、弹性伸缩的云服务 防止其他用户的进程把服务器资源占用过多 特点 标准化\n运输方式（把程序和环境从一个机器运到另一个机器） 存储方式（程序和环境的存储） API接口（不需要Tomcat等应用的命令了，都标准化了） 灵活：即使是最复杂的应用也可以集装箱化\n轻量级：容器利用并共享主机内核\n便携式：可以在本地构建\nDocker的组成、架构、重要概念 images（镜像）: 存储：联合文件系统，UnionFS Container（容器）： 镜像类似于Java中的类，而容器就是实例 容器的这一层是可以修改的，而镜像是不可以修改的 同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰 Repository（仓库）： 官方仓库\n阿里云仓库\n网易云仓库\n时速云\nDaoCloud\n共有 vs 私有\nclient和daemon client提供给用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务 daemon：服务端守护进程，接受client发送的命令并执行相应的操作 Docker的网络模式 Bridge 桥接：独立（网卡独立、路由独立、iptable规则独立）的网络，与主机桥接 Host 主机：不是独立的网络，与主机使用同一个网络 None 没有网络 端口映射技术 制作自己的Docker容器，dockerfile实战 dockerfile作用：文本文件，用来配置镜像，docker根据这个来生成对应的镜像文件\ndockerfile的好处：\n便于版本控制 便于维护环境 便于新人初步了解程序 写自己的dockerfile\nFROM alpine:latest # alpine--极小型的Linux环境，表示这个镜像基于这个系统 MAINTAINER imooc # 描述这个镜像由谁来维护 CMD echo \u0026#39;hello my dockerfile\u0026#39; # 根据自己的业务需求来写 常用命令 docker images # 查询当前镜像列表 docker pull image # 拉取镜像到本地 docker run images image # 前台运行 docker run -d image # 后台运行 d表示detech docker ps # 查看当前后台运行的容器 docker exec -it status bash # -i代表容器输入有效 -t分配一个终端 docker stop status # 关闭容器 docker run -p 8080:80 # 本机8080端口映射到容器的80端口 -p自己定义 -P随机分配主机端口 netstat -na|grep 8080 # 查询端口状态 docker build -t hello_docker . #编译当前的Dockerfile文件，-t指定镜像名字 systemctl stop docker # 停止docker服务 ","permalink":"https://rexhub.space/posts/back/java/microservices/docker%E5%9F%BA%E7%A1%80/","summary":"Docker 概念 Docker是一个用来装程序及其环境的容器,属于Linux容器的 一种封装,提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。\n痛点 环境配置 虚拟机 资源占用多 冗余步骤多 启动时间慢 Docker的基础 \u0026mdash; Linux容器 启动快 占用资源少 体积小 用途 提供统一的环境 提供快速拓展、弹性伸缩的云服务 防止其他用户的进程把服务器资源占用过多 特点 标准化\n运输方式（把程序和环境从一个机器运到另一个机器） 存储方式（程序和环境的存储） API接口（不需要Tomcat等应用的命令了，都标准化了） 灵活：即使是最复杂的应用也可以集装箱化\n轻量级：容器利用并共享主机内核\n便携式：可以在本地构建\nDocker的组成、架构、重要概念 images（镜像）: 存储：联合文件系统，UnionFS Container（容器）： 镜像类似于Java中的类，而容器就是实例 容器的这一层是可以修改的，而镜像是不可以修改的 同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰 Repository（仓库）： 官方仓库\n阿里云仓库\n网易云仓库\n时速云\nDaoCloud\n共有 vs 私有\nclient和daemon client提供给用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务 daemon：服务端守护进程，接受client发送的命令并执行相应的操作 Docker的网络模式 Bridge 桥接：独立（网卡独立、路由独立、iptable规则独立）的网络，与主机桥接 Host 主机：不是独立的网络，与主机使用同一个网络 None 没有网络 端口映射技术 制作自己的Docker容器，dockerfile实战 dockerfile作用：文本文件，用来配置镜像，docker根据这个来生成对应的镜像文件\ndockerfile的好处：\n便于版本控制 便于维护环境 便于新人初步了解程序 写自己的dockerfile\nFROM alpine:latest # alpine--极小型的Linux环境，表示这个镜像基于这个系统 MAINTAINER imooc # 描述这个镜像由谁来维护 CMD echo \u0026#39;hello my dockerfile\u0026#39; # 根据自己的业务需求来写 常用命令 docker images # 查询当前镜像列表 docker pull image # 拉取镜像到本地 docker run images image # 前台运行 docker run -d image # 后台运行 d表示detech docker ps # 查看当前后台运行的容器 docker exec -it status bash # -i代表容器输入有效 -t分配一个终端 docker stop status # 关闭容器 docker run -p 8080:80 # 本机8080端口映射到容器的80端口 -p自己定义 -P随机分配主机端口 netstat -na|grep 8080 # 查询端口状态 docker build -t hello_docker .","title":"Docker基础"},{"content":"Nginx Nginx介绍 使用场景 HTTP的反向代理服务器 负载均衡 缓存 动态静态资源分离 优点 高并发、高性能 可扩展性好，体现在模块化设计 高可靠性，可以持续不断数十年运行 热部署，不停止服务来升级nginx 开源、可商用 Nginx常用命令 ./nginx # 启动nginx ps -aux|grep nginx # 查看nginx相关进程，也可以查到nginx运行的路径 nginx -h # 帮助 nginx -c # 读取指定配置文件 nginx -s stop # 关闭nginx nginx -t # 检查当前配置文件是否有问题，查看当前配置文件路径 nginx -v # 简要版本信息 -V详细信息 nginx -s stop|quit| # -s信号 stop立即停止，quit优雅停止，reload重启，reopen更换日志文件 Nginx配置文件 语法\n;结尾 {}组织多条指令 include 引入 #注释 $ 变量 默认配置文件分析\nnginx.conf\n# 运行用户，默认是nginx user nginx; # nginx进程数,一般设置为和cpu核数一样 worker_processes 1; # 全局错误日志路径 error_log /var/log/nginx/error.log warn; # 进程pid路径 pid /var/run/nginx.pid; events { # 最大连接数 worker_connections 1024; } # 设置http服务器 http { include /etc/nginx/mime.types; default_type application/octet-stream; # 设置日志的格式 log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; # 访问日志的路径 access_log /var/log/nginx/access.log main; # 开启高效传输模式 sendfile on; #tcp_nopush on; # 长连接超时时间，单位是秒 keepalive_timeout 65; #传输时是否压缩，压缩的话需要解压，但是传的大小就小了 #gzip on; #加载其他的配置文件，一带多 include /etc/nginx/conf.d/*.conf; } server { listen 80; //监听端口为80，可以自定义其他端口，也可以加上IP地址，如，listen 127.0.0.1:8080; server_name localhost; //定义网站域名，可以写多个，用空格分隔。 #charset koi8-r; //定义网站的字符集，一般不设置，而是在网页代码中设置。 #access_log logs/host.access.log main; //定义访问日志，可以针对每一个server（即每一个站点）设置它们自己的访问日志。 ##在server{}里有很多location配置段 location / { root html; //定义网站根目录，目录可以是相对路径也可以是绝对路径。 index index.html index.htm; //定义站点的默认页。 } #error_page 404 /404.html; //定义404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; //当状态码为500、502、503、504时，则访问50x.html location = /50x.html { root html; //定义50x.html所在路径 } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #定义访问php脚本时，将会执行本location{}部分指令 #location ~ \\.php$ { # proxy_pass http://127.0.0.1; //proxy_pass后面指定要访问的url链接，用proxy_pass实现代理。 #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; //定义FastCGI服务器监听端口与地址，支持两种形式，1 IP:Port， 2 unix:/path/to/sockt # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; //定义SCRIPT_FILENAME变量，后面的路径/scripts为上面的root指定的目录 # include fastcgi_params; //引用prefix/conf/fastcgi_params文件，该文件定义了fastcgi相关的变量 #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { //访问的url中，以/.ht开头的，如，www.example.com/.htaccess，会被拒绝，返回403状态码。 # deny all; //这里的all指的是所有的请求。 #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; //监听8000端口 # listen somename:8080; //指定ip:port # server_name somename alias another.alias; //指定多个server_name # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; //监听443端口，即ssl # server_name localhost; ### 以下为ssl相关配置 # ssl_certificate cert.pem; //指定pem文件路径 # ssl_certificate_key cert.key; //指定key文件路径 # ssl_session_cache shared:SSL:1m; //指定session cache大小 # ssl_session_timeout 5m; //指定session超时时间 # ssl_protocols TLSv1 TLSv1.1 TLSv1.2; //指定ssl协议 # ssl_ciphers HIGH:!aNULL:!MD5; //指定ssl算法 # ssl_prefer_server_ciphers on; //优先采取服务器算法 # location / { # root html; # index index.html index.htm; # } #} location ^~ /api { rewrite ^/api/(.*)$ /$1 break; proxy_pass http://localhost:8080; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_redirect off; } ","permalink":"https://rexhub.space/posts/back/java/microservices/nginx%E4%BD%BF%E7%94%A8/","summary":"Nginx Nginx介绍 使用场景 HTTP的反向代理服务器 负载均衡 缓存 动态静态资源分离 优点 高并发、高性能 可扩展性好，体现在模块化设计 高可靠性，可以持续不断数十年运行 热部署，不停止服务来升级nginx 开源、可商用 Nginx常用命令 ./nginx # 启动nginx ps -aux|grep nginx # 查看nginx相关进程，也可以查到nginx运行的路径 nginx -h # 帮助 nginx -c # 读取指定配置文件 nginx -s stop # 关闭nginx nginx -t # 检查当前配置文件是否有问题，查看当前配置文件路径 nginx -v # 简要版本信息 -V详细信息 nginx -s stop|quit| # -s信号 stop立即停止，quit优雅停止，reload重启，reopen更换日志文件 Nginx配置文件 语法\n;结尾 {}组织多条指令 include 引入 #注释 $ 变量 默认配置文件分析\nnginx.conf\n# 运行用户，默认是nginx user nginx; # nginx进程数,一般设置为和cpu核数一样 worker_processes 1; # 全局错误日志路径 error_log /var/log/nginx/error.","title":"Nginx使用"},{"content":"微服务 微服务概述 单体应用的痛点 部署效率低下 团队写作开发成本高 系统高可用性差 服务化 把传统的单机应用中的本地方法调用，改造成通过RPC、HTTP产生的远程方法调用 把模块从单体应用中拆分出来，独立成一个服务部署 用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合 从单体到微服务架构 微服务 一种架构风格 开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源API 这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署 这些服务的集中式管理做到了最小化（例如docker相关技术），每一种服务都可以通过不同的变成语言进行编写，并且可以使用不同的数据存储技术 微服务的特点 组件以服务形式来提供\n产品不是项目\n轻量级通信、独立进程\n分散治理、去中心化治理\n容错性设计\n会带来团队组织架构的调整\n微服务优点 服务简单、便于学习和上手，先对易于维护 独立部署，灵活扩展 技术栈丰富 微服务缺点 运维成本过高 接口可能不匹配 代码可能重复 架构复杂度提高 微服务有两大门派 Spring Cloud：众多子项目 dubbo：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡以及服务自动注册和发现 核心组件 Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无/百度的disconf、百度的diamond Spring Cloud Config 服务跟踪 无/京东开源Hydra Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无/当当开源Elastic-Job Spring Cloud Task 通信协议对比 RPC vs REST 服务提供方与调用方接口依赖方式太强 服务对平台敏感，难以简单服务 微服务拆分 服务化拆分 第一阶段的主要目标是快速开发和验证想法 进一步增加更多的新特性来吸引更多的目标用户 同时进行开发的人员超过10人，这个时候就该考虑服务化拆分了 不适合拆分的情况 小团队，技术基础较薄弱 流量不够，压力小，业务变化也不大 对延迟很敏感的低延迟高并发系统 拆分方式 纵向拆分，按照业务维度拆分 横向拆分，按照公共领域拆分 结合业务综合分析 服务扩展 x轴-水平复制，作为整体复制多个系统，重新部署几套，加一个负载均衡器 y轴-功能解耦，微服务拆解 z轴-数据分区，拆分数据库 自动按需扩展 根据CPU负载程度、特定时间（比如周末）、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展 自动分配了一个新的服务实例，提高可用性 提高了可伸缩性（双11之后，自动减少了服务器） 具有最佳使用率，节约成本 微服务重要模块 服务描述 注册服务中心 服务框架 负载均衡 熔断和降级，兜底策略 网关：统一转换，校验，过滤器 ","permalink":"https://rexhub.space/posts/back/java/microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","summary":"微服务 微服务概述 单体应用的痛点 部署效率低下 团队写作开发成本高 系统高可用性差 服务化 把传统的单机应用中的本地方法调用，改造成通过RPC、HTTP产生的远程方法调用 把模块从单体应用中拆分出来，独立成一个服务部署 用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合 从单体到微服务架构 微服务 一种架构风格 开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源API 这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署 这些服务的集中式管理做到了最小化（例如docker相关技术），每一种服务都可以通过不同的变成语言进行编写，并且可以使用不同的数据存储技术 微服务的特点 组件以服务形式来提供\n产品不是项目\n轻量级通信、独立进程\n分散治理、去中心化治理\n容错性设计\n会带来团队组织架构的调整\n微服务优点 服务简单、便于学习和上手，先对易于维护 独立部署，灵活扩展 技术栈丰富 微服务缺点 运维成本过高 接口可能不匹配 代码可能重复 架构复杂度提高 微服务有两大门派 Spring Cloud：众多子项目 dubbo：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡以及服务自动注册和发现 核心组件 Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无/百度的disconf、百度的diamond Spring Cloud Config 服务跟踪 无/京东开源Hydra Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无/当当开源Elastic-Job Spring Cloud Task 通信协议对比 RPC vs REST 服务提供方与调用方接口依赖方式太强 服务对平台敏感，难以简单服务 微服务拆分 服务化拆分 第一阶段的主要目标是快速开发和验证想法 进一步增加更多的新特性来吸引更多的目标用户 同时进行开发的人员超过10人，这个时候就该考虑服务化拆分了 不适合拆分的情况 小团队，技术基础较薄弱 流量不够，压力小，业务变化也不大 对延迟很敏感的低延迟高并发系统 拆分方式 纵向拆分，按照业务维度拆分 横向拆分，按照公共领域拆分 结合业务综合分析 服务扩展 x轴-水平复制，作为整体复制多个系统，重新部署几套，加一个负载均衡器 y轴-功能解耦，微服务拆解 z轴-数据分区，拆分数据库 自动按需扩展 根据CPU负载程度、特定时间（比如周末）、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展 自动分配了一个新的服务实例，提高可用性 提高了可伸缩性（双11之后，自动减少了服务器） 具有最佳使用率，节约成本 微服务重要模块 服务描述 注册服务中心 服务框架 负载均衡 熔断和降级，兜底策略 网关：统一转换，校验，过滤器 ","title":"微服务"},{"content":"RabbitMQ RabbitMQ简介 核心思想 接受并转发消息。\nproducer: P queue: queue_name Consumer: C 消息队列： 业务无关 FIFO 容灾 性能 特点： 开源、跨语言 Erlang语言编写 应用广泛 社区活跃、API丰富 AMBQ协议 Advanced Message Queue Protocol RabbitMQ核心概念 Server：服务 connection：与Server建立连接 channel：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道 message：消息，有properties和body组成 virtual host：虚拟主机，顶层隔离。同一个虚拟主机下，不能有重复的交换机和queue Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到锁绑定的队列上 binding：绑定交换机和队列 routing key：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由 queue：队列，消费者只需要监听队列来消费信息，不需要关注消息来自于哪个Exchange Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列 消息流转过程 RabbitMQ常用命令 systemctl start rabbitmq-server # 启动rabbitmq rabbitmqctl status # 查看状态 RabbitMQ后台管理 http://1.117.91.88:15672/#/connections rabbitmq management\nRabbitMQ应用 第一个java应用 Hello world 导入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.rabbitmq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;amqp-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-nop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.29\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Send.java\npackage helloworld; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: Hello world发送类，连接到RabbitMQ服务端， * 然后发送一条消息，然后退出。 * @Author: Rex * @Create: 2021-06-16 12:54 */ public class Send { private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址 factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接 Connection conn = factory.newConnection(); // 获得信道 Channel channel = conn.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发布消息 String message = \u0026#34;Hello rex!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, QUEUE_NAME, null, message.getBytes(\u0026#34;UTF-8\u0026#34;)); System.out.println(\u0026#34;发送了消息：\u0026#34; + message); // 关闭连接 channel.close(); conn.close(); } } Resv.java\npackage helloworld; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 接受消息，并打印，持续运行 * @Author: Rex * @Create: 2021-06-16 13:11 */ public class Recv { private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址 factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接 Connection conn = factory.newConnection(); // 获得信道 Channel channel = conn.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 接受消息 channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;接收到了消息：\u0026#34; + message); } }); } } 控制台\nSend 发送了消息：Hello rex! Recv 接收到了消息：Hello rex! 多个消费者平均分配 NewTask.java\npackage workqueues; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 消费者，接受前面的批量消息 * @Author: Rex * @Create: 2021-06-16 14:23 */ public class Worker { private final static String TASK_QUEUE_NAME = \u0026#34;task_queue\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址 factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接 Connection conn = factory.newConnection(); // 获得信道 Channel channel = conn.createChannel(); // 声明队列 channel.basicQos(1); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\u0026#34;开始接收消息\u0026#34;); channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;收到了消息：\u0026#34; + message); try { doWork(message); } finally { System.out.println(\u0026#34;完成消息处理\u0026#34;); channel.basicAck(envelope.getDeliveryTag(), false); } } }); } private static void doWork(String task){ char[] chars = task.toCharArray(); for (char ch : chars) { if (ch == \u0026#39;.\u0026#39;){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } Worker\npackage workqueues; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 消费者，接受前面的批量消息 * @Author: Rex * @Create: 2021-06-16 14:23 */ public class Worker { private final static String TASK_QUEUE_NAME = \u0026#34;task_queue\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址 factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接 Connection conn = factory.newConnection(); // 获得信道 Channel channel = conn.createChannel(); // 声明队列 channel.basicQos(1); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\u0026#34;开始接收消息\u0026#34;); channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;收到了消息：\u0026#34; + message); try { doWork(message); } finally { System.out.println(\u0026#34;完成消息处理\u0026#34;); channel.basicAck(envelope.getDeliveryTag(), false); } } }); } private static void doWork(String task){ char[] chars = task.toCharArray(); for (char ch : chars) { if (ch == \u0026#39;.\u0026#39;){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 控制台\nNewTask 发送了消息：message 0... 发送了消息：message 1 发送了消息：message 2... 发送了消息：message 3 发送了消息：message 4... 发送了消息：message 5 发送了消息：message 6... 发送了消息：message 7 发送了消息：message 8... 发送了消息：message 9 Worker(1) 开始接收消息 收到了消息：message 0... 完成消息处理 收到了消息：message 5 完成消息处理 收到了消息：message 7 完成消息处理 收到了消息：message 8... 完成消息处理 Worker(2) 开始接收消息 收到了消息：message 1 完成消息处理 收到了消息：message 3 完成消息处理 收到了消息：message 4... 完成消息处理 收到了消息：message 9 完成消息处理 Worker(3) 开始接收消息 收到了消息：message 2... 完成消息处理 收到了消息：message 6... 完成消息处理 交换机 交换机工作模式 fanout\n广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的\nEmitLog.java\npackage fanout; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.Exchanger; import java.util.concurrent.TimeoutException; /** * @Description: 发送日志信息 * @Author: Rex * @Create: 2021-06-17 15:58 */ public class EmitLog { private static final String EXCHANGE_NAME = \u0026#34;logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT.getType()); String message = \u0026#34;info: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息：\u0026#34; + message); channel.close(); conn.close(); } } ReceiveLogs.java\npackage fanout; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受日志消息 * @Author: Rex * @Create: 2021-06-17 16:07 */ public class ReceiveLogs { private static final String EXCHANGE_NAME = \u0026#34;logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT.getType()); // 临时队列 String queueName = channel.queueDeclare().getQueue(); // 将队列绑定在交换机上 channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLog 发送了消息：info: Hello World! ReceiveLogs 开始接受消息 收到消息：info: Hello World! ReceiveLogs(2) 开始接受消息 收到消息：info: Hello World! ReceiveLogs(3) 开始接受消息 收到消息：info: Hello World! direct\n根据RoutingKey匹配消息路由到指定的队列\nEmitLogDirect\npackage direct; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: direct类型的交换机，发送消息 * @Author: Rex * @Create: 2021-06-17 16:31 */ public class EmitLogDirect { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); String message = \u0026#34;info: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;info\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为info，消息内容：\u0026#34;+ message); message = \u0026#34;warning: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;warning\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为warning，消息内容：\u0026#34;+ message); message = \u0026#34;error: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;error\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为error，消息内容：\u0026#34;+ message); channel.close(); conn.close(); } } ReceiveLogsDirect1.java\npackage direct; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受3个类型等级的日志 * @Author: Rex * @Create: 2021-06-17 16:37 */ public class ReceiveLogsDirect1 { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); // 生成一个随机的临时的队列 String queueName = channel.queueDeclare().getQueue(); // 一个交换机同时绑定3个对列 channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;info\u0026#34;); channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;warning\u0026#34;); channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;error\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } ReceiveLogsDirect2.java\npackage direct; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受1个类型等级的日志 * @Author: Rex * @Create: 2021-06-17 16:37 */ public class ReceiveLogsDirect2 { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); // 生成一个随机的临时的队列 String queueName = channel.queueDeclare().getQueue(); // 一个交换机只绑定1个对列 channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;error\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLogDirect: 发送了消息，等级为info，消息内容：info: Hello World! 发送了消息，等级为warning，消息内容：warning: Hello World! 发送了消息，等级为error，消息内容：error: Hello World! ReceiveLogsDirect1: 开始接受消息 收到消息：info: Hello World! 收到消息：warning: Hello World! 收到消息：error: Hello World! ReceiveLogsDirect2: 开始接受消息 收到消息：error: Hello World! topic\n生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发\n*可以代替一个单词 #可以代替零个或多个单词 EmitLogTopic.java\npackage topic; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: Topic模式交换机，发送消息 * @Author: Rex * @Create: 2021-06-18 11:23 */ public class EmitLogTopic { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); String message = \u0026#34;Animal world!\u0026#34;; String[] routingKeys = new String[9]; routingKeys[0] = \u0026#34;quick.orange.rabbit\u0026#34;; routingKeys[1] = \u0026#34;lazy.orange.elephant\u0026#34;; routingKeys[2] = \u0026#34;quick.orange.fox\u0026#34;; routingKeys[3] = \u0026#34;lazy.brown.fox\u0026#34;; routingKeys[4] = \u0026#34;lazy.pink.rabbit\u0026#34;; routingKeys[5] = \u0026#34;quick.brown.fox\u0026#34;; routingKeys[6] = \u0026#34;orange\u0026#34;; routingKeys[7] = \u0026#34;quick.orange.male.rabbit\u0026#34;; routingKeys[8] = \u0026#34;lazy.orange.male.rabbit\u0026#34;; for (int i = 0; i \u0026lt; routingKeys.length; i++) { channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了：\u0026#34; + message + \u0026#34;routingKey：\u0026#34; + routingKeys[i]); } channel.close(); conn.close(); } } ReceiveLogsTopic1.java\npackage topic; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 特定路由键 * @Author: Rex * @Create: 2021-06-18 11:48 */ public class ReceiveLogsTopic1 { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); // 生成一个随机的临时的队列 String queueName = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;*.orange.*\u0026#34;; channel.queueBind(queueName, EXCHANGE_NAME, routingKey); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message + \u0026#34; routingKey: \u0026#34; + envelope.getRoutingKey()); } }; channel.basicConsume(queueName, true, consumer); } } ReveiveLogsTopic2.java\npackage topic; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 特定路由键 * @Author: Rex * @Create: 2021-06-18 11:48 */ public class ReceiveLogsTopic1 { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); // 生成一个随机的临时的队列 String queueName = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;*.orange.*\u0026#34;; channel.queueBind(queueName, EXCHANGE_NAME, routingKey); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message + \u0026#34; routingKey: \u0026#34; + envelope.getRoutingKey()); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLogTopic 发送了：Animal world!routingKey：quick.orange.rabbit 发送了：Animal world!routingKey：lazy.orange.elephant 发送了：Animal world!routingKey：quick.orange.fox 发送了：Animal world!routingKey：lazy.brown.fox 发送了：Animal world!routingKey：lazy.pink.rabbit 发送了：Animal world!routingKey：quick.brown.fox 发送了：Animal world!routingKey：orange 发送了：Animal world!routingKey：quick.orange.male.rabbit 发送了：Animal world!routingKey：lazy.orange.male.rabbit ReceiveLogsTopic1 开始接受消息 收到消息：Animal world! routingKey: quick.orange.rabbit 收到消息：Animal world! routingKey: lazy.orange.elephant 收到消息：Animal world! routingKey: quick.orange.fox ReceiveLogsTopic2 开始接受消息 收到消息：Animal world! routingKey: quick.orange.rabbit 收到消息：Animal world! routingKey: lazy.orange.elephant 收到消息：Animal world! routingKey: lazy.brown.fox 收到消息：Animal world! routingKey: lazy.pink.rabbit 收到消息：Animal world! routingKey: lazy.orange.male.rabbit headers（不常用）\n根据发送消息内容中的headers属性来匹配\nSpringBoot整合RabbitMQ 引入依赖文件\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp \u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写application.propertise\nconsumer\nserver.port=8081 spring.application.name=consumer spring.rabbitmq.addresses=1.117.91.88:5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000 producer\nserver.port=8080 spring.application.name=producer spring.rabbitmq.addresses=1.117.91.88:5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000 生产者中编写配置文件\npackage com.imooc.springbootrabbitmqproducer; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Description: rabbitmq配置类 * @Author: Rex * @Create: 2021-06-19 9:58 */ @Configuration public class TopicRabbitConfig { @Bean public Queue queue1(){ return new Queue(\u0026#34;queue1\u0026#34;); } @Bean public Queue queue2(){ return new Queue(\u0026#34;queue2\u0026#34;); } @Bean TopicExchange exchange(){ return new TopicExchange(\u0026#34;bootExchange\u0026#34;); } @Bean Binding bindingExchangeMessage1(Queue queue1, TopicExchange exchange){ return BindingBuilder.bind(queue1).to(exchange).with(\u0026#34;dog.red\u0026#34;); } @Bean Binding bindingExchangeMessage2(Queue queue2, TopicExchange exchange){ return BindingBuilder.bind(queue2).to(exchange).with(\u0026#34;dog.#\u0026#34;); } } 生产者发送消息\npackage com.imooc.springbootrabbitmqproducer; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; /** * @Description: 发送消息 * @Author: Rex * @Create: 2021-06-19 10:06 */ @Component public class MessageSender { @Autowired private AmqpTemplate rabbitmqTemplate; public void send1(){ String message = \u0026#34;This is message 1, routing key is dog.red\u0026#34;; System.out.println(\u0026#34;发送了：\u0026#34; + message); this.rabbitmqTemplate.convertAndSend(\u0026#34;bootExchange\u0026#34;, \u0026#34;dog.red\u0026#34;, message); } public void send2(){ String message = \u0026#34;This is message 1, routing key is dog.black\u0026#34;; System.out.println(\u0026#34;发送了：\u0026#34; + message); this.rabbitmqTemplate.convertAndSend(\u0026#34;bootExchange\u0026#34;, \u0026#34;dog.black\u0026#34;, message); } } 消费者接受消息\nReceiver1.java\npackage com.imooc.springbootrabbitmqconsumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @Description: 接收者1 * @Author: Rex * @Create: 2021-06-19 10:11 */ @Component @RabbitListener(queues = \u0026#34;queue1\u0026#34;) public class Receiver1 { @RabbitHandler public void process(String message){ System.out.println(\u0026#34;Receiver1：\u0026#34; + message); } } Receiver2.java\npackage com.imooc.springbootrabbitmqconsumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @Description: 接收者2 * @Author: Rex * @Create: 2021-06-19 10:11 */ @Component @RabbitListener(queues = \u0026#34;queue2\u0026#34;) public class Receiver2 { @RabbitHandler public void process(String message){ System.out.println(\u0026#34;Receiver2：\u0026#34; + message); } } 生产者发送消息\npackage com.imooc.springbootrabbitmqproducer; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class SpringBootRabbitmqProducerApplicationTests { @Autowired private MessageSender messageSender; @Test public void send1(){ messageSender.send1(); } @Test public void send2(){ messageSender.send2(); } } 结果\n生产者：\n2021-06-19 10:19:00.888 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : Starting SpringBootRabbitmqProducerApplicationTests on LAPTOP-LRX with PID 20912 (started by Rex in G:\\Web开发\\后端\\code\\spring-boot-rabbitmq-producer) 2021-06-19 10:19:00.891 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : No active profile set, falling back to default profiles: default 2021-06-19 10:19:05.283 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : Started SpringBootRabbitmqProducerApplicationTests in 5.244 seconds (JVM running for 8.205) 发送了：This is message 1, routing key is dog.red 2021-06-19 10:19:05.814 INFO 20912 --- [ main] o.s.a.r.c.CachingConnectionFactory : Attempting to connect to: [1.117.91.88:5672] 2021-06-19 10:19:06.059 INFO 20912 --- [ main] o.s.a.r.c.CachingConnectionFactory : Created new connection: rabbitConnectionFactory#7072bc39:0/SimpleConnection@ff6077 [delegate=amqp://admin@1.117.91.88:5672/, localPort= 10788] 发送了：This is message 1, routing key is dog.black 消费者\n2021-06-19 10:18:35.322 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : Starting SpringBootRabbitmqConsumerApplication on LAPTOP-LRX with PID 30312 (started by Rex in G:\\Web开发\\后端\\code\\spring-boot-rabbitmq-consumer) 2021-06-19 10:18:35.328 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : No active profile set, falling back to default profiles: default 2021-06-19 10:18:37.160 INFO 30312 --- [ main] o.s.a.r.c.CachingConnectionFactory : Attempting to connect to: [1.117.91.88:5672] 2021-06-19 10:18:37.299 INFO 30312 --- [ main] o.s.a.r.c.CachingConnectionFactory : Created new connection: rabbitConnectionFactory#21a21c64:0/SimpleConnection@7c098bb3 [delegate=amqp://admin@1.117.91.88:5672/, localPort= 7674] Receiver1：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.black 2021-06-19 10:18:37.602 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : Started SpringBootRabbitmqConsumerApplication in 3.042 seconds (JVM running for 6.02) Receiver1：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.black @RabbitListener 当@RabbitListener注解标注在方法上，监听到队列 debug 中有消息时则会进行接收并处理。 当@RabbitListener标注在类上面时，需配合@RabbitHandler注解一起使用。 @RabbitHandler （@RabbitHandle注解用于表示收到某队列对应类型的消息时，要执行的内容。）\n当有收到某队列queue里面的消息的时候，就交给有@RabbitHandler注解的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型。RabbitMQ支持任何类型的数据消息。\n","permalink":"https://rexhub.space/posts/back/java/microservices/rabbitmq/","summary":"RabbitMQ RabbitMQ简介 核心思想 接受并转发消息。\nproducer: P queue: queue_name Consumer: C 消息队列： 业务无关 FIFO 容灾 性能 特点： 开源、跨语言 Erlang语言编写 应用广泛 社区活跃、API丰富 AMBQ协议 Advanced Message Queue Protocol RabbitMQ核心概念 Server：服务 connection：与Server建立连接 channel：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道 message：消息，有properties和body组成 virtual host：虚拟主机，顶层隔离。同一个虚拟主机下，不能有重复的交换机和queue Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到锁绑定的队列上 binding：绑定交换机和队列 routing key：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由 queue：队列，消费者只需要监听队列来消费信息，不需要关注消息来自于哪个Exchange Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列 消息流转过程 RabbitMQ常用命令 systemctl start rabbitmq-server # 启动rabbitmq rabbitmqctl status # 查看状态 RabbitMQ后台管理 http://1.117.91.88:15672/#/connections rabbitmq management\nRabbitMQ应用 第一个java应用 Hello world 导入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.rabbitmq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;amqp-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-nop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.29\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Send.java","title":"Rabbitmq使用"},{"content":"CSS3 CSS新增选择器 属性选择器 选择器 简介 E[attr] 选择具有attr属性的E元素 E[attr=\u0026ldquo;val\u0026rdquo;] 选择具有attr属性且属性值等于E的元素 E[attr^=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val开头的E元素 E[attr$=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val结尾的E元素 E[attr*=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值中含有val的E元素 属性选择器的权重为10\n结构伪类选择器 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 nth-child(n)\nn可以是数字，关键字和公式 n如果是是数字，就是选择第n个子元素，里面数字从1开始 n可以是关键字：even偶数，odd奇数 伪元素选择器 ​\t伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构\n选择器 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意：\nbefore和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法：element::before{} before和after必须有content属性 before在父元素内容的前面创建元素，after在父元素内容的后面插入元素 伪元素选择器和标签选择器一样，权重为1 CSS3盒子模型 box-sizing: content-box 盒子大小为width+padding+border(以前默认的) border-box 盒子大小width 其他特性（了解） filter CSS属性将模糊或颜色偏移等图形效果应用于元素。\nfilter: 函数(); 例如filter:blur(5px); blur模糊处理数值越大越模糊 calc()此CSS函数让你在声明CSS属性值时执行一些计算。\nwidth:calc(100%-80px); CSS过渡 transition:要过渡的属性 花费时间 运动曲线 何时开始;\n属性：想要变化的CSS属性，宽度高度 背景颜色 内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以。\n花费时间：单位是秒（必须写单位）比如0.5s\n运动曲线：默认是ease（可以省略）\nlinear:匀速\nease:逐渐慢下来\nease-in:加速\nease-out:减速\nease-in-out:先加速后减速\n何时开始：单位是秒（必须写单位）可以设置延迟触发时间 默认是0s（可以省略）\n谁做过渡给谁加\n2D转换 转换(transform)是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果\n移动：translate 旋转：rotate 缩放：scale 2D转换是改变在二维平面上的位置和形状的一种技术\ntranslate: 平移元素\ntransform: translate(x, y) | translateX(x) | translateY(y)\n定义2D转换中的移动，沿着X和Y轴移动元素 translate最大的优点：不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的translate：(50%, 50%); 对行内标签没有效果 rotate旋转： 旋转元素\ntransform: rotate(xdeg)\ntransform-origin 设置元素中心点\ntransform-origin: x y;\n参数x和y用空格隔开 x y默认转换的中心点是元素的中心点（50%, 50%） 给x y设置像素或方位名词（top bottom left right center） 2D转换之缩放scale 控制元素的放大与缩小\ntransform: scale(x, y)\n注意其中的x和y用逗号分隔 transform: scale(1, 1)：宽和高都放大一倍，相对于没有放大 transform: scale(2, 2)：宽和高都放大了2倍 transform: scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2,2) transform：scale(0.5, 0.5)：缩小 scale缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子 2D转换综合写法 同时使用多个转换，其格式为：transform: translate() rotate() scale() \u0026hellip;等 其顺序回影响转换的效果。（先旋转会改变坐标轴方向） 当我们同时有位移和其他属性的时候，记得要将位移放到最前 动画 动画（animation）是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。\n相比较过渡，动画可以实现更多变化，更多控制，连续自动播放。\n基本使用 @keyframes move { /* 开始状态 */ 0% { transform: translateX(0px); } /* 结束状态 */ 100% { transform: translateX(100px); } } div { width: 200px; height: 200px; background-color: pink; /* 调用动画 */ animation-name: move; /* 持续时间 */ animation-duration: 1s; } 动画序列 可以做多个状态的变化 keyframe关键帧 里面的百分比要是整数 里面的百分比就是总的时间 动画常用属性 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了animation-play-state属性。 animation-name 规定@keyframes动画的名称。（必须的） animation-duration 规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须的） animation-timing-function 规定动画的速度曲线，默认是“ease”。 animation-delay 规定动画何时开始，默认是0。 animation-iteration-count 规定动画播放的次数，默认是1，还有infinite animation-direction 规定动画是否在下一周期逆向播放，默认是\u0026quot;normal\u0026quot;，alternate逆播放 animation-play-state 规定动画是否正在运行或暂停。默认是\u0026quot;running\u0026quot;，还有\u0026quot;pause\u0026quot;。 animation-fill-mode 规定动画结束后状态，保持forwards回到起始backwards ","permalink":"https://rexhub.space/posts/front/css3/","summary":"CSS3 CSS新增选择器 属性选择器 选择器 简介 E[attr] 选择具有attr属性的E元素 E[attr=\u0026ldquo;val\u0026rdquo;] 选择具有attr属性且属性值等于E的元素 E[attr^=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val开头的E元素 E[attr$=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val结尾的E元素 E[attr*=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值中含有val的E元素 属性选择器的权重为10\n结构伪类选择器 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 nth-child(n)\nn可以是数字，关键字和公式 n如果是是数字，就是选择第n个子元素，里面数字从1开始 n可以是关键字：even偶数，odd奇数 伪元素选择器 ​\t伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构\n选择器 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意：\nbefore和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法：element::before{} before和after必须有content属性 before在父元素内容的前面创建元素，after在父元素内容的后面插入元素 伪元素选择器和标签选择器一样，权重为1 CSS3盒子模型 box-sizing: content-box 盒子大小为width+padding+border(以前默认的) border-box 盒子大小width 其他特性（了解） filter CSS属性将模糊或颜色偏移等图形效果应用于元素。\nfilter: 函数(); 例如filter:blur(5px); blur模糊处理数值越大越模糊 calc()此CSS函数让你在声明CSS属性值时执行一些计算。\nwidth:calc(100%-80px); CSS过渡 transition:要过渡的属性 花费时间 运动曲线 何时开始;","title":"CSS3"},{"content":"Nginx的安装 Linux安装 登录root账号 执行yum install yum-utils 运行vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 然后查看源 yum list | grep nginx 看到存在稳定版的源，确认无误。 运行安装命令 yum install nginx 1:1.16.1-1.el7.ngx 过程中输入y，确认 查看版本，若出现版本号，则安装成功 用whereis nginx可以查看到目录： nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz MacOS的安装 安装homebrew，然后nginx使用安装brew： $ brew install nginx 笔记：\nnginx的配置文件位于中/usr/local/etc/nginx/nginx.conf。 要编辑配置文件或运行nginx，您需要使用sudo： sudo nano /usr/local/etc/nginx/nginx.conf和 sudo nginx \u0026hellip;\nWindows下的安装 不推荐，nginx不适合运行在Windows上，功能不完整，我们尽量运行在linux上。\n","permalink":"https://rexhub.space/posts/back/java/microservices/nginx%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"Nginx的安装 Linux安装 登录root账号 执行yum install yum-utils 运行vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 然后查看源 yum list | grep nginx 看到存在稳定版的源，确认无误。 运行安装命令 yum install nginx 1:1.16.1-1.el7.ngx 过程中输入y，确认 查看版本，若出现版本号，则安装成功 用whereis nginx可以查看到目录： nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz MacOS的安装 安装homebrew，然后nginx使用安装brew： $ brew install nginx 笔记：\nnginx的配置文件位于中/usr/local/etc/nginx/nginx.conf。 要编辑配置文件或运行nginx，您需要使用sudo： sudo nano /usr/local/etc/nginx/nginx.conf和 sudo nginx \u0026hellip;\nWindows下的安装 不推荐，nginx不适合运行在Windows上，功能不完整，我们尽量运行在linux上。","title":"Nginx的入门"},{"content":"Docker的安装 在Cent OS安装docker 先有一个Cent OS 7.6系统 这个很重要，不同版本按照的时候是不一样的。查看CentOS版本 cat /etc/redhat-release\n用root账户登录进去 配置国内yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache\n卸载旧版本 较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。 如果yum报告未安装这些软件包，也没问题。\ndocker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 更新yum yum check-update yum update\n安装所需的软件包 yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的存储库。 sudo yum-config-manager \u0026ndash;add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n查看docker版本 yum list docker-ce \u0026ndash;showduplicates | sort -r\n安装指定的版本 yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io\nDocker 是服务器\u0026mdash;-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动 systemctl start docker\n安装完成后，运行下面的命令，验证是否安装成功。 docker version 或者 docker info\n","permalink":"https://rexhub.space/posts/back/java/microservices/docker%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"Docker的安装 在Cent OS安装docker 先有一个Cent OS 7.6系统 这个很重要，不同版本按照的时候是不一样的。查看CentOS版本 cat /etc/redhat-release\n用root账户登录进去 配置国内yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache\n卸载旧版本 较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。 如果yum报告未安装这些软件包，也没问题。\ndocker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 更新yum yum check-update yum update\n安装所需的软件包 yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的存储库。 sudo yum-config-manager \u0026ndash;add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n查看docker版本 yum list docker-ce \u0026ndash;showduplicates | sort -r\n安装指定的版本 yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io\nDocker 是服务器\u0026mdash;-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动 systemctl start docker","title":"Docker的安装"},{"content":"分布式 定义： 利用物理架构形成多个自治的处理元素，不共享主内存, 但是通过发送信息合作。\u0026mdash; Leslie Lamport\n实际项目的演进过程 一个项目，大而全 多台机器，部署同样的应用 分布式：权限系统、员工系统、请假系统 分布式的作用 为什么需要分布式 解决单体应用的问题 应用代码耦合严重，功能扩展难 新需求开发交互周期长，测试工程量大 新加入的开发同事需要很长时间才能属性系统 升级维护困难（改动任何一点地方都要升级整个系统） 系统性能提升艰难，可用性低，不稳定 分布式的好处 增大系统容量 加强系统可用 因为模块化，所以系统模块重用度高 因为软件服务模块被拆分，开发和发布速度可以并行变得更块 系统拓展性更高 团队协作流程也会得到改善 技术升级 分布式和单体结构的对比 传统单体结构 分布式架构 新人的学习成本 业务逻辑成本高 架构逻辑成本高 部署、运维 容易 发布频繁，发布顺序复杂、运维难 隔离性 一损俱损，殃及鱼塘 故障影响范围小 架构设计 难度低 难度指数级上升 系统性能 响应快、吞吐量小 响应慢、吞吐量大 测试成本 低 很高 技术多样性 技术单一且封闭 技术多样且开放 系统扩展性 扩展性差 扩展性很好 系统管理成本 成本低 成本高 CAP定理 CAP理论：三者不可兼得\nC：（Consistency，一致性）：读操作是否总能读到前一个写操作的结果 A：（Availbilty，可用性）：非故障节点应该在合理的时间内做出合理的响应，但是可能不是最新的数据 P：（Partition tolerance，分区容错性）：当出现网络分区现象后，系统能够继续运行 分区容错（P）\n一致性（C）\n可用性(A)\nCAP的选取\n火车票 C 银行转账 A 集群、分布式、微服务的区别 集群与分布式 集群：一个业拆分多个子业务，部署在不同的服务器上 分布式：同一个业务，部署在多个服务器上 集群和微服务 集群：分散压力 微服务：分散能力 分布式和微服务 分布式：系统部署方式，部署角度（后） 微服务：架构设计方式，逻辑角度（先） ","permalink":"https://rexhub.space/posts/back/java/microservices/%E5%88%86%E5%B8%83%E5%BC%8F/","summary":"分布式 定义： 利用物理架构形成多个自治的处理元素，不共享主内存, 但是通过发送信息合作。\u0026mdash; Leslie Lamport\n实际项目的演进过程 一个项目，大而全 多台机器，部署同样的应用 分布式：权限系统、员工系统、请假系统 分布式的作用 为什么需要分布式 解决单体应用的问题 应用代码耦合严重，功能扩展难 新需求开发交互周期长，测试工程量大 新加入的开发同事需要很长时间才能属性系统 升级维护困难（改动任何一点地方都要升级整个系统） 系统性能提升艰难，可用性低，不稳定 分布式的好处 增大系统容量 加强系统可用 因为模块化，所以系统模块重用度高 因为软件服务模块被拆分，开发和发布速度可以并行变得更块 系统拓展性更高 团队协作流程也会得到改善 技术升级 分布式和单体结构的对比 传统单体结构 分布式架构 新人的学习成本 业务逻辑成本高 架构逻辑成本高 部署、运维 容易 发布频繁，发布顺序复杂、运维难 隔离性 一损俱损，殃及鱼塘 故障影响范围小 架构设计 难度低 难度指数级上升 系统性能 响应快、吞吐量小 响应慢、吞吐量大 测试成本 低 很高 技术多样性 技术单一且封闭 技术多样且开放 系统扩展性 扩展性差 扩展性很好 系统管理成本 成本低 成本高 CAP定理 CAP理论：三者不可兼得\nC：（Consistency，一致性）：读操作是否总能读到前一个写操作的结果 A：（Availbilty，可用性）：非故障节点应该在合理的时间内做出合理的响应，但是可能不是最新的数据 P：（Partition tolerance，分区容错性）：当出现网络分区现象后，系统能够继续运行 分区容错（P）\n一致性（C）\n可用性(A)\nCAP的选取\n火车票 C 银行转账 A 集群、分布式、微服务的区别 集群与分布式 集群：一个业拆分多个子业务，部署在不同的服务器上 分布式：同一个业务，部署在多个服务器上 集群和微服务 集群：分散压力 微服务：分散能力 分布式和微服务 分布式：系统部署方式，部署角度（后） 微服务：架构设计方式，逻辑角度（先） ","title":"分布式"},{"content":"ThreadLocal详解 使用场景： 每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）\n每个Thread内有自己的实例副本，不共享 比喻：教材只有一本，一起做笔记有线程安全问题。复印后没有问题，ThreadLocal相当于生成了一个副本 重写initialValue方法\npackage treadlocal; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @Description: 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 * @Author: Rex * @Create: 2021-06-09 14:43 */ public class ThreadLocalNormalUsage05 { public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws InterruptedException { for (int i = 0; i \u0026lt; 1000; i++) { int finalI = i; executor.submit(new Thread(new Runnable() { @Override public void run() { String date = new ThreadLocalNormalUsage05().date(finalI); System.out.println(Thread.currentThread().getName ()+\u0026#34;:\u0026#34;+date); } })); } executor.shutdown(); } public String date(int seconds){ // 参数的单位是毫秒，从1970.1.1 00:00:00 GMT+计时 Date date = new Date(1000 * seconds); SimpleDateFormat sdf = ThreadSafeFormatter.threadLocal.get(); return sdf.format(date); } } class ThreadSafeFormatter { public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; dateFormatThreadLocal = new ThreadLocal\u0026lt;SimpleDateFormat\u0026gt;(){ @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;); } }; public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; threadLocal = ThreadLocal.withInitial(()-\u0026gt;new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;)); } 每个线程内需要保存全局变量（例如获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦\n手动调用set方法\npackage treadlocal; /** * @Description: 演示ThreadLocal用法2：避免传递参数的麻烦 * @Author: Rex * @Create: 2021-06-09 19:49 */ public class ThreadLocalNormalUsage06 { public static void main(String[] args) { new Service1().process(); } } class UserContextHolder{ public static ThreadLocal\u0026lt;User\u0026gt; holder = new ThreadLocal\u0026lt;\u0026gt;(); } class Service1 { public void process(){ User user = new User(\u0026#34;超哥\u0026#34;); UserContextHolder.holder.set(user); new Service2().process(); } } class Service2 { public void process(){ User user = UserContextHolder.holder.get(); System.out.println(\u0026#34;service2拿到用户名：\u0026#34; + user.name); new Service3().process(); } } class Service3 { public void process(){ User user = UserContextHolder.holder.get(); System.out.println(\u0026#34;service3拿到用户名：\u0026#34; + user.name); } } class User { String name; public User(String name) { this.name = name; } } /** 结果： service2拿到用户名：超哥 service3拿到用户名：超哥 */ ThreadLocal的两大作用 让某个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象) 在任何方法中都可以轻松获取到该对象 initialValue 在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制 set 如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息 用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用 ThreadLocal的好处： 达到线程安全\n不需要加锁，提高执行效率\n更高效地利用内存、节省开销\n相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销 免去传参的繁琐\n不需要每次都传同样的参数\nThreadLocal使得代码耦合度低，更优雅\n主要方法： T initialValue(): 初始化 该方法会返回当前线程对应的\u0026quot;初始值\u0026quot;，这是一个延迟加载的方法，只有在调用get的时候，才会触发 当线程第一次使用get方法访问变量，将调用此方法 每个线程最多调用一次此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法 如果不重写此方法，这个方法会放回null。一般使用匿名内部类的方法来重写initialValue()方法 void set(T t)：为这个线程设置一个新值 T get()：得到这个线程对应的value。如果是首次调用get()，则会调用initialize来得到这个值 void remove()：删除对应这个线程的值 源码分析 get方法:\nset方法：\nget方法是先取出当前线程的ThreadLocal\n然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入\n取出map中属于ThreadLocal的value\n注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal\ninitialValue方法\n没有默认实现 如果要用initialValue()方法，需要自己实现 通常使用匿名内部类的方式实现 remove方法\nThreadLocalMap\nThreadLocalMap 类， 也就是Thread.threadLocals\nThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个map，键值对：\n键：这个ThreadLocal 值：实际需要的成员变量，比如user或者simpleDateFormat对象 冲突：\nHashMap\nThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是链表拉链\n使用注意点 内存泄露（OOM） 什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收 key的泄露：ThreadLocalMap中的Entry继承自WeakReference，是弱引用 value的泄露 ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用 正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收机制回收，因为没有任何强引用了 但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链：Thread -\u0026gt; ThreadLocalMap -\u0026gt; Entry(key为null) -\u0026gt; value 因为value和Thread还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM 扫描key为null的Entry，并把对应的value设置为null 如果一个ThreadLocal不被使用，就可能导致value的内存泄露 如何避免（阿里规约）： 调用remove方法，就会删除对应的Entry对象，可以避免内存泄露，所以使用完ThreadLocal之后，应该调用remove方法 空指针异常(NPE) 包装类不能用基本数据类型去接受 ","permalink":"https://rexhub.space/posts/back/java/threadpool/threadlocal%E8%AF%A6%E8%A7%A3/","summary":"ThreadLocal详解 使用场景： 每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）\n每个Thread内有自己的实例副本，不共享 比喻：教材只有一本，一起做笔记有线程安全问题。复印后没有问题，ThreadLocal相当于生成了一个副本 重写initialValue方法\npackage treadlocal; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @Description: 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 * @Author: Rex * @Create: 2021-06-09 14:43 */ public class ThreadLocalNormalUsage05 { public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws InterruptedException { for (int i = 0; i \u0026lt; 1000; i++) { int finalI = i; executor.submit(new Thread(new Runnable() { @Override public void run() { String date = new ThreadLocalNormalUsage05().","title":"Threadlocal详解"},{"content":"关于ReentrantLock和Condition ReentrantLock是Java中一种常见的“锁”，锁是什么？ 并发编程的时候，比如说有一个业务是读写操作，那多个线程执行这个业务就会造成已经写入的数据又写一遍，就会造成数据错乱。\n所以需要引入锁，进行数据同步，强制使得该业务执行的时候只有一个线程在执行，从而保证不会插入多条重复数据。\n一些共享资源也是需要加锁，从而保证数据的一致性。\n使用Condition实现线程等待和唤醒 通常在开发并发程序的时候，会碰到需要停止正在执行业务A，来执行另一个业务B，当业务B执行完成后业务A继续执行。ReentrantLock通过Condtion等待/唤醒这样的机制。\n","permalink":"https://rexhub.space/posts/back/java/threadpool/%E5%85%B3%E4%BA%8Ereentrantlock%E5%92%8Ccondition/","summary":"关于ReentrantLock和Condition ReentrantLock是Java中一种常见的“锁”，锁是什么？ 并发编程的时候，比如说有一个业务是读写操作，那多个线程执行这个业务就会造成已经写入的数据又写一遍，就会造成数据错乱。\n所以需要引入锁，进行数据同步，强制使得该业务执行的时候只有一个线程在执行，从而保证不会插入多条重复数据。\n一些共享资源也是需要加锁，从而保证数据的一致性。\n使用Condition实现线程等待和唤醒 通常在开发并发程序的时候，会碰到需要停止正在执行业务A，来执行另一个业务B，当业务B执行完成后业务A继续执行。ReentrantLock通过Condtion等待/唤醒这样的机制。","title":"关于reentrantlock和condition"},{"content":"守护线程 两类线程： User Thread 用户线程 Daemon Thread 守护线程 分类标准是线程是否会阻止JVM的停止，只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部继续工作；只有当最后一个非守护线程结束时，所有守护线程才会随着JVM一同结束工作。（非守护线程等同于用户线程）\nJVM停止的情况 已调用System.exit()方法 所有非守护程序线程都已结束 而一般情况下我们不会调用System.exit()方法，所以大部分的Java程序的结束都是由于所有用户线程都结束而导致的。\n所以可以认为，任何一个守护线程都是整个JVM中所有用户线程（非守护线程）的管家。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它是一个很称职的守护者。\n守护线程的特性 线程类型默认继承自父线程 守护线程创建的线程为默认是守护线程，同样，用户线程创建的线程默认为用户线程。非守护线程如果想创建一个守护线程，需要调用Thread.setDaemon来设置它（Thread类用布尔值daemon属性来表示线程是否是守护线程），并且，该方法必须在start之前调用，否则会抛出 IllegalThreadStateException 异常。 被谁启动 通常由JVM启动，而不是由用户去启动。当JVM启动时，通常会有一个非守护线程（通常为执行main函数的线程）。\n不影响JVM退出 当只剩下守护线程时，JVM就会退出，因为如果只剩下守护线程，就没必要继续运行程序了。\n守护线程没结束并不会影响JVM的正常停止:假设所有用户线程都结束了，那么就算有5个守护线程正在运行，JVM也会正常停止：\n守护线程和普通线程的区别 虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护者”，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 这就是守护线程的作用：告诉JVM不需要等待它退出,当JVM中所有的线程都是守护线程的时候，JVM就可以正常的退出了。 我们是否需要给线程设置为守护线程？ 我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。\n","permalink":"https://rexhub.space/posts/back/java/threadpool/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/","summary":"守护线程 两类线程： User Thread 用户线程 Daemon Thread 守护线程 分类标准是线程是否会阻止JVM的停止，只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部继续工作；只有当最后一个非守护线程结束时，所有守护线程才会随着JVM一同结束工作。（非守护线程等同于用户线程）\nJVM停止的情况 已调用System.exit()方法 所有非守护程序线程都已结束 而一般情况下我们不会调用System.exit()方法，所以大部分的Java程序的结束都是由于所有用户线程都结束而导致的。\n所以可以认为，任何一个守护线程都是整个JVM中所有用户线程（非守护线程）的管家。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它是一个很称职的守护者。\n守护线程的特性 线程类型默认继承自父线程 守护线程创建的线程为默认是守护线程，同样，用户线程创建的线程默认为用户线程。非守护线程如果想创建一个守护线程，需要调用Thread.setDaemon来设置它（Thread类用布尔值daemon属性来表示线程是否是守护线程），并且，该方法必须在start之前调用，否则会抛出 IllegalThreadStateException 异常。 被谁启动 通常由JVM启动，而不是由用户去启动。当JVM启动时，通常会有一个非守护线程（通常为执行main函数的线程）。\n不影响JVM退出 当只剩下守护线程时，JVM就会退出，因为如果只剩下守护线程，就没必要继续运行程序了。\n守护线程没结束并不会影响JVM的正常停止:假设所有用户线程都结束了，那么就算有5个守护线程正在运行，JVM也会正常停止：\n守护线程和普通线程的区别 虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护者”，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 这就是守护线程的作用：告诉JVM不需要等待它退出,当JVM中所有的线程都是守护线程的时候，JVM就可以正常的退出了。 我们是否需要给线程设置为守护线程？ 我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。","title":"守护线程"},{"content":"线程池 线程池介绍 软件中的池可以理解为计划经济\n优点：\n复用线程 控制资源总量 好处：\n加快响应速度 合理利用CPU和内存 统一管理 适用场合\n服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理 创建和停止线程池 线程池构造方法的参数 参数名 类型 含义 corePoolSize int 核心线程数 maxPoolSize int 最大线程数 keepAliveTime long 保持存活时间 workQueue BlockingQueue 任务存储队列 threadFactory ThreadFactory 当线程池需要新的线程的时候，会使用threadFactory来生成新的线程 Handler RejectedExecutionHandler 由于线程池无法接受你所提交的任务的拒绝策略 添加线程规则 如果线程数小于corePoolSize，创建一个新线程来运行新任务。 如果线程数等于（或大于）corePoolSize但少于maxmumPoolSize，则将任务放入队列。 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程。 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝。 是否需要增加线程的判断顺序是：\ncorePoolSize workQueue maxPoolSize 增减线程的特点 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它 举例：\n线程池：核心池大小为5，最大池大小为10，队列为100 因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建最新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝 keepAliveTime\n如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，他们就会被终止 ThreadFactory\n默认使用Executors.defaultThreadFactory() 创建出来的都在同一个线程组 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 工作队列\n有3种最常见的队列类型：\n直接交接：SynchronousQueue\n适用于任务不多的情况，只作为中转\n内部没有容量，maxPoolSize需要设置的大一点\n无界队列：LinkedBlockingQueue\n可以防止浏览突增\n但是如果处理的速度跟不上任务提交的速度，队列里的东西会越来越多造成内存浪费或OOM(Out of Memory)异常\n不会被塞满，maxPoolSize无效\n有界队列：ArrayBlockingQueue\n可以设置maxPoolSize，控制队列容量\n自动创建（即直接调用JDK封装好的构造方法）VS自动创建 手动创建线程可以更加明确线程池的运行规则，避免资源耗尽的风险 自动创建：\nnewFixedThreadPool\n因为默认使用的是LinkedBlockingQueue，容易造成大量内存占用，可能会导致OOM错误\nnewSingleThreadExecutor\n当请求堆积的时候，可能会占用大量的内存\nnewCachedThreadPool\n可缓存线程池 特点：具有自动回收多余线程的功能 弊端在于第二个参数maxmumPoolSize被设置为了Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM newScheduledThreadPool\n支持定时及周期性执行任务 workStealingPool(jdk1.8)\n适合于有子任务的，如树的遍历 窃取(stealing) 正确的创建线程池的方法\n根据业务场景，设置线程池参数 比如：内存有多大，给线程取什么名字等等 线程数量的设置：\nCPU密集型（大量加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。\n耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍（如10倍）\n参考Brain Geoetz推荐的计算方法：\n线程数 = CPU核心数 × (1 + 平均等待时间/平均工作时间)\nor压测\nParameter FIXEDTHREADPOOL CACHEDTHREADPOLL sCHEDULEDtHREADPOOL SINGLETHREADED corePoolSize constructor-arg 0 constructor-arg 1 maxPoolSize same as corePoolSize Integer.MAX_VALUE Integer.MAX_VALUE 1 keepAliveTime 0 seconds 60 seconds 0 seconds 0 seconds 停止线程池的正确做法 shutdown：初始化整个关闭过程，并不会马上关闭 isShutdown：判断是否进入停止状态 isTerminated：判断线程是否已经终止 awaitTermination：判断在一段时间内线程是否完全停止 shutdownNow：暴力关闭 暂停和恢复线程池 拒绝任务 拒绝时机\n当Executor关闭时，提交新任务会被拒绝 以及当Executor对最大线程和工作队列容量使用有限边界且 已经饱和时 拒绝策略\nAbortPolicy\n抛出异常\nDiscardPolicy（Discard丢弃）\n默默丢弃任务，不知道任务是否被丢弃\nDiscardOledestPolicy\n丢弃最老的任务\nCallerRunsPolicy\n让调用者去执行任务\n钩子方法-给线程池加点料\n每个任务执行前后\n日志、统计\n示例代码：\npackage threadpool; import java.util.concurrent.*; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; /** * @Description: 描述每个任务执行前后放钩子函数 * @Author: Rex * @Create: 2021-06-08 14:22 */ public class PauseableThreadLocal extends ThreadPoolExecutor { private final ReentrantLock lock = new ReentrantLock(); private boolean isPaused; private Condition unpause = lock.newCondition(); public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); lock.lock(); try{ while(isPaused) { unpause.await(); } }catch (InterruptedException e){ e.printStackTrace(); }finally { lock.unlock(); } } private void pause(){ lock.lock(); try { isPaused = true; } finally { lock.unlock(); } } public void resume(){ lock.lock(); try { isPaused = false; unpause.signalAll(); } finally { lock.unlock(); } } public static void main(String[] args) throws InterruptedException { PauseableThreadLocal pauseableThreadLocal = new PauseableThreadLocal(10, 20, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue\u0026lt;\u0026gt;()); for (int i = 0; i \u0026lt; 10000; i++) { pauseableThreadLocal.execute(() -\u0026gt; { System.out.println(\u0026#34;我被执行\u0026#34;); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } }); } Thread.sleep(1500); pauseableThreadLocal.pause(); System.out.println(\u0026#34;线程池被暂停了\u0026#34;); Thread.sleep(1500); pauseableThreadLocal.resume(); System.out.println(\u0026#34;线程池被恢复了\u0026#34;); } } 线程池实现原理 线程池组成部分\n线程池管理器 工作线程 任务队列 任务接口（Task） Executor -\u0026gt; ExecutorService -\u0026gt; AbstractExecutorService -\u0026gt; ThreadPoolExecutor\n线程池实现任务复用\n相同线程执行不同任务 线程池状态 状态 含义 Running 接受新任务并处理排队任务 Shutdown 不接受新任务，但处理排队任务 Stop 不接受新任务，也不处理排队任务，并中断正在进行的任务 Tydying 所有任务都已终止，workCount为零时，线程会转换到Tidying状态，并将运行terminal()钩子方法 Terminated terminal()运行完成 使用线程池的注意点 避免任务堆积 避免线程数过渡增加 排查线程泄露 ","permalink":"https://rexhub.space/posts/back/java/threadpool/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","summary":"线程池 线程池介绍 软件中的池可以理解为计划经济\n优点：\n复用线程 控制资源总量 好处：\n加快响应速度 合理利用CPU和内存 统一管理 适用场合\n服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理 创建和停止线程池 线程池构造方法的参数 参数名 类型 含义 corePoolSize int 核心线程数 maxPoolSize int 最大线程数 keepAliveTime long 保持存活时间 workQueue BlockingQueue 任务存储队列 threadFactory ThreadFactory 当线程池需要新的线程的时候，会使用threadFactory来生成新的线程 Handler RejectedExecutionHandler 由于线程池无法接受你所提交的任务的拒绝策略 添加线程规则 如果线程数小于corePoolSize，创建一个新线程来运行新任务。 如果线程数等于（或大于）corePoolSize但少于maxmumPoolSize，则将任务放入队列。 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程。 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝。 是否需要增加线程的判断顺序是：\ncorePoolSize workQueue maxPoolSize 增减线程的特点 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它 举例：\n线程池：核心池大小为5，最大池大小为10，队列为100 因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建最新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝 keepAliveTime\n如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，他们就会被终止 ThreadFactory\n默认使用Executors.defaultThreadFactory() 创建出来的都在同一个线程组 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 工作队列\n有3种最常见的队列类型：\n直接交接：SynchronousQueue\n适用于任务不多的情况，只作为中转\n内部没有容量，maxPoolSize需要设置的大一点\n无界队列：LinkedBlockingQueue\n可以防止浏览突增\n但是如果处理的速度跟不上任务提交的速度，队列里的东西会越来越多造成内存浪费或OOM(Out of Memory)异常\n不会被塞满，maxPoolSize无效\n有界队列：ArrayBlockingQueue\n可以设置maxPoolSize，控制队列容量","title":"线程池"},{"content":"CSS CSS简介 层叠样式表(Cascading Style Sheets)的简称 美化HTML、布局网页 结构（HTML）-样式（CSS）分离 语法规范： ​\t选择器{属性:值}\nh1{color: red;} 语法风格 紧凑格式\nh3 {color:red} 展开格式(强推)\nh3 { color: pink; font-size:20px; } 选择器： CSS引入方式 内部样式表 行内样式表 外部样式表 CSS常用选择器 基础选择器 标签选择器 类选择器 id选择器 通配符选择器 复合选择器 后代选择器\n元素1 元素2 { 样式声明 }\n子选择器：只能选择作为某元素的最近一级 元素，\n元素1\u0026gt;元素2 { 样式声明 }\n并集选择器\n元素1,元素2 { 样式声明 }\n伪类选择器\n链接伪类选择器：必须按照lvha的顺序\na:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/ a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接*/ focus伪类选择器用于获取焦点的表单元素。\ninput:focus{ background-color: yellow; } CSS三大特性： 层叠性\n解决样式冲突问题\n样式冲突时遵循就近原则，哪个结构近，就执行哪个样式\n继承性\n子标签继承父标签的某些样式\n优先级\n选择器 选择器权重 继承或者* 0,0,0,0 元素选择器 0,0,0,1 类选择器，伪类选择器 0,0,1,0 ID选择器 0,1,0,0 行内样式style=\u0026quot;\u0026quot; 1,0,0,0 !important 重要的 ∞ 无穷大 选择性相同，则执行层叠性\n选择性不同，则根据选择器权重执行\ntip:复合选择器存在权重叠加的问题\nCSS显示模式： 分类 块级元素（div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等）\n独占一行 高度、宽度、外边距以及内边距都可以控制 宽度默认是容器的100% 是一个容器及盒子，里面可以放行内元素或者块级元素 注意：\n文字类的元素内不能使用块级元素 \u0026lt;p\u0026gt;标签主要用于存放文字，因此\u0026lt;p\u0026gt;不能放块级元素，特别是不能放\u0026lt;div\u0026gt; 同理\u0026lt;h1\u0026gt;~\u0026lt;h6\u0026gt;等都是文字类块级标签，里面也不能放其他块级元素 行内元素（span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block））\n相邻行内元素在一行上，一行可以显示多个 高、宽直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素 注意：\n链接里面不能再放链接 特殊情况链接\u0026lt;a\u0026gt;里面可以放块级元素，但是给\u0026lt;a\u0026gt;转换以下块级模式最安全 行内块元素（button、img、input、select、textarea、td）\n和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点） 默认宽度就是它本身内容的宽度（行内元素特点） 高度，行高，外边距以及内边距都可以控制（块级元素特点） 转换： 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块元素：display:inline-block CSS的背景： background-color:颜色值;\n设置背景颜色，默认为transparent(透明)\nbackground-image:none|url\n设置背景图片，默认为none\nbackground-repeat: repeat | no-repeat | repeat-x | repeat-y\n背景平铺，默认为repeat\nbackground-position:[length]or[position]\nposition:top | center | bottom | left | center | right\n背景图片的位置\nbackground-attachment:scroll | fixed\n背景图像固定(背景附着)\n背景复合写法\nbackground:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置（习惯约定）\n注意：rgba是CSS3新增属性，是IE9+版本浏览器才支持的\n盒子模型（Box Model）： 组成 border边框\n边框粗细 border-width 边框样式 border-style 边框颜色 border-color border: border-width || border-style || border-color\nborder-collapse属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。\ncontent内容\npadding内边距\n边框与内容之间的距离\n值的个数 表达意思 padding: 5px; 1个值，代表上下左右都有5像素内边距; padding: 5px 10px; 2个值，代表上下内边距是5像素，左右内边距是10像素; padding: 5px 10px 20px 3个值，代表上内边距5像素，左右内边距10像素 下内边距是20px; padding: 5px 10px 20px 30px; 4个值，上5像素 右10像素 下20像素 左30像素 margin外边距\n控制盒子和盒子之间的\t距离\nmargin简写类似padding\n外边距典型应用-块级盒子水平居中 ，条件\n盒子必须指定宽度 盒子左右的外边距都设置为auto tip:\n相邻元素垂直外边距的合并\n尽量只给一个盒子设置外边距\n嵌套块元素垂直外边距的塌陷\n为父元素定义上边框 为父元素定义内边距 为父元素添加overflow:hidden 行内元素为了照顾兼容性，尽量只设置内外边距，不要设置上下内外边距。但是转换为块级和行内元素就可以了\n浮动的盒子不会有外边距合并问题\n三种布局方式 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级横向排列找浮动\n网页布局第二准则：先设置盒子大小，之后设置盒子的位置\n普通流（普通流/文档流） ​\t标签按照规定好默认方式排列\n块级元素独占一行，从上向下排列\n行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行\n浮动 ​\t典型应用：可以让多个块级元素一行内排列显示。\n​\n属性值 描述 none 元素不浮动 left 元素向左浮动 right 元素向右浮动 浮动特性 脱标 脱离标准普通流的控制（浮）移动到指定位置（动）（脱标） 浮动的盒子不再保留原先的位置 如果多个盒子都设置了浮动，则它们会按照属性值一行显示并且顶端对齐排列 浮动元素具有行内块元素特性 注意点 浮动元素经常和标准流父级搭配使用 ​\t先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置.符合网页布局第一准则\n清除浮动 ​\t由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占位置，最后父级盒子高度为0时，会影响下面的标准流盒子。\n选择器{ clear:both } 清除浮动的策略是闭合浮动\n清除浮动的方法\n额外标签法也成为隔墙法，是W3C推荐的做法。\n优点：通俗易懂，书写方便\n缺点：添加许多无意义的标签，结构化较差\ntips：添加的元素必须是块级元素\n父级添加overflow属性\n优点：代码简洁\n缺点：无法显示溢出的部分\n父级添加after伪元素(比较常用)\n.clearfix::after { content: \u0026#34;\u0026#34;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7专有 */ *zoom: 1; } 优点：没有增加标签，结构更简单\n缺点：照顾低版本浏览器\n代表网站：百度、淘宝、网易等\n父级添加双伪元素\n.clearfix::after, .clearfix::before { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { clear: both; } .clearfix { /* IE6、7专有 */ *zoom: 1; } 优点：代码简洁\n缺点：照顾低版本浏览器\n代表网站：小米、腾讯等\n定位： 将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\n定位 = 定位模式 + 边偏移\n定位模式 值 语义 static 静态定位 relative 相对定位 absulte 绝对定位 fixed 固定定位 static：默认定位方式，无定位\n静态定位按照标准流特性摆放位置，它没有边偏移 静态定位在布局时很少用到 relative：相对定位是元素在移动的时候，是相对于它原来的位置来说的\n它是相当于自己原来的位置来移动的 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱标） absolute：绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的(拼爹型)\n如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准单位（Document文档） 如果祖先元素有定位（相对、绝对、固定定位），则以最近一级有定位祖先元素为参考点移动位置 绝对定位不再占有原来的位置（脱标） fixed：固定定位是元素固定于浏览器可视区的位置。可以在浏览器页面滚动时元素的位置不会改变\n以浏览器可视窗口为参照点移动元素 跟父元素无关 不随滚动条滚动 固定定位不在占有原先的位置 固定定位也是脱标的，其实固定定位也可以看作是一种特殊的绝对定位 sticky：粘性定位可以被认为是相对定位和固定定位的混合。IE不支持\n以浏览器的可视窗口为参照点移动元素（固定定位） 粘性定位占有原先的位置 必须添加top、left、right、bottom其中一个才有效 定位特殊特性： 行内添加绝对或者固定定位，可以直接设置高度和宽度。 浮动不会压住盒子的内容（浮动产生的目的最初就是为了做文字环绕效果的），而绝对定位会完全压住盒子 边偏移： ​\ttop、bottom、right、left\n定位叠放次序：z-index 数值可以是正整数、负整数或0，默认是auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 常见应用： 子绝父相：子级是绝对定位，父级是相对定位 固定定位技巧：固定在版心右侧位置： 让固定定位的盒子left:50%。走到浏览器可视区的一半位置。 让固定定位的盒子margin-left: 版心宽度的一半距离。多走版心宽度的一半位置 绝对定位的盒子居中（无法用margin:0 auto） left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。 margin-left: -100px; 让盒子向左移动宽度的一半 常见样式： 字体属性： font-family:\u0026#34;宋体\u0026#34;;/*常见的字体\u0026#39;Microsoft YaHei\u0026#39;,tahoma,arial,\u0026#39;Hiragino Sans GB\u0026#39;*/ font-size:20px;/*定义字体大小，标题标签需要单独设置*/ font-weight:700;/*不需要单位，提倡使用数字*/ font-style:normal/*文本风格,平时很少给文字加斜体，反而要给斜体改为不倾斜 font:font-style font-weight font-size/line-height font family/*字体复合属性*/ 文本属性： color: red;/*文本颜色：预定义的颜色值;进制表示;rgb和rgba*/ text-align:center;/*用于元素内文本内容的水平对其方式:left、right、center*/ text-decoration: underline;/*装饰文本：none、underline、overline、line-through*/ text-indent: ;/*指定文本的第一行的缩进，通常是将段落首行缩进, 一般用em，em是一个相对单位，就是当前元素1格文字的大小*/ line-height:;/*行间距*/ 圆角边框(CSS3) border-radius:length; /*设置元素外边框圆角。 radius-\u0026gt;半径原理：（椭）圆与边框的交集形成圆角效果。参数值可以是百分比，即宽的百分比和高的百分比*/ border-radisu:10px 20px 30px 40px; /*给四个角设置不同的圆角，顺时针*/ border-top-left-radius:10px /*给单独一个角设置圆角：border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius*/ 元素的显示与隐藏： display 显示隐藏\ndisplay隐藏元素后，不再占有原来的位置，常搭配js\nvisibility 显示隐藏\nvisibility隐藏元素后，继续占有原来的位置\noverflow 溢出隐藏\n如果有定位的盒子，请慎用overflow:hidden 因为它会隐藏多余的部分\n盒子阴影(CSS3) 值 描述 h-shadow 必须。水平阴影的位置。允许负值。 v-shadow 必须。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。 inset 可选。将外部阴影改为内部阴影。 ​\nbox-shadow: h-shadow v-shadow blur spread color insert; /*盒子阴影*/ 文字阴影(CSS3) text-shadow:h-shadow v-shadow blur color 值 描述 h-shadow 必须。水平阴影的位置。允许负值。 v-shadow 必须。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 color 可选。阴影的颜色。 CSS初始化 /* 把我们所有标签的内外边距清零 */ * { margin: 0; padding: 0; /* css3盒子模型 */ box-sizing: border-box } /* em 和 i 斜体的文字不倾斜 */ em, i { font-style: normal } /* 去掉li的小圆点 */ li { list-style: none } /* */ img { /* border 0照顾低版本浏览器 如果 图片外边包含了链接会有边框 的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle } button { /* 当鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer } a { color: #666; text-decoration: none } a:hover { color: #c81623 } button, input { /* \u0026#34;\\5B8B\\4F53\u0026#34;就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif } body { /* CSS3 抗锯齿性 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; color: #666 } .hide, .none { display: none } /* 清除浮动 */ .clearfix:after { visibility: hidden; clear: both; display: block; content: \u0026#34;.\u0026#34;; height: 0 } .clearfix { *zoom: 1 } 技巧 布局技巧 margin负值运用 让每个盒子margin往左移动-1px 正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高盒子的层级即可（如果没有定位，则加相对定位（保留位置），如果有定位，则加z-index） 文字围绕浮动元素 float属性 CSS三角的做法 等腰三角形\n.div { width: 0; height: 0; line-height: 0;/*考虑兼容性*/ font-size: 0;/*考虑兼容性*/ border: 50px solid transparent; border-top-color: pink; margin: 100px auto; } 三角强化-直角三角形\n.box1 { width: 0; height: 0; border-top: 100px solid transparent; border-right: 50px solid skyblue; border-bottom: 0 solid blue; border-left: 0 solid green; } .box1{ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2.样式都是solid */ border-style: solid; /* 3.上边框宽度要大，右边框稍小，其余的边框为0 */ border-width: 100px 50px 0 0; } 界面样式： 更改用户的鼠标样式\ncursor: pointer\n属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 表单轮廓和文本域拖拽\noutline: none 取消轮廓线\nresize: none （文本域）防止拖拽文本域\n精灵图(sprites)技术： 优点： 为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度 缺点： 图片文件还是比较大的。 图片本身放大缩小会失真 一旦图片制作完毕想要更换比较复杂 使用核心： 精灵图主要针对于背景图片使用。就是把多个小图片整合到一张大图片中 这个大图片也称为sprites精灵图或者雪碧图 主要借助于背景位置来实现\u0026mdash;background-position. 一般情况下精灵图都是负值。（千万注意网页中的坐标：x轴右边走是正值，左边是负值，y轴同理） 字体图标 优点： 轻量级：一个图标字体要比一系列的图像要小，一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意：字体图片不能代替精灵技术，只是对工作中图标部分技术的提升和优化。\n常用字体库： icomoon：http://icomoon.io 阿里iconfont： http://www.iconfont.cn vertical-align属性应用 ​\t用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效\nvertical: baseline | top | middle | bottom 解决图片底部默认空白缝隙问题 给图片添加vertical-align: middle|top|bottom等(提倡) 把图片转换为块级元素 display: block 溢出文本省略号表示 单行文本\ndiv { width: 150px; height: 80px; background-color: pink; margin: 100px auto; /* 如果文字显示不开自动换行 */ /* white-space: normal; */ /* 如果文字显示不开也必须一行内显示完 */ white-space: nowrap; /* 溢出的部分隐藏起来 */ overflow: hidden; /* 文字溢出的时候用省略号来显示 */ text-overflow: ellipsis; } 多行文本\n有较大兼容性问题，适合于webkit浏览器或移动端（移动端内核大部分是webkit）\ndiv { width: 150px; height: 80px; background-color: pink; margin: 100px auto; overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 4; /* 设置或间所伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical; } ","permalink":"https://rexhub.space/posts/front/css/","summary":"CSS CSS简介 层叠样式表(Cascading Style Sheets)的简称 美化HTML、布局网页 结构（HTML）-样式（CSS）分离 语法规范： ​\t选择器{属性:值}\nh1{color: red;} 语法风格 紧凑格式\nh3 {color:red} 展开格式(强推)\nh3 { color: pink; font-size:20px; } 选择器： CSS引入方式 内部样式表 行内样式表 外部样式表 CSS常用选择器 基础选择器 标签选择器 类选择器 id选择器 通配符选择器 复合选择器 后代选择器\n元素1 元素2 { 样式声明 }\n子选择器：只能选择作为某元素的最近一级 元素，\n元素1\u0026gt;元素2 { 样式声明 }\n并集选择器\n元素1,元素2 { 样式声明 }\n伪类选择器\n链接伪类选择器：必须按照lvha的顺序\na:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/ a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接*/ focus伪类选择器用于获取焦点的表单元素。\ninput:focus{ background-color: yellow; } CSS三大特性： 层叠性\n解决样式冲突问题","title":"CSS"},{"content":"网页开发 浏览器内核 浏览器 内核 备注 IE Trident IE、猎豹、360极速浏览器、百度浏览器 firefox Gecko 火狐浏览器内核 Safari Webkit 苹果浏览器内核 Chrome/Opera Blink Chrome/Opera浏览器内核。Blink其实是Webkit的分支 Web标准 目的： ​\t浏览器不同，他们显示页面或者排版不同\n构成： 结构 - HTML 表现 - CSS 行为 - JavaScript SEO优化 TDK三大标签 title\ntitle是搜索引擎了解网页入口和网页主题归属的最佳判断点\n建议：网站名（产品名）-网站的介绍（尽量不超过30个汉字）\ndescription\n简要说明我们网站主要是做什么的。\n我们提倡，description作为网站的总体业务和主题概况\nkeyword\nkeywords是页面关键字，是搜索引擎的关注点之一。\nkeywords最好限制为6~8个关键字，关键字之间用英文逗号隔开，采用关键词1，关键词2的形式\nLOGO SEO优化 logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要 h1里面再放一个链接，可以返回首页的，把logo的背景图片给链接即可。 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来 方法1：text-index移到盒子外面（text-indent:-9999px），然后overflow:hidden，淘宝的做法 方法2：直接给font-size:0;就看不到文字了，京东的做法。 最后给链接一个title属性，这样鼠标放到logo上就可以看到提示文字了 HTML标签 声明部分 文档类型声明标签 ​\t\u0026lt;!DOCTYPE\u0026gt;文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页\n\u0026lt;!DOCTYPE html\u0026gt;指当前页面采用HTML5版本来显示网页\nlang语言种类 en定义语言为中文 zh-CN定义语言为中文 这个对于网页的编码没有什么影响，主要针对浏览器和搜索引擎\n字符集 ​\t\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;在\u0026lt;head\u0026gt;标签内，用于指定HTML文档的编码方式\ncharset常用的值有：GB2312，BIG5，GBK和UTF-8，其中UTF-8为万国码，包含了各个国家的字符\n图标： \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;./images/favicon.ico\u0026#34;\u0026gt; 常用标签 标题标签：\u0026lt;h1\u0026gt; - \u0026lt;h6\u0026gt; h -\u0026gt; head的缩写 作为标题使用，并且依据重要性递减 段落：\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; p -\u0026gt; paragraph\n可以把HTML文档分割为若干段落\n特点\n文本在一个段落中会根据浏览器窗口的大小自动换行 段落和段落之间保有空隙。 换行标签：\u0026lt;br /\u0026gt; br -\u0026gt; break 强制换行 特点 单标签。 \u0026lt;br /\u0026gt;标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距 文本格式化标签 语义 标签 说明 加粗 或者 更推荐使用标签加粗 语义更强烈 倾斜 或者 更推荐使用标签加粗 语义更强烈 删除线 或者 更推荐使用标签加粗 语义更强烈 下划线 或者 更推荐使用标签加粗 语义更强烈 div和span标签：\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;、\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; div -\u0026gt; division 分割、分区；span 跨度、跨距 特点： \u0026lt;div\u0026gt;标签用来布局，但是现在一行只能放一个\u0026lt;div\u0026gt;。大盒子 \u0026lt;span\u0026gt;标签用来布局，一行可以多个\u0026lt;span\u0026gt;。小盒子 图像标签：\u0026lt;img src=\u0026quot;图像URL\u0026quot;\u0026gt; img -\u0026gt; image 图像\n图像标签属性\n属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本。图像不能显示的文字 title 文本 提示文本。鼠标放到图像上，显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 超链接标签/锚点链接：\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; a -\u0026gt; anchor 锚\n属性\n属性 作用 href 用于指定连接目标的url地址，为href属性时，他就具有了超链接的功能 target 用于指定链接页面的打开方式，其中_self为默认值，__blank为在新窗口中打开 注释和特殊字符 注释标签：\u0026lt;!-- --\u0026gt; 特殊字符 特殊字符 描述 字符的代码 空格符 \u0026amp;nbsp; \u0026lt; 小于号 \u0026amp;lt; \u0026gt; 大于号 \u0026amp;gt; \u0026amp; 和号 \u0026amp;amp; ￥ 人民币 \u0026amp;yen; © 版权 \u0026amp;copy; ® 注册商标 \u0026amp;reg; ° 摄氏度 \u0026amp;deg; ± 正负号 \u0026amp;plusmn; × 乘号 \u0026amp;times; ÷ 除号 \u0026amp;divide; ² 平方2(上标2) \u0026amp;sup2; ³ 立方3(上标3) \u0026amp;sup3; 表格标签 \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;用于定义表格的标签\n\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;用于定义表格中的行，必须嵌套在\u0026lt;table\u0026gt;\u0026lt;table\u0026gt;标签中.\ntable row\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;用于定义表格中的单元格，必须嵌套在\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;标签中.\n字母td指表格(table data)，即数据单元格的内容。\n\u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;表头单元格\ntable head\n表格属性 属性名 属性值 描述 align left、center、right 规定表格相对周围元素的对齐方式 border 1或\u0026quot;\u0026quot; 规定表格单元格是否拥有边框，默认为\u0026quot;\u0026quot;，表示没有边框 cellpadding 像素值 规定单元边沿与其内容之间的空白，默认像素为1 cellspacing 像素值 规定单元格之间的空白，默认2像素 width 像素值 规定表格的宽度 表格结构标签 \u0026lt;thead\u0026gt;\u0026lt;/thead\u0026gt;表格的头部区域\n\u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt;表格的主体区域\n合并单元格 跨行合并：rowspan=\u0026ldquo;合并单元格的个数\u0026rdquo; 跨列合并：colspan=\u0026ldquo;合并单元格的个数\u0026rdquo; 列表标签：用来布局 特点：整齐、整洁、有序 无序列表：\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\n有序列表：\u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\n自定义列表：\u0026lt;dl\u0026gt;\u0026lt;/dl\u0026gt;、\u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt;、\u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt;\n表单 定义表单域：\u0026lt;form\u0026gt;\n常用属性：\n属性 属性值 作用 action url地址 用于指定接受并处理表单数据的服务器程序的url地址 method get、post\u0026hellip; 用于设置表单数据的提交方式，其取值为get或post等等 name 名称 用于指定表单的名称，以区分同一个页面的多个表单域 表单控件\ninput输入表单元素\ntype属性\n属性值 描述 button 定义可点击按钮（多数情况下，用于通过JavaScript启动脚本）。 checkbox 定义复选框 file 定义输入字段和浏览按钮，供文件上传 hidden 定义隐藏的输入字段 image 定义图像形式的提交按钮。 password 定义密码字段。该字段中的字符被掩码。 radio 定义单选按钮。 reset 定义重置按钮。重置按钮会清除表单中的所有数据 submit 定义提交按钮。提交按钮会把表单数据发送到服务器 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。 其他属性\n属性 属性值 描述 name 由用户自定义 定义input元素的名称 value 由用户自定义 规定input元素的值 checked checked 规定此input元素首次加载时应当被选中。 maxlength 正整数 规定输入字段中的字符的最大长度 label标签用于绑定表单元素\nselect下拉表单元素\ntextarea文本域元素\n表单信息\n","permalink":"https://rexhub.space/posts/front/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","summary":"网页开发 浏览器内核 浏览器 内核 备注 IE Trident IE、猎豹、360极速浏览器、百度浏览器 firefox Gecko 火狐浏览器内核 Safari Webkit 苹果浏览器内核 Chrome/Opera Blink Chrome/Opera浏览器内核。Blink其实是Webkit的分支 Web标准 目的： ​\t浏览器不同，他们显示页面或者排版不同\n构成： 结构 - HTML 表现 - CSS 行为 - JavaScript SEO优化 TDK三大标签 title\ntitle是搜索引擎了解网页入口和网页主题归属的最佳判断点\n建议：网站名（产品名）-网站的介绍（尽量不超过30个汉字）\ndescription\n简要说明我们网站主要是做什么的。\n我们提倡，description作为网站的总体业务和主题概况\nkeyword\nkeywords是页面关键字，是搜索引擎的关注点之一。\nkeywords最好限制为6~8个关键字，关键字之间用英文逗号隔开，采用关键词1，关键词2的形式\nLOGO SEO优化 logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要 h1里面再放一个链接，可以返回首页的，把logo的背景图片给链接即可。 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来 方法1：text-index移到盒子外面（text-indent:-9999px），然后overflow:hidden，淘宝的做法 方法2：直接给font-size:0;就看不到文字了，京东的做法。 最后给链接一个title属性，这样鼠标放到logo上就可以看到提示文字了 HTML标签 声明部分 文档类型声明标签 ​\t\u0026lt;!DOCTYPE\u0026gt;文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页\n\u0026lt;!DOCTYPE html\u0026gt;指当前页面采用HTML5版本来显示网页\nlang语言种类 en定义语言为中文 zh-CN定义语言为中文 这个对于网页的编码没有什么影响，主要针对浏览器和搜索引擎\n字符集 ​\t\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;在\u0026lt;head\u0026gt;标签内，用于指定HTML文档的编码方式\ncharset常用的值有：GB2312，BIG5，GBK和UTF-8，其中UTF-8为万国码，包含了各个国家的字符\n图标： \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;.","title":"网页开发"},{"content":"HTML5 TIP: 存在兼容性问题，基本上IE+9以上版本的浏览器才支持\n语义化标签 \u0026lt;head\u0026gt;: 头部标签 \u0026lt;nav\u0026gt;: 导航标签 \u0026lt;artivle\u0026gt;: 内容标签 \u0026lt;section\u0026gt;: 定义文档某个区域 \u0026lt;aside\u0026gt;: 侧边栏标签 \u0026lt;footer\u0026gt;: 尾部标签 注意：\n这种语义化标准主要是针对搜索引擎的 这些新标签页面可以使用多次 在IE9中，需要把这些元素转换为块级元素 移动端更喜欢使用这些标签 多媒体标签 \u0026lt;vedio\u0026gt;\n浏览器 MP4 Webm ogg Internet Explore Yes No No Chrome Yes Yes Yes Firefox Yes\n从Firefox21版本开始\nLinux系统从Firefox30开始 Yes Yes Safari Yes No No Opera Yes Yes Yes 语法：\n\u0026lt;video src=\u0026quot;文件地址\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/video\u0026gt;\n属性：\n属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 规定视频的音频输出应该被静音。 poster URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。 preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 \u0026ldquo;autoplay\u0026rdquo;，则忽略该属性。 src url 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。 \u0026lt;audeo\u0026gt;\n浏览器 MP3 wav ogg Internet Explore Yes No No Chrome Yes Yes Yes Firefox Yes Yes Yes Safari Yes YES No Opera Yes Yes Yes 语法：\n\u0026lt;audio src=\u0026quot;文件地址\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt;\n属性\n属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新开始播放。 muted muted 规定视频输出应该被静音。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 \u0026ldquo;autoplay\u0026rdquo;，则忽略该属性。 src url 要播放的音频的 URL。 多媒体标签总结\n音频和视频使用方式基本一致 浏览器支持情况不同 谷歌浏览器把音频和视频自动播放了 我们可以给视频标签添加muted属性来静音播放视频，音频不可以（可以通过JavaScript解决） 视频标签是重点，我们经常设置自动播放，不适用controls控件，循环和设置大小属性 input类型 属性值 说明 type=\u0026ldquo;email\u0026rdquo; 限制用户输入必须为Email类型 type=\u0026ldquo;url\u0026rdquo; 限制用户输入必须为URL类型 type=\u0026ldquo;date\u0026rdquo; 限制用户输入必须为日期类型 type=\u0026ldquo;time\u0026rdquo; 限制用户输入必须为时间类型 type=\u0026ldquo;month\u0026rdquo; 限制用户输入必须为月类型 type=\u0026ldquo;week\u0026rdquo; 限制用户输入必须为周类型 type=\u0026ldquo;number\u0026rdquo; 限制用户输入必须为数字类型 type=\u0026ldquo;tel\u0026rdquo; 手机号 type=\u0026ldquo;search\u0026rdquo; 搜索框 type=\u0026ldquo;color\u0026rdquo; 生成一个颜色选择表单 新增的表单属性 属性 值 说明 required required 表单拥有该属性表示其内容不能为空，必填 placeholder 提示文本 表单的提示信息，存在默认值将不显示 autofocus autofocus 自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplate off/on 当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。\n默认已经打开，如autocomplete=\u0026ldquo;on\u0026rdquo;, 关闭autocomplete=\u0026ldquo;off\u0026quot;需要放在表单内，同时加上name属性，同时成提交 multiple mltiple 可以多选文件提交 ","permalink":"https://rexhub.space/posts/front/html5/","summary":"HTML5 TIP: 存在兼容性问题，基本上IE+9以上版本的浏览器才支持\n语义化标签 \u0026lt;head\u0026gt;: 头部标签 \u0026lt;nav\u0026gt;: 导航标签 \u0026lt;artivle\u0026gt;: 内容标签 \u0026lt;section\u0026gt;: 定义文档某个区域 \u0026lt;aside\u0026gt;: 侧边栏标签 \u0026lt;footer\u0026gt;: 尾部标签 注意：\n这种语义化标准主要是针对搜索引擎的 这些新标签页面可以使用多次 在IE9中，需要把这些元素转换为块级元素 移动端更喜欢使用这些标签 多媒体标签 \u0026lt;vedio\u0026gt;\n浏览器 MP4 Webm ogg Internet Explore Yes No No Chrome Yes Yes Yes Firefox Yes\n从Firefox21版本开始\nLinux系统从Firefox30开始 Yes Yes Safari Yes No No Opera Yes Yes Yes 语法：\n\u0026lt;video src=\u0026quot;文件地址\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/video\u0026gt;\n属性：\n属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 规定视频的音频输出应该被静音。 poster URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。 preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 \u0026ldquo;autoplay\u0026rdquo;，则忽略该属性。 src url 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。 \u0026lt;audeo\u0026gt;","title":"HTML5"},{"content":"Vue进阶 Vue路由 1.初始路由 **路由**：表示一种对应关系，某些事物的一一对应的关系 **后端路由**：后端路由是由服务器端进行实现，并完成资源的分发（url与资源/数据的对应关系） **前端路由**：前端路由是依靠hash值（锚点链接）的变化进行实现页面内容的切换（锚点与组件之间的关系） 2.vue-router vue-router工作原理\n它是一个Vue.js官方提供的路由管理器，是一个功能更加强大的前端路由器，可以实现前端界面内容切换\nSPA：Single Page Application，单页面应用，整个网站只有一个页面\nSPA推荐使用vue-router，实现界面内容的切换\nvue-router提供两种模式\nhash模式：hash又叫锚点：比如#/login，根据hash改变，来实现界面切换\nhistory模式：history模式不会出现#号比较美观，利用history.pushState()来完成URL的跳转而且无须重写加载页面\n示例代码\nconst router = new VueRouter({ mode: \u0026#39;history\u0026#39;, router: [...] }) vue-router默认为hash模式，需要通过mode来改变模式\nvue-router基本使用\n引入vue-router.js\n定义路由链接和路由视图\n代码示例：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34; tag=\u0026#34;span\u0026#34;\u0026gt;前往登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; router-link是路由链接，to代表链接地址，tag代表渲染的标签\nrouter-view是路由视图，用于显示路由链接对应的组件\n定义路由匹配规则\n代码示例\nvar login = { template: \u0026#34;\u0026lt;h1\u0026gt;登录组件\u0026lt;/h1\u0026gt;\u0026#34; } const router = new VueRouter({ routes: [ { path: \u0026#39;/login\u0026#39;, component: login } ] }); 在实例化VueRouter的时候传入routes\n通过routes定义路由匹配规则，可以定义多个\n匹配规则是一个对象，key是路由链接path，value是组件component\n注册路由\n代码示例\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, router: router }); 在实例化Vue的时候，通过选项router来注册路由\n路由对象属性\nthis.$router表示全局路由器对象，就是通过router选项注册的VueRouter路由管理器对象\nthis.$route代表当前路由对象，而已获取当前路由相关信息\n路由对象属性\n属性名 类型 说明 $route.path String 对应当前路由的路径 $route.query Object 一个{key:value}对象，表示URL查询参数 $route.params Object 一个{key:value}对象，路由跳转携带参数 $route.hash String 在history模式下获取当前路由hash值（带#），如果没有hash值，则为空字符串 $route.fullPath String 完成解析后的URL，包含查询参数和hash的完整路径 $route.name String 当前路由的名称 $route.matched Array 路由记录，当前路由下路由声明的所有信息，从父路由（如果有）到当前路由为止 $route.redirectedFrom String 如果存在重定向，即为重定向来源的路由 3.用户登录注册案例 4.动态路由 什么是动态路由\n可以匹配带有不同参数的url的路由规则就是动态路由\nquery方式传参\n通过？传参\n传参\n示例\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user?id=1\u0026amp;name=Rex\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; id: {{this.$route.query.id}} name: {{this.$route.query.name}} \u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 传参语法：?参数名1=参数值1\u0026amp;参数名2=参数值2\n定义路由\nconst router = new VueRouter({ routes: [{ path: \u0026#39;/user\u0026#39;, component: user }] }) 获取参数\n{{this.$route.query.参数名}}\nparams方式传参\n通过url本身传递\n传参\n示例代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user/10/admin\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; id:{{this.$route.params.id}} name:{{this.$route.params.name}} \u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 传参语法：/参数值1/参数值2，这里只需要传递值即可\n定义动态路由\n实例代码\nconst router = new VueRouter({ routes: [ { path: \u0026#34;/user/:id/:name\u0026#34;, component: user } ] }) 动态路由语法，:参数名，以冒号开头就代表动态匹配\n:id就会匹配10，:name就会匹配admin\n获取参数\n{{$route.params.参数名}}\n5. 嵌套路由 什么是嵌套路由\n界面中如果存在嵌套组件,那么就需要组件对应的路由也是嵌套路由\n定义嵌套路由:\n通过在路由对象中定义children属性,定义嵌套的子路由\n示例代码\nvar router = new VueRouter({ routes:[{ path: \u0026#39;/home\u0026#39;, component: home, children:[ {path: \u0026#39;login\u0026#39;, component: login}, {path: \u0026#39;register\u0026#39;, component: register} ] }] }) 使用嵌套路由\n示例代码:\n\u0026lt;router-link to=\u0026#34;/父路由的地址/要去的子路由\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; 子路由的url是:父path/子path\n6. 命名路由 如果路由的path比较长,使用的时候比较麻烦,这时候可以给路由起个名字,用的时候通过名字使用\n定义命名路由\n示例代码\n​\nconst router = new VueRouter({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: user } ] }) 在定义路由对象时,通过name来给路由起名字\n使用命名路由\n示例代码\n\u0026lt;router-link :to=\u0026#34;{name:\u0026#39;user\u0026#39;, params: {id:123}}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; 使用属性绑定,是因为to的值是一个js对象\n7. 命名视图 给视图起名字,就是命名视图\n在开发中想同时显示多个同级视图,这时候就需要使用命名视图\n定义命名视图\n示例代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view name=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 通过name属性给router-view添加名字\n路由规则使用命名视图\n示例代码\nvar header = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;header\u0026#34;\u0026gt;header头部区域\u0026lt;/h1\u0026gt;\u0026#39; } var sidebar = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;sidebar\u0026#34;\u0026gt;sidebar测导航区域\u0026lt;/h1\u0026gt;\u0026#39; } var mainbox = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;main\u0026#34;\u0026gt;mainBox主题区域\u0026lt;/h1\u0026gt;\u0026#39; } 路由对象中通过components来使用多个视图\n8. 编程式导航 router.push()\npush:推,push方法可以实现url跳转\n语法:\n//先获取router实例 var router = new VueRouter() //字符串形式 router.push(\u0026#39;user\u0026#39;) //对象形式 router.push({path:\u0026#39;/login?url=\u0026#39;+this.$route.path}) //命名路由 router.push({name:\u0026#39;user\u0026#39;, params:{userId:123}}) //带查询参数/user?id=1 route.push({path:\u0026#39;user\u0026#39;,queyr:{id:\u0026#39;1\u0026#39;}}) push可以传递一个字符串路径,也可以是对象\n对象中可以是路径path,也可以是路由的名字\n注意\n在参数对象中,如果提供了path,params会被忽略,为了传参数,需要提供路由的name或者手写带有参数的路径\nconst userId = \u0026#39;123\u0026#39; router.push({name:\u0026#39;user\u0026#39;, params:{userId}}) // /user/123 router.push({path:\u0026#39;/user/${userId}\u0026#39;})\t// /user/123 //这里的params不生效 router.push({path:\u0026#39;/user\u0026#39;, params:{userId}})// /user router.replace()\nreplace:替换,可以替换当前界面的url\n语法\n//编程式 router.replace({path:\u0026#39;user\u0026#39;}) //声明式 \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;user\u0026#39;} replace\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; 与push的区别:push有history记录,replace没有\nrouter.go()\ngo:去,可以实现前进后退 go()方法,接受正数或负数,表示前进或后退 后退一个界面:$router.go(-1) 前进一个界面:$router.go(1) Vuex状态管理 初始Vuex Vuex是一套组件状态（数据）管理维护工具\n使得Vue组件的状态更加容易维护\n创建Vuex的store示例\nconst store = new Vuex.Store({ state:{}, mutations:{} }) 使用Vuex就是使用store来对状态进行管理\nVuex通过store(存储来存储数据)，并且管理数据\nVuex的下载和安装 script引入文件\n下载Vuex\n引入\n\u0026lt;script src=\u0026#34;../js/vuex.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使用\n创建store\nconst store = new Vuex.Store({ state: { name: \u0026#39;vuex.js直接引用\u0026#39; } }) 实例化Store的时候，可以传入state选项\nstate选项：状态选项，数据选项，用于定义要存储的数据\n挂载store\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store }) 使用state数据\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{this.$store.state.name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 获取state数据是一层一层的获取的\nthis中有store选项，所以：this.$store\nstore中有state，所以this.$store.state\nstate中有name，所以this.$store.state.name\n使用计算属性\n上边的方式，使用state数据，太麻烦了，每次都要this.$store.state.name\n我们可以在计算属性中将state数据返回，相当于将state数据变为计算属性，这样在使用的时候就简单很多\n定义计算属性\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, computed: { name() { return this.$store.state.name; } } }) 使用\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; mapState辅助函数\n当一个组件需要获取多个状态时，将这些状态都声明为计算属性有些麻烦，这时候可以使用mapState辅助函数来生成计算属性\n使用mapState\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, computed: Vuex.mapState({ //key:计算属性的名字 //value:函数，将state数据返回 name: state =\u0026gt; state.name }) }) mapState是Vuex提供的一个方法 mapState，是状态映射，理解为将state数据映射（转换）为计算属性 mapState接受一个对象，对象中可以映射多个数据 对象中的key是计算属性的名字，value是一个箭头函数，箭头函数有一个state参数然后直接将state的数据返回即可 使用数据\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; npm安装\n需要船舰出来一个项目才可以导入npm安装的包\n创建项目需要脚手架vue-cli npm install vue-cli \u0026ndash;save 创建webpack模板的vue项目\nvue init webpack demo02 cd demo02 安装vuex\nnpm install vuex@3.1.1 \u0026ndash;save 定义store的数据\n创建store\\index.js文件，用来导出store实例\nimport Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;Vuex\u0026#39; Vue.use(Vuex) export default new Vuex.Store({ state: {name: \u0026#39;正在使用Vuex\u0026#39;} }) 通过import导入npm安装的包\n通过Vue.use安装Vuex\nexport default将store导出，其他组件都可以使用\n导入store\n修改src\\main.js文件导入相关文件\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false 导入Vue，并且配置productionTip为false 导入根组件App 导入路由router 导入数据store 注册store\n修改src\\main.js文件，在Vue实例中注册store\n/*eslint-disable no new*/ new Vue({ el:\u0026#39;#app\u0026#39;, router, components:{App}, template:\u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, store }) eslint-disable no-new：是关闭eslint语法校验 components:{App}:注册组件App template: '\u0026lt;App/\u0026gt;'使用组件App，App.vue中的#app的div el: \u0026lsquo;#app\u0026rsquo;, 这个是index.html中的div 修改App.vue\n映射state数据\n\u0026lt;script\u0026gt; import { mapState } from \u0026#34;vuex\u0026#34;; export default { name: \u0026#34;App\u0026#34;, computed: mapState({ name: (state) =\u0026gt; state.name, }), }; \u0026lt;/script\u0026gt; 使用数据\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ name }}\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 运行项目 npm run dev\nVuex状态管理模式 单项数据流机制：在Vue中，组件的状态变化是通过Vue单向数据流的设计理念实现的。\n单项数据流组成部分主要包括\nState：驱动应用的数据源 View：以声明方式将state映射到视图 Actions：响应在View上的用户输入导致状态变化 代码:\nnew Vue({ //State data(){ return {count: 0} }, //View template: \u0026#39;\u0026lt;div\u0026gt;{{ count }}\u0026lt;/div\u0026gt;\u0026#39;, //Actions methods:{ increment(){ this.count++; } } }) Vuex的工作流程关系 actions、mutations和state的关系\nState数据render渲染到vue组件 用户在Vue组件中点击按钮，触发逻辑Actions Actions中通过commit触发修改数据逻辑Mutations Mutations修改的state，重新渲染到Vue组件 Vuex配置选项 1.mutations mutations是一个对象，可以定义多个方法\nmutations方法用来操作state数据（翻译：变化，理解为数据变化）\nmutations方法接受state对象作为参数\n在组件中通过store.commit(\u0026ldquo;mutations方法名\u0026rdquo;)来触发mutations方法执行\n代码：\nconst store = new Vuex.Store({ state: { param: \u0026#34;\u0026#34; }, mutations: { reciver(state, param) { this.state.param = param; console.log(param); } } }) new Vue({ el: \u0026#34;#app\u0026#34;, store: store, methods: { param() { this.$store.commit({ type: \u0026#34;reciver\u0026#34;, name: \u0026#34;我是传递的数据\u0026#34; }) } }, }) 2.actions actions类似于mutations，不同之处在于actions是异步执行的（翻译：动作，理解为执行异步动作）\nactions函数接受store对象，用于完成mutations提交\nstore的dispatch方法触发actions函数\n代码\nconst store = new Vuex.Store({ state: { count: 0 }, //mutations：专门用来修改state的数据 mutations: { increment(state) { state.count++; } }, actions: { add(context) { setTimeout(() =\u0026gt; { context.commit(\u0026#34;increment\u0026#34;) }, 1000); } } }) context即为store实例\n简写\nactions:{ add({commit}){ commit(\u0026#34;increment\u0026#34;)\t}\t} var vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, methods: { calc() { this.$store.dispatch(\u0026#34;add\u0026#34;); } }, }); store的dispatch方法，用于触发actions方法\n3.getters getters，类似于Vue实例的computed计算属性（翻译：获取者，获取计算之后的数据）\n定义\nconst store = new Vuex.Store({ state: { todos: [{ id: 1, text: \u0026#39;列表1\u0026#39; }, { id: 2, text: \u0026#39;列表2\u0026#39; }], id: 0 }, mutations: { searchM(state, id) { state.id = id; } }, getters: { searchG: state =\u0026gt; { return state.todos.filter( todo =\u0026gt; (todo.id == state.id) ) } } }) getters是计算属性，计算属性其实是方法，只不过使用的时候是属性\n使用\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;列表查询\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;search\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;搜索结果：{{this.$store.getters.searchG}}\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in this.$store.state.todos\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 4.modules modules模块就是为了应对复杂的业务逻辑，将数据与操作数据的逻辑分模块处理\nmodules的配置选项：\n与store数据参考中的参数是相同的\nkey:{\t//key表示模块名称 state,\t//初始数据 mutations,\t//状态提交，同步 actions,\t//状态分发，异步 getters,\t//计算属性 modules\t//模块 } 代码\nconst moduleA = { state: { nameA: \u0026#39;A\u0026#39; } } const moduleB = { state: { nameB: \u0026#39;B\u0026#39; } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }); console.log(store.state.a); console.log(store.state.b); 5.plugins 用于给Vuex添加插件，插件本身为函数\n函数接受参数store对象作为参数\n代码\nconst myPlugin = store =\u0026gt; { store.subscribe((mutation, state) =\u0026gt; { // 每次mutation提交后调用，mutation格式{type, paylooad} console.log(mutation.type, mutation.payload); }) } const store = new Vuex.Store({ mutations: { do(state) { console.log(state); } }, plugins: [myPlugin] }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, }); store.commit(\u0026#39;do\u0026#39;, \u0026#39;plugin\u0026#39;) 插件函数中通过store实例对象的subscribe函数可以用来处理mutation\nsubscribe函数接受参数为mutation和state\n作用：一般在项目中我们会使用plugin初始化一些数据\n6.devtools 用来设置是否在devtools调试工具中应用Vuex 默认值为true，表示在启用，设为false表示停止使用 Vuex中的API 模块注册 store.registerModule()用于动态创建模块的接口\n与modules选项作用类似，但是registerModule()更加灵活\n代码\nconst store = new Vuex.Store({ state: {}, }); store.registerModule(\u0026#39;myModule\u0026#39;, { state: { name: \u0026#34;我是注册模块的数据\u0026#34; } }) modules选项只能在实例化store的时候，注册模块\nregisterMudule()方法只要是能够获取到store对象的地方都可以注册\n状态替换 store.replaceState()方法用于实现状态替换\n该方法接受新的state对象\n代码\nconst store = new Vuex.Store({ state: { name: \u0026#39;我是初始值数据\u0026#39; } }); store.replaceState({ name: \u0026#34;替换后的新数据\u0026#34; }) var vm = new Vue({ el: \u0026#34;#app\u0026#34;, store, }) \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{this.$store.state.name}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://rexhub.space/posts/front/vue/vue%E8%BF%9B%E9%98%B6/","summary":"Vue进阶 Vue路由 1.初始路由 **路由**：表示一种对应关系，某些事物的一一对应的关系 **后端路由**：后端路由是由服务器端进行实现，并完成资源的分发（url与资源/数据的对应关系） **前端路由**：前端路由是依靠hash值（锚点链接）的变化进行实现页面内容的切换（锚点与组件之间的关系） 2.vue-router vue-router工作原理\n它是一个Vue.js官方提供的路由管理器，是一个功能更加强大的前端路由器，可以实现前端界面内容切换\nSPA：Single Page Application，单页面应用，整个网站只有一个页面\nSPA推荐使用vue-router，实现界面内容的切换\nvue-router提供两种模式\nhash模式：hash又叫锚点：比如#/login，根据hash改变，来实现界面切换\nhistory模式：history模式不会出现#号比较美观，利用history.pushState()来完成URL的跳转而且无须重写加载页面\n示例代码\nconst router = new VueRouter({ mode: \u0026#39;history\u0026#39;, router: [...] }) vue-router默认为hash模式，需要通过mode来改变模式\nvue-router基本使用\n引入vue-router.js\n定义路由链接和路由视图\n代码示例：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34; tag=\u0026#34;span\u0026#34;\u0026gt;前往登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; router-link是路由链接，to代表链接地址，tag代表渲染的标签\nrouter-view是路由视图，用于显示路由链接对应的组件\n定义路由匹配规则\n代码示例\nvar login = { template: \u0026#34;\u0026lt;h1\u0026gt;登录组件\u0026lt;/h1\u0026gt;\u0026#34; } const router = new VueRouter({ routes: [ { path: \u0026#39;/login\u0026#39;, component: login } ] }); 在实例化VueRouter的时候传入routes\n通过routes定义路由匹配规则，可以定义多个\n匹配规则是一个对象，key是路由链接path，value是组件component\n注册路由\n代码示例","title":"Vue进阶"},{"content":"JPA 一、什么是jpa ​\tJPA是Java Persistence API的意思，是一种ORM框架。是使用JDK 5.0注解或XML描述对象－关系表的映射关系的元数据，并将运行期的面向对象语言程序中的实体对象持久化到数据库中。\n二、基于注解的使用 JPA常用注解 注解 解释 @Entity 声明类为实体或表。 @Table 声明表名。 @Basic 指明非约束明确的各个字段。 @Embedded 指定类或它的值是一个可嵌入的类的实体的属性。 @Id 指定的类的属性，用于识别（一个表中的主键）。 @GeneratedValue 指定如何标识属性可以被初始化，例如自动、手动、或从序列表中获得的值。 @Transient 指定的属性，它是不持久的，即：该值永远不会存储再数据库中。 @Column 指定持久属性栏属性。 @SequenceGenerator 指定在@GeneratedValue注解中指定的属性的值。它创建了一个序列。 @TableGenerator 指定在@GeneratedValue批注指定属性的值发生器。它创造了的值生成的表。 @AccessType 这种类型的注释用于设置访问类型。如果设置@AccessType(FIELD)，则可以直接访问变量并且不需要getter和setter，但必须为public。如果设置@AccessType(PROPERTY)，通过getter和setter方法访问Entity的变量。 @JoinColumn 指定一个实体组织或实体的集合。这是用在多对一和一对多关联。 @UniqueConstraint 指定的字段和用于主要或辅助表的唯一约束。 @ColumnResult 参考使用select字句的SQL查询中的列明。 @ManyToMany 定义了连接表之间的多对多的的关系 @ManyToOne 定义了连接表之间的多对一的关系 @OneToMany 定义了连接表之间存在一个一对多的关系。 @OneToOne 定义了连接表之间有一个一对一的关系 @NamedQueries 指定命名查询的列表 @NamedQuery 指定使用静态名称的查询。 三、使用 在application.properties文件中的配置\n#jpa的配置 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=create tips:\n​\tjpa.hibernate.ddl-auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：\ncreate：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。\ncreate-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。\nupdate：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\nvalidate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\n四、JPQL查询 ​\t常用关键字\nkeyword sample jpaql snippet And findByLastnameAndFirstname \u0026hellip;where x.firstname = ?1 and x.lastname = ?2 Or findByLastnameOrFirstname \u0026hellip;where x.firstname = ?1 or x.lastname = ?2 Is, Equals findByFirstnameIs, findByFirstnameEquals \u0026hellip;where x.firstname = ?1 Between findByStartDateBetween \u0026hellip;where x.firstname between ?1 and ?2 LessThan findByAgeLessThan \u0026hellip;where x.age \u0026lt; ?1 LessThanEqual findByAgeLessThanEqual \u0026hellip;where x.age \u0026lt;= ?1 GreaterThan findByAgeGreaterThan \u0026hellip;where x.age \u0026gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual \u0026hellip;where x.age \u0026gt;= ?1 After findByStartDateAfter \u0026hellip;where x.startDate \u0026gt; ?1 Before findByStartDateBefore \u0026hellip;where x.startDate \u0026lt; ?1 IsNull findByAgeIsNull \u0026hellip;where x.age is null IsNotNull, NotNull findByAge(IS)NotNull \u0026hellip;where x.age not null Like findByFirstnameLike \u0026hellip;where x.firstname like ?1 NotLike findByFirstnameNotLike \u0026hellip;where x.firstname not like ?1 StartingWith findByFirstnameStartingWith \u0026hellip;where x.firstname like ?1(parameter bound with appended %) EndingWith findByFirstnameEndingWith \u0026hellip;where x.firstname like ?1(parameter bound with prepended %) Containing findByFirstnameContaining \u0026hellip;where x.firstname like ?1(parameter bound with wrapped in %) OrderBy findByAgeOrderByLastnameDesc \u0026hellip; where x.age = ?1 order by x.lastname desc Not findByLastnameNot \u0026hellip; where x.lastname \u0026lt;\u0026gt; ?1 In findByAgeIn (Collection ages) \u0026hellip; where x.age in ?1 NotIn findByAgeNotIn (Collection ages) \u0026hellip; where x.age not in ?1 TRUE findByActiveTrue() \u0026hellip;where x.active=true FALSE findByActiveFalse() \u0026hellip;where x.active=false IgnoreCase findByFirstnameIgnoreCase \u0026hellip;where UPPER(x.firstname) = UPPER(?1) 五、自定义Query 使用原生的sql语句 @Query(nativeQuery = true) 1.查询 实例 public interface UserRepository extends Repository\u0026lt;User, Long\u0026gt; { /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，参数分别为?1，?2，?3...... * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=?1\u0026#34;) public User findUser(Long id); /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * :id为传递的参数 * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=:id\u0026#34;) public User findUserByParam(@Param(\u0026#34;id\u0026#34;) Long id); /** * 根据id和name查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=?1 and u.name=?2\u0026#34;) public User findUserByIdAndName(Long id, String name); /** * 查询所有用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * * @return */ @Query(\u0026#34;select u from User u\u0026#34;) public List\u0026lt;User\u0026gt; findUserList(); /** * 根据name模糊查询 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param name * @return */ @Query(\u0026#34;select u from User u where name like %?1%\u0026#34;) public List\u0026lt;User\u0026gt; findUserListByLikeName(String name); /** * 根据name模糊查询 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param name * @return */ @Query(\u0026#34;select u from User u where name like concat(\u0026#39;%\u0026#39;,?1,\u0026#39;%\u0026#39;) \u0026#34;) public List\u0026lt;User\u0026gt; findUserListByLikeConcatName(String name); /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * nativeQuery = true时，JPA能够识别真正的SQL语句 * * @param id * @return */ @Query(value = \u0026#34;select * from user where id=?1\u0026#34;, nativeQuery = true) public User findUserByNativeQuery(int id); /** * 使用SpEL表达式 * \u0026lt;p\u0026gt; * 从Spring Data JPA 1.4版开始，我们支持在手动定义的查询中使用受限制的SpEL模板表达式@Query。 * 在执行查询时，将根据预定义的变量集评估这些表达式。Spring Data JPA支持一个名为的变量entityName。它的用法是select x from #{#entityName} x。 * 它插入entityName与给定存储库关联的域类型。该entityName解决如下：如果域类型已设置的name属性@Entity的注释，它被使用。否则，使用域类型的简单类名 * * @param name * @return */ @Query(\u0026#34;select u from #{#entityName} u where u.name = ?1\u0026#34;) public List\u0026lt;User\u0026gt; findBySpEL(String name); } 2.更新/删除 示例 ​\tUserRepository.java\n@Transactional//事务：原子性，回滚 @Modifying @Query(\u0026#34;update User set gender=:gender where userName=:name \u0026#34;) public int updateUser(@Param(\u0026#34;gender\u0026#34;) Integer gender ,@Param(\u0026#34;name\u0026#34;) String userName); 3.多表联查 示例 ​\tUserDepartVo.java\n@Data @AllArgsConstructor public class UserDepartVo { String code; String userName; Integer gender; String name; } ​\tUserRepository.java\n//查询所有用户的code，姓名，性别，部门名称 @Query(\u0026#34;select new com.wzy.jxx.jpa.UserDepartVo(u.code,u.userName,u.gender,d.name) \u0026#34; + \u0026#34;from User u,Department d where u.departmentId=d.id\u0026#34;) public List\u0026lt;UserDepartVo\u0026gt; getUserDeparment(); 4.分页查询 示例1 ​\tUserRepository.java\n@Query(\u0026#34;select u from User u where gender=?1 and age between ?2 and ?3 \u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender3(Integer gender, Integer minAge, Integer maxAge,Pageable pageable); ​\tUserController.java\n@PostMapping(\u0026#34;/findPageByGender3\u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender3(Integer page, Integer size,Integer gender, Integer minAge, Integer maxAge){ Pageable pageable = PageRequest.of(page,size); return userRepository.findPageByGender3(gender, minAge, maxAge, pageable); } 示例2 ​\tUserRepository.java\n@Query(value = \u0026#34;select * from User WHERE gender = ?1\u0026#34;,nativeQuery = true) Page\u0026lt;User\u0026gt; findPageByGender(Integer gender, Pageable page); ​\tUserController.java\n@PostMapping(\u0026#34;findPageByGender\u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender(Integer gender){ Pageable pageable = PageRequest.of(0,20); Page\u0026lt;User\u0026gt; userPage = userRepository.findPageByGender(gender,pageable); List\u0026lt;User\u0026gt; users = userPage.getContent(); return userPage; } 5.排序查询 示例 ​\tUserRepository.java\n@Query(value = \u0026#34;select u from User u WHERE gender = ?1\u0026#34;) List\u0026lt;User\u0026gt; findByGenderSort(Integer gender, Sort sort); ​\tUserController.java\n@PostMapping(\u0026#34;findByGenderSort\u0026#34;) public List\u0026lt;User\u0026gt; findByGenderSort(Integer gender){ Sort sort = Sort.by(Sort.Direction.DESC, \u0026#34;id\u0026#34;); List\u0026lt;User\u0026gt; users = userRepository.findByGenderSort(gender,sort); return users; } ","permalink":"https://rexhub.space/posts/back/java/jdbctool/jpa%D1%A7%CF%B0/","summary":"JPA 一、什么是jpa ​\tJPA是Java Persistence API的意思，是一种ORM框架。是使用JDK 5.0注解或XML描述对象－关系表的映射关系的元数据，并将运行期的面向对象语言程序中的实体对象持久化到数据库中。\n二、基于注解的使用 JPA常用注解 注解 解释 @Entity 声明类为实体或表。 @Table 声明表名。 @Basic 指明非约束明确的各个字段。 @Embedded 指定类或它的值是一个可嵌入的类的实体的属性。 @Id 指定的类的属性，用于识别（一个表中的主键）。 @GeneratedValue 指定如何标识属性可以被初始化，例如自动、手动、或从序列表中获得的值。 @Transient 指定的属性，它是不持久的，即：该值永远不会存储再数据库中。 @Column 指定持久属性栏属性。 @SequenceGenerator 指定在@GeneratedValue注解中指定的属性的值。它创建了一个序列。 @TableGenerator 指定在@GeneratedValue批注指定属性的值发生器。它创造了的值生成的表。 @AccessType 这种类型的注释用于设置访问类型。如果设置@AccessType(FIELD)，则可以直接访问变量并且不需要getter和setter，但必须为public。如果设置@AccessType(PROPERTY)，通过getter和setter方法访问Entity的变量。 @JoinColumn 指定一个实体组织或实体的集合。这是用在多对一和一对多关联。 @UniqueConstraint 指定的字段和用于主要或辅助表的唯一约束。 @ColumnResult 参考使用select字句的SQL查询中的列明。 @ManyToMany 定义了连接表之间的多对多的的关系 @ManyToOne 定义了连接表之间的多对一的关系 @OneToMany 定义了连接表之间存在一个一对多的关系。 @OneToOne 定义了连接表之间有一个一对一的关系 @NamedQueries 指定命名查询的列表 @NamedQuery 指定使用静态名称的查询。 三、使用 在application.properties文件中的配置\n#jpa的配置 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=create tips:\n​\tjpa.hibernate.ddl-auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：\ncreate：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。\ncreate-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。\nupdate：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\nvalidate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\n四、JPQL查询 ​\t常用关键字\nkeyword sample jpaql snippet And findByLastnameAndFirstname \u0026hellip;where x.","title":"JPA学习"},{"content":"Vue动画 Vue过渡和动画 1. 过渡和动画基础 什么是过渡和动画\n过渡：从一个状态向另一个状态变化的过程\n动画：与过渡非常类似，只不过动画控制的过程更加细腻，更加精准\n过渡语法：\n\u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 需要添加过渡的div标签--\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; name指定的是过渡所需要的样式名的前提\ntransition组件\nVue给transition标签，提供了六个过度类\n过渡类型 说明 v-enter 进入过渡的开始状态，作用于开始的一帧 v-enter-active 进入过渡生效时的状态，作用于整个过程 v-enter-to 进入过渡的结束状态，作用于结束的一帧 v-leave 离开过渡的开始状态，作用于开始的一帧 v-leave-active 离开过渡生效时的状态，作用于整个过程 v-leave-to 离开过渡的结束状态，作用于结束的一帧 过渡类分析图\n代码示例：\nhtml：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;调整box的宽度\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; css：\n/* 图形的初始状态 */ .chart { width: 200px; height: 50px; background-color: orange; } .box-enter-active, .box-leave-active { transition: width 3s; } .box-enter, .box-leave-to { width: 0px; } .box-enter-to, .box-leave { width: 200px; } js：\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { show: true }, methods: { toggle() { this.show = !this.show; } }, }) 总结\nv-enter 进入前的那一刻，和v-leave-to 离开结束的那一刻，就是隐藏的状态 v-enter-to 进入结束的那一刻，和v-leave 离开前的那一刻，就是显示的状态 v-enter-active 与 v-leave-active，是进入（显示）的整个过渡过程，与离开（隐藏）的整个过渡过程 自定义类名\ntransition允许使用自定义的类名\n如果使用自定义类名，就不需要设置name属性\n设置自定义类名的属性\n进入：enter-class、enter-active-class、enter-to-class 离开：leave-class、leave-active-class、leave-to-class 初始化渲染动画\n\u0026lt;transition appear appear-active-class=\u0026#34;animated swing\u0026#34; enter-active-class=\u0026#34;animated bounceInLeft\u0026#34; leave-active-class=\u0026#34;animated bounceOutLeft\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34;\u0026gt;动画效果过渡\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt; 上述代码中，appear表示开启此特性，appear-class表示初始class样式，appear-to-class表示过渡完成的class样式，appear-active-class会应用在整个过渡过程中\n使用@keyframes创建CSS动画\nkeyframes：关键帧，用于定义动画的每一帧\n代码：\n.bounce-enter-active { animation: Anim 1s; } .bounce-leave-active { /* 反向 */ animation: Anim 1s reverse; } @keyframes Anim { /* 相当于v-enter和v-leave-to */ 0% { transform: scale(0); background-color: red; } /* 相当于 v-enter-to 和 v-leave */ 100% { transform: scale(1); background-color: blue; } } 钩子函数实现动画\n在动画执行过程中的各个阶段会有不同的钩子函数，通过这些钩子函数也可以实现动画\n钩子函数\n入场钩子\n\u0026lt;transition @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @after-enter=\u0026#34;afterEnter\u0026#34; @enter-cancelled=\u0026#34;enterCancelled\u0026#34; \u0026lt;/transition\u0026gt; 出场钩子\n\u0026lt;transition @before-leave=\u0026#34;beforeLeave\u0026#34; @leave=\u0026#34;leave\u0026#34; @after-leave=\u0026#34;after-leave\u0026#34; @leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt; Vue会跳过CSS的检测\n\u0026lt;transition v-bind:css=\u0026#34;false\u0026#34;\u0026gt; \u0026gt; \u0026lt;/transition\u0026gt; Vue结合Velocity.js实现动画\nVelocity.js是一个简单易用，高性能且功能丰富的轻量级JS动画库\n代码：\nenter(el, done) { Velocity(el, { opacity: 1, fontSize: \u0026#39;1.4em\u0026#39; }, { duration: 300 }) Velocity(el, { fontSize: \u0026#39;1em\u0026#39; }, { complete: done }); }, 注意\n在动画钩子函数中可以利用velocity来确定执行的动画 velocity第一个参数是DOM元素，第二个参数是css样式，第三个参数表示动画的配置项 第三个参数可以配置duration动画时长，也可以配置动画完成complete 2. 多个元素过渡 不同标签名元素过渡\n不同标签默元素可以使用v-if和v-else来进行过渡\n代码\n\u0026lt;transition\u0026gt; \u0026lt;ul v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;li\u0026gt;项目1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p v-else\u0026gt;抱歉，没有找到您查询的内容\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt; 相同标签名元素过渡\n相同标签名的元素切换时，需要通过key设置唯一值\n代码：\n\u0026lt;button @click=\u0026#34;isEdit=!isEdit\u0026#34;\u0026gt;切换编辑和保存\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEdit\u0026#34; key=\u0026#34;edit\u0026#34;\u0026gt; 编辑 \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#39;save\u0026#39;\u0026gt; 保存 \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { isEdit: \u0026#34;true\u0026#34; } }); 过渡模式\n过度模式描述 新旧俩个元素参与过渡的时候，新元素的进入和旧元素的离开会同时触发，这是因为\u0026lt;transition\u0026gt;的默认行为进入和离开同时发生了，如果要求离开的元素完全消失后，进入的元素再显示出来（如开始的切换），可以使用transition提供的过渡模式mode，来解决当一个组件离开后，另一个组件进来时发生的位置的闪动或阻塞问题 过渡模式的原理时，设置有序的过渡而不是同时发生过渡，在transition中加入mode属性，它的俩个值如下所示。 in-out：表示新元素先进行过渡，完成之后当前元素过渡离开 out-in：表示当前元素先进行过渡，完成之后新元素过渡进入 3. 多个组件过渡 什么是多个组件过渡\n通过\u0026lt;component\u0026gt;元素的is属性来切换组件，实现动态组件，然后给组件添加过渡，这就是多组件过渡\n案例演示\n\u0026lt;transition name=\u0026#34;fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;componentName\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; Vue.component(\u0026#39;example1\u0026#39;, { template: \u0026#34;#example1\u0026#34; }) Vue.component(\u0026#39;example2\u0026#39;, { template: \u0026#39;#example2\u0026#39; }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { componentName: \u0026#39;example1\u0026#39; } }) 4. 列表过渡 什么是列表过渡\n通过v-for循环显示多个元素，并且通过transition-group组件来给这多个元素同时添加过渡效果\n列表的进入和离开过渡\n\u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;span v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item}} \u0026lt;/span\u0026gt; \u0026lt;/transition-group\u0026gt; /* 插入或移除元素的过程 */ .list-enter-active, .list-leave-active { transition: all 1s; } /* 开始插入或移除结束的位置变化 */ .list-enter, .list-leave-to { opacity: 0; transform: translateY(30px); } 列表的排序过渡\n排序过渡 - 其他元素平滑过渡\n当插入或移除元素的时候，虽然有过渡动画，但是周围的元素会瞬间移动到新的置，而不是平滑过渡。为了实现平滑过渡，可以借助v-move特性，v-move对于设置过渡的切换时机和过渡曲线非常有用。v-move特性会在元素改变定位的过程中应用，它同之前的类名一样，可以通过name属性来自定义前缀（例如name）\n.list-move { transition: transform 1s; } Flip\nVue使用了FLIIP简单动画队列来实现排序过渡，所以即使没有插入或者移除元素，对于元素顺序的变化也支持过渡动画，FLIP动画能提高动画的流畅度，可以解决动画的卡顿，闪烁等不流畅的现象，它不禁可以实现单列过渡，也可以实现多维网络的过渡。FLIP代表First、Last、Invert、Play，有兴趣的读者可以自行研究学习\n列表的交错过渡\n列表的交错过渡，其实就是多个li在做动画时，每一个li做过渡时有时间差，依次过渡\n延迟做过渡动画\nenter(el, done) { //交错过渡，每个li都做延迟过渡 var delay = el.dataset.index * 150; setTimeout(function () { Velocity(el, { opacity: 1, height: \u0026#39;1.6em\u0026#39; }, { complete: done }); }); }, leave(el, done) { var delay = el.dataset.index * 150; setTimeout(function () { Velocity(el, { opacity: 0, height: 0 }, { complete: done }) }) } 可复用的过渡\ntemplate方式 函数式组件方式 ","permalink":"https://rexhub.space/posts/front/vue/vue%E5%8A%A8%E7%94%BB/","summary":"Vue动画 Vue过渡和动画 1. 过渡和动画基础 什么是过渡和动画\n过渡：从一个状态向另一个状态变化的过程\n动画：与过渡非常类似，只不过动画控制的过程更加细腻，更加精准\n过渡语法：\n\u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 需要添加过渡的div标签--\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; name指定的是过渡所需要的样式名的前提\ntransition组件\nVue给transition标签，提供了六个过度类\n过渡类型 说明 v-enter 进入过渡的开始状态，作用于开始的一帧 v-enter-active 进入过渡生效时的状态，作用于整个过程 v-enter-to 进入过渡的结束状态，作用于结束的一帧 v-leave 离开过渡的开始状态，作用于开始的一帧 v-leave-active 离开过渡生效时的状态，作用于整个过程 v-leave-to 离开过渡的结束状态，作用于结束的一帧 过渡类分析图\n代码示例：\nhtml：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;调整box的宽度\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; css：\n/* 图形的初始状态 */ .chart { width: 200px; height: 50px; background-color: orange; } .box-enter-active, .box-leave-active { transition: width 3s; } .box-enter, .box-leave-to { width: 0px; } .","title":"Vue动画"},{"content":"Vue基础 初始Vue 前端技术的发展 HTML：用于编写网页的结构\nCSS：用于美化网页\nJS：用于处理页面的交互效果\nJQuery：JS的升级版，代码简洁，更高效的开发项目\nVue：采用虚拟DOM技术，代码更加简洁\n虚拟DOM技术\n和真实DOM结构类似的JS对象 可以提高浏览器的渲染速度 什么是Vue 一条基于构建用户界面的渐进式框架\n渐进式理解：Vue提供的一系列技术，可以渐渐的，一步一步的使用这个框架 框架理解：解决一类问题的解决方案，理解为工具 Vue的数据绑定基于MVVM设计思想\nMVVM：Model，View，ViewModel\n可以将模型数据与视图连接起来\n模型数据变化会影响视图 视图数据变化会影响模型 Vue的优势 轻量级：Vue简单、直接，所以Vue使用起来更加友好 数据绑定：数据驱动视图，视图也可以驱动数据 指令：指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为 插件：插件用于对Vue框架功能进行扩展 Vue、Angular和React的区别： Angular相对Vue学习成本高，更复杂，性能稍差 React采用了特殊的JSX语法，Vue中推崇编写以*.vue后缀命名的文件格式 Vue开发基础上 1.Vue实例 说明\nVue实例：通过new关键字实例化Vue({})构造函数\n实例化Vue时的参数内的属性，我们称之为选项：\n选项 说明 data Vue实例数据对象 methods 定义Vue实例中的方法 component 定义子组件 computed 计算属性 filters 过滤器 el 唯一根元素 watch 监听数据变化 el唯一根标签：在创建Vue实例时，el表示唯一根标签，通过指定class或id选择器可用来将页面结构与Vue实例对象vm进行绑定。 el：element，元素 el选项表示：当前Vue实例绑定的页面怨怒是 绑定的这个元素，作为Vue实例在界面上的元素 el选项的值：“id或类选择器” 注意：Vue的数据只能在el绑定的元素内部使用 data初始数据：Vue实例的数据对象为data，Vue会将data的属性转换为getter、setter，从而让data的属性能够响应数据变化。 data：数据 data选项表示：当前Vue实例可以使用的数据 data选项的值：对象，对象中可以定义多个数据 js中获取data数据：vm.$data.name、vm.name methods定义方法： method：方法，为啥加s，因为可以有多个方法 methods选项表示：当前Vue实例可以用到的方法 methods选项的值：对象，对象中定义方法 computed计算属性：计算属性结果会被缓存起来，当依赖的响应式属性发生变化时，才会重新计算，返回最终结果。 computed：计算 computed选项表示：当前Vue实例可以用到的计算属性 computed选项的值：对象，对象中定义方法 应用场景：当有些数据需要随着其他数据变动而变动时，就需要使用computed计算数学；一般处理计算逻辑 注意：计算属性，定义时是一个方法，但是当属性使用（所以才叫计算属性）；计算属性需要将结果放回；计算属性具有缓存，这就意味着只要计算属性的依赖没有进行相应的数据更新，那么computed会直接从缓存中获取值，多次访问都会返回之前的计算结果 watch状态监听：用来检测Vue实例中的数据变动 watch：观察、检测 watch选项表示：检测data选项中的数据变化 watch选项的值：对象，对象中定义方法 应用场景：要在数据变化同时进行异步操作或者是比较大的开销时使用 注意：watch是检测data的数据变化，watch的方法必须与data的属性名一致 filter过滤器：对数据进行格式化，比如字符串字母变大写，日期格式化等。 filter：过滤器 filters选项表示：对data选项中的数据进行格式化 filters选项的值：对象，对象中定义方法 应用场景：对数据格式化（字符串中首字母大写，字符串大小写转换、日期格式化） 注意：过滤器函数，必须定义一个参数，此参数就是使用过滤器的数据，将格式化的结果返回 使用过滤器：插值表达式使用：{{data属性名 | 过滤器名称}}或属性绑定使用 v-bind=\u0026quot;{{data属性名 | 过滤器名称}}\u0026quot; 2.Vue数据绑定 绑定样式：内联样式和绑定样式\n绑定行内样式style 绑定对象语法：v-bind:style=\u0026quot;{backgroundColor:pink, width:width, height:height} 绑定数组语法：v-bind:style=\u0026quot;[myDiv, xxx]\u0026quot;，数组中是一个一个的样式对象，如果只绑定一个对象中括号可以省略 上述语法中：pink，width，myDiv均为data数据 为什么要进行样式绑定：绑定之后可以通过操作data数据来改变样式，理解为绑定样式就是为了操作样式 绑定类样式class 绑定对象语法：v-bind:class=\u0026quot;{box}\u0026quot;,data中需要有一个属性：box:\u0026ldquo;box\u0026rdquo;,这里的大括号可以省略 绑定数组语法：v-bind:class=\u0026quot;[box1,box2]\u0026quot; 内置指令\n常用内置指令：\n路径 说明 v-model 双向数据绑定 v-on 监听事件 v-bind 单向事件绑定 v-text 插入文本内容 v-html 插入包含html的内容 v-for 列表渲染 v-if 条件渲染 v-show 显示隐藏 详解\nv-model v-model主要实现数据双向绑定，通常用在表单元素上，例如input、textarea、select等 双向数据绑定：数据改变影响界面，界面改变影响数据 v-text指令： v-text是在DOM元素内部插入文本内容，类似于之前的innerText，理解：v-text是将元素内部文本与data属性进行数据绑定 这个实现的是单项绑定：数据改变影响界面，处理v-model其他的数据绑定都是单向的 v-html指令： v-html是在DOM元素内部插入HTML内容，类似于之前的innerHTML，理解：v-text是将元素内部HTML与data属性进行单向数据绑定 v-bind指令： v-bind可以实现属性单向数据绑定 目的是为了操作DOM元素的属性 v-on指令： v-on是事件监听指令，负责给DOM元素绑定事件，配合事件类型使用 语法：v-on:事件名 = \u0026ldquo;事件处理程序\u0026rdquo; v-for指令： v-for可以实现页面列表渲染，常用来循环数组 语法：v-for = \u0026ldquo;(value, key) in xxx\u0026rdquo;; v-if和v-show指令： 用来控制元素显示或隐藏，属性为布尔值 语法：v-if=\u0026ldquo;isShow\u0026rdquo;，isShow是data中的一个布尔类型数据 区别：v-if控制元素是否渲染，v-show控制元素是否显示，操作display属性 3.Vue事件 事件监听：在Vue中可使用内置指令v-on监听DOM事件，并在触发时运行一些Javascript代码，或绑定事件处理方法。\n语法：v-on:事件名 = \u0026ldquo;事件函数\u0026rdquo;；v-on:事件名 = \u0026ldquo;js代码\u0026rdquo;\n按键修饰符\n监听哪个键盘/抬起 v-on:keyup.案件修饰符 = \u0026lsquo;xxx\u0026rsquo; 案件修饰符其实就是按键名，代表监听哪个按键 事件修饰符\n常用事件修饰符：\n修饰符 说明 .stop 阻止事件冒泡（如:阻止点击子元素触发父元素的点击事件） .prevent 阻止默认事件行为（a标签单击的默认跳转） .capture 事件捕获（如：先执行父元素的点击事件再执行子元素的点击事件） .self 将事件绑定到自身，只有自身才能触发（不能冒泡触发） .once 事件只触发一次 4.Vue组件 什么是组件\n组件是构成页面中独立结构单元，组件主要以页面结构形式存在，不同组件也具有基本交互功能\n组件理解为自定义标签即可，可以是一个标签组成，也可以是多个标签组成\n组件的定义：Vue.component(id, [definition]);\n参数id：组件名称\n参数[definition]：组件配置对象，包括data、template\n局部注册组件\n局部组件，通过components选项来定义 全局组件与局部组件的区别 全局组件再项目中的任何界面都可以使用 局部组件只能在当前界面中使用 template模板\nVue提供了template标签，可以编写组件的结构 优势 改善开发体验：之前的组件模板都是直接以字符串形式书写，这种方式很容易出错 有代码提示，代码高亮，提高开发效率 组件之间数据传递：在Vue开发中，我们会使用大量的组件，所以会存在组件嵌套的情况，那么子组件之间经常需要传递数据\nprops传值 props：properties：意为通过属性传智 这种方式是父组件向子组件传值 my-parent是父组件 template中的标签就是子组件 父组件在使用的时候，通过属性，给子组件div传递值 $emit传值 emit：发射，理解为触发 Vue实例中提供了一个$emit方法，专门用于触发自定义事件的执行 组件切换\n通过v-if和v-else来控制是否显示组件 5.Vue生命周期 钩子函数：钩子函数用来描述Vue实例从创建到销毁的整个生命周期 Vue生命周期：Vue从创建到销毁的整个过程 在生命周期过程中，会执行很多回调函数，这些回调函数叫钩子函数 实例创建 beforeCreate:创建实例对象之前执行，【此时数据不能使用】 created:建实例对象之后执行，【此时数据可以使用】 页面挂载 beforeMount:页面挂载成功之前执行，【无法展示数据】 Mounted: 页面挂载成功之后执行，【可以展示数据】 数据更新 beforeUpdate:组件更新之前执行，【数据更新之前】 update:组件更新之后执行，【数据更新之后】 实例销毁 beforeDestroy:实例销毁之前执行，【可以操作DOM】 destroyed:实例销毁之后执行，【无法操作DOM】 Vue开发基础下 1.全局API Vue.directive\n用来注册指令\n注册语法\nVue.directive(\u0026#39;focus\u0026#39;, { inserted(el, binding){ if(binding.value){ el.focus(); } } }) 参数1：自定义指令的名称\n参数2：配置对象\n配置对象中使用inserted函数处理 inserted函数：会在使用指令的元素被插入到DOM中的时候被带哦用 inserted参数el：使用指令的元素 inserted参数binding：指令相关的配置 使用：\n\u0026lt;div\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; v-foucs/\u0026gt; \u0026lt;/div\u0026gt; Vue.use\n用于给Vue安装插件\n自定义插件\n//定义一个MyPlugin(自定义插件)对象 let MyPlugin = {}; 安装插件\n//编写插件对象的install方法 MyPlugin.install = function (Vue, options) { console.log(options); //在插件中为Vue添加自定义指令 Vue.directive(\u0026#39;my-directive\u0026#39;, { bind(el, binding) { //为自定义指令v-my-directive绑定的DOM元素设置style样式 el.style = \u0026#34;width:100px; height:100px; background-color:#ccc;\u0026#34;; } }); } Vue.use(MyPlugin, { options: true }); 使用插件中的指令\n\u0026lt;div id=\u0026#34;app\u0026#34; v-my-directive\u0026gt;\u0026lt;/div\u0026gt; Vue.extend\n用于创建Vue的子类，对Vue进行扩展\n创建子类\nVue2 = Vue.extend({ data() { return { title: \u0026#39;hello，我是vue的子类\u0026#39; } } }) 这个Vue2子类中，默认携带title数据\n使用子类：\nvar vm = new Vue2({ el: \u0026#39;#app2\u0026#39;, }); \u0026lt;div id=\u0026#34;app2\u0026#34;\u0026gt; app2:{{title}} \u0026lt;/div\u0026gt; Vue.set\n用于响应式对象中增加新属性，确保属性也具备响应式特点\n语法：Vue.set(target, key, value)\ntarget：要更改的数据源（可以是对象或者数组） key：要更改或新增的属性 value：新值 代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { a: \u0026#34;我是根级响应式属性a\u0026#34;, obj: {} } }); Vue.set(vm.obj, \u0026#39;b\u0026#39;, \u0026#39;我是Vue.set添加的响应式的属性b\u0026#39;) 注意\ndata中的根数据是响应式的：a和obj 如果是新增加的obj的属性，这个属于二级数据，而新增加的二级数据默认不是响应式的，即直接通过vm.obj.b=\u0026ldquo;我是xxx\u0026rdquo;，是无法做到响应的 通过Vue.set添加的二级数据可以是响应式的 Vue.mixin\nmix：混合，in：进入，minxin：混入\nVue.mixin：用于给Vue增加混入对象\n理解：在Vue中混进去一个拓展的对象，增加功能\n定义混入：\nVue.mixin({ //混入对象可以有组件的选项 data() { return { msg: \u0026#39;混入的数据\u0026#39; } }, created() { console.log(\u0026#34;混入的created\u0026#34;); var myOption = this.$options.myOption; if (myOption) { console.log(myOption.toUpperCase()); } }, }) Vue实例化：\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, myOption: \u0026#39;hello vue！\u0026#39;, data: { title: \u0026#39;我是title\u0026#39; }, created() { console.log(\u0026#34;Vue的created钩子函数\u0026#34;); }, }); 2.实例属性 vm.$props\n用于接受父组件向子组件传递的数据\n代码：\nVue.component(\u0026#39;my-child\u0026#39;, { props: [\u0026#34;name\u0026#34;], watch: { name() { var brand = this.$props.name; var found = false; this.content.forEach((value, index) =\u0026gt; { if (value.brand == brand) { found = value; } }); this.show = found ? found : { brand: \u0026#39;\u0026#39;, type: \u0026#39;\u0026#39;, price: \u0026#39;\u0026#39; } } } props定义可以通过name传递数据 然后在方法或watch中可以通过this.$props.name获取name属性 其实也可以通过this.name直接获取 vm.$options\n用于获取Vue实例化时传入的选项的值\n代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, customOption: \u0026#39;我是自定义数据\u0026#39;, data: { base: \u0026#34;我是data里的基础数据\u0026#34; }, created() { this.noBase = this.$options.customOption; }, }); \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{base}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{noBase}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; vm.$el\n用于获取Vue绑定的根元素\n代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {} }); vm.$el.innerHTML = \u0026#34;\u0026lt;div\u0026gt;我是替换后的div标签\u0026lt;/div\u0026gt;\u0026#34; 通过vm.$el修改根元素的内部标签\nvm.$children\n用于获取当前实例的直接子组件\n什么是直接子组件\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;child\u0026#34;\u0026gt;查看子组件\u0026lt;/button\u0026gt; \u0026lt;my-componet\u0026gt;\u0026lt;/my-componet\u0026gt; \u0026lt;/div\u0026gt; 在app根元素下的my-componet就是直接子组件\n通过vm.$children可以获取到my-componet\nvm.$root\n用于获取当前组件树的根Vue实例\n组件实例对象和Vue实例对象都有$root属性\n代码\nVue.component(\u0026#39;my-component\u0026#39;, { template: \u0026#39;\u0026lt;button @click=\u0026#34;root\u0026#34;\u0026gt;查看根实例\u0026lt;/button\u0026gt;\u0026#39;, methods: { root() { console.log(this.$root); console.log(this.$root == vm.$root); } } }) vm.$slot\n用于获取插槽\n插槽是用于父组件向子组件传递内容\n代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt;你好\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#39;first\u0026#39;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 插槽：用于接受自定义组件的内容 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 获取插槽的内容：vm.$children[0].slots.default[0].text\nvm.$attrs\n用于获取组件的属性，但不包含class、style以及被声明为props的属性\n定义属性\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; 获取属性\nVue.component(\u0026#39;my-component\u0026#39;, { template: \u0026#39;\u0026lt;button @click=\u0026#34;showAttrs\u0026#34;\u0026gt;查看属性\u0026lt;/button\u0026gt;\u0026#39;, methods: { showAttrs() { console.log(this.$attrs); } }, }) 3.全局配置 productionTip\n用于配置是否显示生产信息提示，默认打开\n关闭生产信息提示：\nVue.config.productionTip = false productionTip：生产信息提示\nsilent\n用于配置是否显示Vue日志和警告，默认打开\n关闭日志和警告：\nVue.config.silent = true slient：沉默的\n注意：配置要写在Vue实例的上方，在Vue实例下方不生效\ndevtools\n用于配置是否允许使用开发工具调试代码，默认允许\n关闭调试\nVue.config.devtools = false devtools: development tools, 开发工具\n4.组件进阶 mixins\n用于注册混入对象，混入对象：包含公共的方法或者数据，计算属性等，然后混入到多个组件中使用，方便管理与统一修改\n定义混入对象并注册\nvar myMixin = { data() { return { message: \u0026#39;mixin的数据\u0026#39; } } } var vm = new Vue({ data: { message: \u0026#39;Vue的数据\u0026#39; }, mixins: [myMixin], created() { console.log(this.message); } }) render\n实现对虚拟DOM的操作，通过JS来渲染界面元素\n代码\nrender(createElement) { return createElement(\u0026#39;p\u0026#39;, { style: { color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;16px\u0026#39;, backgroundColor: \u0026#39;#eee\u0026#39; } }, this.$slots.default); }, 说明\nrender是一个函数，他作为一个选项存在，可以在Vue和组件中使用这个选项 render的参数：createElment是一个用于创建元素的函数 createElement\n用于创建元素\n说明\ncreateElement，createElement()函数返回的并不是一个实际的DOM元素，\n他返回的其实是一个描述节点(createNodeDescription)。\n第1个参数可以是一个HTML标签名或组件选项对象 第2个参数是可选的，可以传入一个与模板中属性对应的数据对象。 第3个参数是由createElement()构建而成的子级虚拟节点，也可以使用字符串来生成文本虚拟节点。 ","permalink":"https://rexhub.space/posts/front/vue/vue%E5%9F%BA%E7%A1%80/","summary":"Vue基础 初始Vue 前端技术的发展 HTML：用于编写网页的结构\nCSS：用于美化网页\nJS：用于处理页面的交互效果\nJQuery：JS的升级版，代码简洁，更高效的开发项目\nVue：采用虚拟DOM技术，代码更加简洁\n虚拟DOM技术\n和真实DOM结构类似的JS对象 可以提高浏览器的渲染速度 什么是Vue 一条基于构建用户界面的渐进式框架\n渐进式理解：Vue提供的一系列技术，可以渐渐的，一步一步的使用这个框架 框架理解：解决一类问题的解决方案，理解为工具 Vue的数据绑定基于MVVM设计思想\nMVVM：Model，View，ViewModel\n可以将模型数据与视图连接起来\n模型数据变化会影响视图 视图数据变化会影响模型 Vue的优势 轻量级：Vue简单、直接，所以Vue使用起来更加友好 数据绑定：数据驱动视图，视图也可以驱动数据 指令：指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为 插件：插件用于对Vue框架功能进行扩展 Vue、Angular和React的区别： Angular相对Vue学习成本高，更复杂，性能稍差 React采用了特殊的JSX语法，Vue中推崇编写以*.vue后缀命名的文件格式 Vue开发基础上 1.Vue实例 说明\nVue实例：通过new关键字实例化Vue({})构造函数\n实例化Vue时的参数内的属性，我们称之为选项：\n选项 说明 data Vue实例数据对象 methods 定义Vue实例中的方法 component 定义子组件 computed 计算属性 filters 过滤器 el 唯一根元素 watch 监听数据变化 el唯一根标签：在创建Vue实例时，el表示唯一根标签，通过指定class或id选择器可用来将页面结构与Vue实例对象vm进行绑定。 el：element，元素 el选项表示：当前Vue实例绑定的页面怨怒是 绑定的这个元素，作为Vue实例在界面上的元素 el选项的值：“id或类选择器” 注意：Vue的数据只能在el绑定的元素内部使用 data初始数据：Vue实例的数据对象为data，Vue会将data的属性转换为getter、setter，从而让data的属性能够响应数据变化。 data：数据 data选项表示：当前Vue实例可以使用的数据 data选项的值：对象，对象中可以定义多个数据 js中获取data数据：vm.$data.name、vm.name methods定义方法： method：方法，为啥加s，因为可以有多个方法 methods选项表示：当前Vue实例可以用到的方法 methods选项的值：对象，对象中定义方法 computed计算属性：计算属性结果会被缓存起来，当依赖的响应式属性发生变化时，才会重新计算，返回最终结果。 computed：计算 computed选项表示：当前Vue实例可以用到的计算属性 computed选项的值：对象，对象中定义方法 应用场景：当有些数据需要随着其他数据变动而变动时，就需要使用computed计算数学；一般处理计算逻辑 注意：计算属性，定义时是一个方法，但是当属性使用（所以才叫计算属性）；计算属性需要将结果放回；计算属性具有缓存，这就意味着只要计算属性的依赖没有进行相应的数据更新，那么computed会直接从缓存中获取值，多次访问都会返回之前的计算结果 watch状态监听：用来检测Vue实例中的数据变动 watch：观察、检测 watch选项表示：检测data选项中的数据变化 watch选项的值：对象，对象中定义方法 应用场景：要在数据变化同时进行异步操作或者是比较大的开销时使用 注意：watch是检测data的数据变化，watch的方法必须与data的属性名一致 filter过滤器：对数据进行格式化，比如字符串字母变大写，日期格式化等。 filter：过滤器 filters选项表示：对data选项中的数据进行格式化 filters选项的值：对象，对象中定义方法 应用场景：对数据格式化（字符串中首字母大写，字符串大小写转换、日期格式化） 注意：过滤器函数，必须定义一个参数，此参数就是使用过滤器的数据，将格式化的结果返回 使用过滤器：插值表达式使用：{{data属性名 | 过滤器名称}}或属性绑定使用 v-bind=\u0026quot;{{data属性名 | 过滤器名称}}\u0026quot; 2.","title":"Vue基础"},{"content":"Lambda表达式 什么是Lambda表达式 JDK8开始支持Lambda表达式，用来让程序编写更优雅 利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 基于Lambda提供stream流式处理极大简化对集合的操作 Lambda表达式语法格式： 说明： 代码示例： MathOperation.java\npackage com.imooc.lambda; /** * 四则运算接口 * @author CubeMonkey * @create 2020-10-23 17:39 */ @FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查 public interface MathOperation { public Float operate(Integer a, Integer b); } LambdaSample.java\npackage com.imooc.lambda; /** * @author CubeMonkey * @create 2020-10-23 17:42 */ public class LambdaSample { public static void main(String[] args) { //1.标准的使用方式 //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口，Java称为\u0026#34;函数式接口\u0026#34; MathOperation addition = (Integer a, Integer b)-\u0026gt;{ System.out.println(\u0026#34;加法运算\u0026#34;); return a+b+0f; }; System.out.println(addition.operate(5, 3)); //2.Lambda允许忽略参数类型 MathOperation substraction = (a, b)-\u0026gt;{ return a - b + 0f; }; System.out.println(substraction.operate(5, 3)); //3.单行实现代码可以省略大括号和return MathOperation multiplication = (a, b) -\u0026gt; a*b+0f; System.out.println(multiplication.operate(5, 3)); //test MathOperation division = (a, b) -\u0026gt;{ System.out.println(\u0026#34;除法运算\u0026#34;); return a * 1.0f / b; }; System.out.println(division.operate(5, 3)); } } 函数式编程 什么是函数式编程 函数式编程是基于函数式接口并使用lambda表达的编程方式 函数式编程理念是将代码作为可重用数据带入到程序中 函数式编程强调“你想做什么”，而不是“你想怎么做” 什么是函数式接口 函数式接口是有且只有一个抽象方法的接口 Java中拥有大量函数式接口，如java.lang.Runnable JDK8后提供了一系列新的函数式接口，位于java.util.function JDK8常用函数式接口 接口 用途 Consumer 对应一个输入参数无输出的功能代码 Function\u0026lt;T, R\u0026gt; 对应一个输入参数且需要返回数据的功能代码 Predicate 用于条件判断，固定返回布尔值 一、函数式接口Predicate 说明： Predicate是新增的函数式接口，位于java.util.function Predicate用于测试传入的数据是否满足判断要求 Predicate接口需要实现test()方法进行逻辑判断 代码示例： package com.imooc.lambda; import java.util.Arrays; import java.util.List; import java.util.function.Predicate; /** * 理解函数式编程 * Predicate函数式接口的使用方法 * @author CubeMonkey * @create 2020-10-23 18:20 */ public class PredicateSample { public static void main(String[] args) { Predicate\u0026lt;Integer\u0026gt; predicate = n-\u0026gt;n\u0026lt;4; boolean result = predicate.test(10); System.out.println(result); List\u0026lt;Integer\u0026gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); /*for (Integer num:list){ if (num % 2 == 1){ System.out.println(num); } }*/ filter(list, n -\u0026gt; n % 2 == 1);//取所有奇数 filter(list, n -\u0026gt; n % 2 == 0);//取所有偶数 filter(list, n -\u0026gt; n \u0026gt; 5 \u0026amp;\u0026amp; n % 2 == 0);//取所有大于5的偶数 } public static void filter(List\u0026lt;Integer\u0026gt; list, Predicate\u0026lt;Integer\u0026gt; predicate){ for (Integer num:list){ if (predicate.test(num)){ System.out.print(num+\u0026#34; \u0026#34;); } } System.out.println(); } } 二、函数式接口Consumer 代码示例： package com.imooc.lambda; import java.util.function.Consumer; /** * Consumer接口的使用 * @author CubeMonkey * @create 2020-10-23 18:57 */ public class ConsumerSample { public static void main(String[] args) { output(s-\u0026gt;System.out.println(\u0026#34;向控制台打印：\u0026#34; + s)); output(s-\u0026gt;{ System.out.println(\u0026#34;向xxx网站发送数据包：\u0026#34;+s); }); } public static void output(Consumer\u0026lt;String\u0026gt; consumer){ String text = \u0026#34;天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为。\u0026#34;; consumer.accept(text); } } 三、函数式接口Function 代码示例： package com.imooc.lambda; import java.util.Random; import java.util.function.Function; /** * 利用Function函数式接口生成定长随机字符串 * @author CubeMonkey * @create 2020-10-23 19:07 */ public class FunctionSample { public static void main(String[] args) { Function\u0026lt;Integer, String\u0026gt; randomStringFunction = l -\u0026gt; { String chars = \u0026#34;abcdefhigklmnopqrstuvwxyz0123456789\u0026#34;; StringBuffer stringBuffer = new StringBuffer(); Random random = new Random(); for (int i = 0; i \u0026lt; l; i++) { int position = random.nextInt(chars.length()); stringBuffer.append(chars.charAt(position)); } return stringBuffer.toString(); }; System.out.println(randomStringFunction.apply(32)); } } 面向函数式编程与面向对象编程比较 面向对象编程 函数式编程 设计思路 面向对象 面向过程 开发侧重 侧重过程，重分析，重设计 侧重结果，快速实现 可读性 结构复杂，相对较差 更适合人眼阅读，可读性更好 代码量 多 少 并发问题 设计不当，会出现线程安全问题 不会出现线程安全问题 健壮性 好 差 使用场景 中大型项目，多人协作工程 小型应用，要求快速实现 Stream流式处理 什么是Stream流式处理 Stream流式处理是建立在Lambda基础上的多数据处理技术 Stream对集合数据处理进行高度抽象，极大简化代码量 Stream可对集合进行迭代，去重，筛选，排序，聚合等一系列处理 Stream常用方法 接口 用途 forEach 循环遍历 map map方法用于映射每个元素对应的结果 filter filter方法用于通过设置的条件过滤出元素 limit limit方法用于获取指定数量的流 sorted sorted方法用于对流进行排序 Collectors Collectors类实现将流转换成集合和聚合元素 Stream流的五种创建方式 package com.imooc.stream; import org.junit.Test; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.stream.IntStream; import java.util.stream.Stream; /** * Stream流对象的五种创建方式 * @author CubeMonkey * @create 2020-10-23 19:50 */ public class StreamGenerator { //基于数组进行创建 @Test public void generator1(){ String[] arr = {\u0026#34;Lily\u0026#34;, \u0026#34;Andy\u0026#34;, \u0026#34;Jackson\u0026#34;, \u0026#34;Smith\u0026#34;}; Stream\u0026lt;String\u0026gt; stream = Stream.of(arr); stream.forEach(s-\u0026gt; System.out.println(s)); } //2.基于集合进行创建 @Test public void generator2(){ List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Lily\u0026#34;); list.add(\u0026#34;Andy\u0026#34;); list.add(\u0026#34;Jackson\u0026#34;); list.add(\u0026#34;Smith\u0026#34;); Stream\u0026lt;String\u0026gt; stream = list.stream(); stream.forEach(s-\u0026gt; System.out.println(s)); } //3.利用generate方法创建无限长度流 @Test public void generator3(){ Stream\u0026lt;Integer\u0026gt; stream = Stream.generate(() -\u0026gt; new Random().nextInt(100000)); stream.limit(10).forEach(i-\u0026gt; System.out.println(i)); } //4.基于迭代器创建流 @Test public void generator4(){ Stream\u0026lt;Integer\u0026gt; stream = Stream.iterate(1, n -\u0026gt; n + 1); stream.limit(100).forEach(i-\u0026gt; System.out.println(i)); } //5.基于字符序列创建流 @Test public void generator5(){ String str = \u0026#34;abcdefg我的\u0026#34;; IntStream stream = str.chars(); stream.forEach(c-\u0026gt; System.out.println(c)); } } Stream常用方法代码示例 package com.imooc.stream; import org.junit.Test; import java.util.Arrays; import java.util.List; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Stream; /** * @author CubeMonkey * @create 2020-10-23 20:29 */ public class StreamMethod { //提取集合中所有偶数并求和 @Test public void case1(){ List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;); int sum = list.stream()//获取stream对象 .mapToInt(s -\u0026gt; Integer.parseInt(s)) //mapToInt将流中每一个数据转为整数 .filter(num -\u0026gt; num % 2 == 0)//filter对流数据进行过滤 .sum();//求和 System.out.println(sum); } //所有名字首字母大写 @Test public void case2(){ List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;lily\u0026#34;, \u0026#34;smith\u0026#34;, \u0026#34;jackson\u0026#34;); Stream\u0026lt;String\u0026gt; stream = list.stream(); //按规则对每一个流进行转化 List\u0026lt;String\u0026gt; collect = stream.map(s -\u0026gt; s.substring(0, 1).toUpperCase() + s.substring(1)) //collect对流数据进行收集，生成新的List/Set .collect(Collectors.toList()); for (String s : collect) { System.out.println(s); } } //将所有奇数从大到小进行排序，且不许出现重复 @Test public void case3(){ List\u0026lt;Integer\u0026gt; list = Arrays.asList(1, 60, 38, 21, 51, 60, 51, 73); List\u0026lt;Integer\u0026gt; newList = list.stream().filter(num -\u0026gt; num % 2 == 1) .distinct() .sorted((a, b) -\u0026gt; b - a) .collect(Collectors.toList()); System.out.println(newList); } } ","permalink":"https://rexhub.space/posts/back/java/lambda/","summary":"Lambda表达式 什么是Lambda表达式 JDK8开始支持Lambda表达式，用来让程序编写更优雅 利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 基于Lambda提供stream流式处理极大简化对集合的操作 Lambda表达式语法格式： 说明： 代码示例： MathOperation.java\npackage com.imooc.lambda; /** * 四则运算接口 * @author CubeMonkey * @create 2020-10-23 17:39 */ @FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查 public interface MathOperation { public Float operate(Integer a, Integer b); } LambdaSample.java\npackage com.imooc.lambda; /** * @author CubeMonkey * @create 2020-10-23 17:42 */ public class LambdaSample { public static void main(String[] args) { //1.标准的使用方式 //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口，Java称为\u0026#34;函数式接口\u0026#34; MathOperation addition = (Integer a, Integer b)-\u0026gt;{ System.out.println(\u0026#34;加法运算\u0026#34;); return a+b+0f; }; System.","title":"Lambda(java)"},{"content":"Maven入门 Maven介绍 Maven是项目管理工具，对软件项目提供构建与依赖管理 Maven是Apache下的Java开源项目 Maven为Java项目提供了统一的管理方式，已成为业界标准 解决了的问题 工程的结构不统一 第三方jar包多的时候，不便于管理 工程打包的困难 Maven核心特性 项目设置遵循统一的规则，保证不同开发环境的兼容性 强大的依赖管理，项目依赖组件自动下载、自动更新 可扩展的插件机制，使用简单，功能丰富 Maven的坐标： GroupId：机构或者团队的英文，采用\u0026quot;逆向域名\u0026quot;形式书写 ArtifactId：项目名称，说明其用途，例如：cms(内容管理系统)，oa(办公自动化系统) Version：版本号，一般采用“版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构 目录 用途 ${basedir} 根目录，用于保存pom.xml ${basedir}/src/main/java Java源代码目录 ${basedir}/src/main/resources 资源目录，保存配置文件、静态图片等 ${basedir}/src/test/java 测试类的源代码 ${basedir}/src/test/resources 测试时需要使用的资源文件 ${basedir}/target 项目输出的目录，用于存储jar、war文件 ${basedir}/target/classes 字节码(.class)的编译输出目录 ${basedir}/pom.xml 项目(Project)对象(Object)模型(Model)文件 Maven的依赖管理 说明 Maven利用dependency(依赖)自动下载、管理第三方Jar 在pom.xml文件中配置项目依赖的第三方组件 maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用 获取 apache：https://search.maven.org/\n阿里云：https://maven.aliyun.com/mvn/search\n本地仓库与中央仓库 使用代理：\n\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!-- 创建私服的地址 --\u0026gt; \u0026lt;id\u0026gt;aliyun\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 普通项目的创建与打包案例（实现中文与拼音的转化） 创建\u0026amp;使用： 新建一个Maven项目，默认的jdk是1.5，将jdk的版本调整为1.8\n配置第三方组件，使得maven自动从远程仓库中下载第三方jar包到本地仓库\n核心语句\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.belerweb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pinyin4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 创建简单的java文件\nPinyinTestor.java\npublic class PinyinTestor { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String str = scanner.nextLine(); String[] pinyin = PinyinHelper.toHanyuPinyinStringArray(str.charAt(0)); for(String py:pinyin) { System.out.println(py); } } } 运行main方法\n打包 在pom.xml配置文件中，根目录下配置打包的信息，使用maven-assemble-plugin插件进行打包输出\n\u0026lt;build\u0026gt; \u0026lt;!-- 配置插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 经典版本 --\u0026gt; \u0026lt;version\u0026gt;2.5.5\u0026lt;/version\u0026gt; \u0026lt;!-- 用于说明打包过程中的一些细节 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 指定项目的入口类 --\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;com.imooc.maven.PinyinTestor \u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;!-- 描述符引用 打包过程中所用到的参数 --\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;!-- all in one, 在打包时会将所有引用的jar包合并到jar文件中 --\u0026gt;\t\u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 运行assembly插件，输出合并的jar文件\n用命令行执行输出的jar包\nWeb项目的创建与打包案例 创建\u0026amp;使用 配置好tomcat，创建一个普通的Maven项目，默认的jdk是1.5，将jdk的版本调整为1.8\n进入项目的配置信息，配置java的编译级别为jdk1.8\n在src/main目录下创建一个文件夹，名为webapp\n将maven工程变成标准的web项目，打开该工程的属性配置页面，选择Project Facets，点击Convert to facted from\u0026hellip;开启项目模块的面板，选择版本为3.1，并指定运行环境，不要直接点击apply and close，还没完\n点击图中出现的Further configuration available\u0026hellip;，设置content directory为src/main/webapp，勾选配置xml文件\n再在右侧找到deployment assembly，添加maven的依赖，否则在maven加入的jar包会失效\n在创建的webapp文件夹中出现MATE-INF和WEB-INF目录说明，已经成功将普通的maven工程变为标准的web工程\n在webapp文件夹下创建一个index.jsp ， 在里面写如this is a maven project!!!\n将当前工程发布到tomcat下运行\n在浏览器的url中输入http:localhost:8080/web-maven/， 在页面上显示this is a maven project!!!\n​\t打包 在pom.xml文件的根目录中编写配置war包的信息\n\u0026lt;!-- packaging代表输出的格式，默认的是jar包 --\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!-- 输出的war包名 --\u0026gt; \u0026lt;finalName\u0026gt;web-maven\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 运行maven中的插件\n点击run\n将生成的war包放在tomcat的webapp目录下，运行tomcat bin目录下的startup.bat文件，在浏览器中输入http:localhost:8080/web-maven/\nMaven常用命令 命令 用途 mvn archetype:generate 创建工程结构 mvn compile 编译源代码 mvn test 执行测试用例 mvn clean 清除产生的项目 mvn package 项目打包 mvn install 安装至本地仓库 ","permalink":"https://rexhub.space/posts/back/java/build_tool/maven%E5%9F%BA%E7%A1%80/","summary":"Maven入门 Maven介绍 Maven是项目管理工具，对软件项目提供构建与依赖管理 Maven是Apache下的Java开源项目 Maven为Java项目提供了统一的管理方式，已成为业界标准 解决了的问题 工程的结构不统一 第三方jar包多的时候，不便于管理 工程打包的困难 Maven核心特性 项目设置遵循统一的规则，保证不同开发环境的兼容性 强大的依赖管理，项目依赖组件自动下载、自动更新 可扩展的插件机制，使用简单，功能丰富 Maven的坐标： GroupId：机构或者团队的英文，采用\u0026quot;逆向域名\u0026quot;形式书写 ArtifactId：项目名称，说明其用途，例如：cms(内容管理系统)，oa(办公自动化系统) Version：版本号，一般采用“版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构 目录 用途 ${basedir} 根目录，用于保存pom.xml ${basedir}/src/main/java Java源代码目录 ${basedir}/src/main/resources 资源目录，保存配置文件、静态图片等 ${basedir}/src/test/java 测试类的源代码 ${basedir}/src/test/resources 测试时需要使用的资源文件 ${basedir}/target 项目输出的目录，用于存储jar、war文件 ${basedir}/target/classes 字节码(.class)的编译输出目录 ${basedir}/pom.xml 项目(Project)对象(Object)模型(Model)文件 Maven的依赖管理 说明 Maven利用dependency(依赖)自动下载、管理第三方Jar 在pom.xml文件中配置项目依赖的第三方组件 maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用 获取 apache：https://search.maven.org/\n阿里云：https://maven.aliyun.com/mvn/search\n本地仓库与中央仓库 使用代理：\n\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!-- 创建私服的地址 --\u0026gt; \u0026lt;id\u0026gt;aliyun\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 普通项目的创建与打包案例（实现中文与拼音的转化） 创建\u0026amp;使用： 新建一个Maven项目，默认的jdk是1.5，将jdk的版本调整为1.8\n配置第三方组件，使得maven自动从远程仓库中下载第三方jar包到本地仓库\n核心语句\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.belerweb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pinyin4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.","title":"Maven"},{"content":"MyBatis基础入门 软件开发中的框架 框架是可被应用开发者定制的应用骨架 框架是一种规则，保证开发者遵循相同的方式开发程序 框架提倡“不要重复造轮子”，对基础功能进行封装 框架的优点 极大提高了开发效率 统一的编码规则，有利于团队管理 灵活配置的应用，拥有更好的维护性 SSM开发框架 S -\u0026gt; Spring S -\u0026gt; Spring MVC M -\u0026gt; MyBatis 什么是MyBatis MyBatis是优秀的持久层框架 MyBatis使用XML将SQL与程序解耦，便于维护 MyBatis学习简单，执行高效，是JDBC的延展 MyBatis开发流程 引入MyBatis依赖 创建核心配置文件 创建实体(Entity)类 创建Mapper映射文件 初始化SessionFactory 利用SqlSession对象操作数据 MyBatis环境配置 mybatis-config.xml说明 MyBatis采用XML格式配置数据库环境信息 MyBatis环境配置标签 environment包含数据库驱动、URL、用户名于密码 mybatis-config.xml示例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--根据环境，不同的环境不同的id，dev-\u0026gt;开发环境 prd-\u0026gt;生产环境 --\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--数据连接方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;environment id=\u0026#34;prd\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--数据连接方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://192.168.1.1:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 创建SqlSession SqlSessionFactory SqlSessionFactory是MyBatis的核心对象 用于初始化MyBatis，创建SqlSession对象 保证SqlSessionFactory在应用中全局唯一 SqlSession SqlSession是MyBatis操作数据库的核心对象 SqlSession使用JDBC方式与数据库交互 SqlSession对象提供了数据表CRUD对应方法 示例代码 package com.imooc.mybatis; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.Reader; import java.sql.Connection; /** * JUNIT单元测试类 * @author CubeMonkey * @create 2020-10-27 10:21 */ public class MyBatisTestor { @Test public void testSqlSessionFactory() throws IOException { //利用Reader加载classpath下的mybatis-config.xml核心配置文件 Reader reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); //初始化SqlSessionFactory对象，同时解析mybatis-config.xml文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = null; try { //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互 sqlSession = sqlSessionFactory.openSession(); //创建数据库连接（测试用） Connection conn = sqlSession.getConnection(); System.out.println(conn); }catch (Exception e){ e.printStackTrace(); } finally { if (sqlSession != null) { //如果type=\u0026#34;POOLED\u0026#34;, 代表使用连接池，close则是将连接回收到连接池中 //如果type=\u0026#34;UNPOOLED\u0026#34;,代表直连，close则会调用Connection.close()方法关闭连接 sqlSession.close(); } } } } 初始化工具类MyBatisUtils MyBatisUtils代码示例： package com.imooc.mybatis.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.Reader; /** * MyBatisUtils工具类，创建全局唯一的SqlSessionFactory对象 * @author CubeMonkey * @create 2020-10-27 10:51 */ public class MyBatisUtils { //利用static(静态)属于类不属于对象，且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态代码块在初始化类时实例化sqlSessionFactory static{ Reader reader = null; try { reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); } catch (IOException e) { e.printStackTrace(); //初始化错误时，通过抛出异常ExceptionInitializerError通知调用者 throw new ExceptionInInitializerError(e); } } /** * openSession 创建一个新的SqlSession对象 * @return SqlSession对象 */ public static SqlSession openSession(){ return sqlSessionFactory.openSession(); } /** * 释放一个有效的SqlSession对象 * @param sqlSession 准备释放sqlSession对象 */ public static void closeSession(SqlSession sqlSession){ if (sqlSession != null){ sqlSession.close(); } } } MyBatisUtils工具类使用实例：\n@Test public void testMyBatisUtils(){ SqlSession sqlSession = null; try { sqlSession = MyBatisUtils.openSession(); Connection conn = sqlSession.getConnection(); System.out.println(conn); }catch (Exception e){ e.printStackTrace(); }finally { MyBatisUtils.closeSession(sqlSession); } } MyBatis数据查询 简单查询 MyBatis数据查询步骤 创建实体类(Entity) 创建Mapper Xml 编写SQL标签 开启驼峰命名映射 新增 SqlSession执行select语句 示例： 创建实体类\nGoods.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 11:28 */ public class Goods { private Integer goodsId;//商品编号 private String title;//标题 private String subTitle;//子标题 private Float originalCost;//原始价格 private Float currentPrice;//当前价格 private Float discount;//折扣率 private Integer isFreeDelivery;//是否包邮，1-包邮 0-不包邮 private Integer categoryId;//分类编号 public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.goodsId = goodsId; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getSubTitle() { return subTitle; } public void setSubTitle(String subTitle) { this.subTitle = subTitle; } public Float getOriginalCost() { return originalCost; } public void setOriginalCost(Float originalCost) { this.originalCost = originalCost; } public Float getCurrentPrice() { return currentPrice; } public void setCurrentPrice(Float currentPrice) { this.currentPrice = currentPrice; } public Float getDiscount() { return discount; } public void setDiscount(Float discount) { this.discount = discount; } public Integer getIsFreeDelivery() { return isFreeDelivery; } public void setIsFreeDelivery(Integer isFreeDelivery) { this.isFreeDelivery = isFreeDelivery; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } } 创建Mapper Xml\n编写SQL标签\nresources/mappers/goods.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goods\u0026#34;\u0026gt; \u0026lt;!--resultType-\u0026gt;返回的数据类型 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods order by goods_id desc limit 10 \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 开启驼峰命名映射\n在mybatis-config.xml中的configuration下添加settings配置\n\u0026lt;settings\u0026gt; \u0026lt;!--goods_id ==\u0026gt; goodsId 驼峰命名转化--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 新增\n在mybatis-config.xml中的configuration下添加mapper配置\n\u0026lt;mappers\u0026gt; \u0026lt;!--resource指的是映射文件的目录--\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/goods.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt; SqlSession执行select语句\nMyBatisTestor部分测试代码：\n@Test public void testSelectAll(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectAll\u0026#34;); for (Goods goods : list) { System.out.println(goods.getTitle()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } } SQL传参 单参数传参\ngoods.xml\n\u0026lt;!--单参数传递，使用parameterType指定参数的数据类型即可，SQL#{value}提取参数--\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where goods_id = #{value} \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectById(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = session.selectOne(\u0026#34;goods.selectById\u0026#34;, 1603); System.out.println(goods.getTitle()); }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } } 多参数传参\ngoods.xml\n\u0026lt;select id=\u0026#34;selectByPriceRange\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limit} \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectByPriceRange(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Map param = new HashMap\u0026lt;String, Integer\u0026gt;(); param.put(\u0026#34;min\u0026#34;, 100); param.put(\u0026#34;max\u0026#34;, 500); param.put(\u0026#34;limit\u0026#34;, 10); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectByPriceRange\u0026#34;, param); for (Goods goods : list) { System.out.println(goods.getTitle()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } } 多表查询 示例（不用ResultMap结果映射）： goods.xml中添加以下代码\n\u0026lt;!--利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值，字段类型根据表结构进行自动判断 优点：易于扩展，易于使用 缺点：太过灵活，无法进行编译时检查 --\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsMap\u0026#34; resultType=\u0026#34;java.util.LinkedHashMap\u0026#34;\u0026gt; select g.*, c.category_name from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectGoodsMap(){ SqlSession sqlSession = null; sqlSession = MyBatisUtils.openSession(); List\u0026lt;Map\u0026gt;list = sqlSession.selectList(\u0026#34;goods.selectGoodsMap\u0026#34;); for (Map map : list) { System.out.println(map); } } ResultMap结果映射 ResultMap可以将查询结果映射为复杂类型的Java对象 ResultMap使用于Java对象保存多表关联结果 ResultMap支持对象关联查询等高级特性 tip:DTO-\u0026gt;Data Transfer Object \u0026ndash; 数据传输对象 使用ResultMap结果映射 编写GoodsDTO -\u0026gt;\npackage com.imooc.mybatis.dto; import com.imooc.mybatis.entity.Category; import com.imooc.mybatis.entity.Goods; /** * @author CubeMonkey * @create 2020-10-27 18:50 */ //Data Transfer Object --数据传输对象 public class GoodsDTO { private Goods goods = new Goods(); private Category category = new Category(); private String test; public Goods getGoods() { return goods; } public void setGoods(Goods goods) { this.goods = goods; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } public String getTest() { return test; } public void setTest(String test) { this.test = test; } } Goods.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 11:28 */ public class Goods { private Integer goodsId;//商品编号 private String title;//标题 private String subTitle;//子标题 private Float originalCost;//原始价格 private Float currentPrice;//当前价格 private Float discount;//折扣率 private Integer isFreeDelivery;//是否包邮，1-包邮 0-不包邮 private Integer categoryId;//分类编号 public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.goodsId = goodsId; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getSubTitle() { return subTitle; } public void setSubTitle(String subTitle) { this.subTitle = subTitle; } public Float getOriginalCost() { return originalCost; } public void setOriginalCost(Float originalCost) { this.originalCost = originalCost; } public Float getCurrentPrice() { return currentPrice; } public void setCurrentPrice(Float currentPrice) { this.currentPrice = currentPrice; } public Float getDiscount() { return discount; } public void setDiscount(Float discount) { this.discount = discount; } public Integer getIsFreeDelivery() { return isFreeDelivery; } public void setIsFreeDelivery(Integer isFreeDelivery) { this.isFreeDelivery = isFreeDelivery; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } } Category.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 19:12 */ public class Category { private Integer categoryId; private String categoryName; private Integer parentId; private Integer categoryLevel; private Integer categoryOrder; public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } public String getCategoryName() { return categoryName; } public void setCategoryName(String categoryName) { this.categoryName = categoryName; } public Integer getParentId() { return parentId; } public void setParentId(Integer parentId) { this.parentId = parentId; } public Integer getCategoryLevel() { return categoryLevel; } public void setCategoryLevel(Integer categoryLevel) { this.categoryLevel = categoryLevel; } public Integer getCategoryOrder() { return categoryOrder; } public void setCategoryOrder(Integer categoryOrder) { this.categoryOrder = categoryOrder; } } 在goods.xml中添加如下信息\n\u0026lt;!--结果映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods\u0026#34; type=\u0026#34;com.imooc.mybatis.dto.GoodsDTO\u0026#34;\u0026gt; \u0026lt;!--设置主键字段与属性映射--\u0026gt; \u0026lt;id property=\u0026#34;goods.goodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!--设置非主键字段与属性映射--\u0026gt; \u0026lt;result property=\u0026#34;goods.title\u0026#34; column=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.originalCost\u0026#34; column=\u0026#34;original_cost\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.currentPrice\u0026#34; column=\u0026#34;current_price\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.discount\u0026#34; column=\u0026#34;discount\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.isFreeDelivery\u0026#34; column=\u0026#34;is_free_delivery\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryName\u0026#34; column=\u0026#34;category_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.parentId\u0026#34; column=\u0026#34;parent_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryLevel\u0026#34; column=\u0026#34;category_level\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryOrder\u0026#34; column=\u0026#34;category_order\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;test\u0026#34; column=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsDTO\u0026#34; resultMap=\u0026#34;rmGoods\u0026#34;\u0026gt; select g.*, c.*, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; MyBatis的写操作 Insert操作 在goods.xml中配置如下信息\n\u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId}) \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; MyBatisTestor.java 测试代码\n@Test public void testInsert() { SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(\u0026#34;测试用例标题\u0026#34;); goods.setSubTitle(\u0026#34;测试用例子标题\u0026#34;); goods.setOriginalCost(1f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(12); int num = session.insert(\u0026#34;goods.insert\u0026#34;, goods); session.commit();//这个很重要，不能忘记 if (num == 1) System.out.println(\u0026#34;插入成功\u0026#34;); else System.out.println(\u0026#34;插入失败\u0026#34;); System.out.println(goods.getGoodsId()); } catch (Exception e){ session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } } selectKey与useGeneratedKey区别 selectKey: \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; useGeneratedKey: \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; keyColumn=\u0026#34;goods_id\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;/insert\u0026gt; 二者区别 - 显示与隐式 selectKey标签需要明确编写获取最新主键的SQL语句(不同的数据库驱动获取最新主键的SQL语句不同) useGeneratedKeys属性会自动根据驱动生成对应SQL语句 二者区别-应用场景不同 selectKey适用于所有的关系型数据库 useGeneratedKeys只支持“自增主键”类型的数据库 tip: ​\t不支持自增主键的数据库有：DB2， Oracle\n在oracle中selectKey的用法： \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;BEFORE\u0026#34;\u0026gt; select seq_goods.nextval as id from dual \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; 总结： selectKey标签是通用方案，使用于所有数据库，但编写麻烦 useGeneratedKeys属性只支持“自增主键”数据库，使用简单 update操作 goods.xml:\n\u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; update t_goods set title = #{title}, sub_title = #{subTitle}, original_cost = #{originalCost}, current_price = #{currentPrice}, discount = #{discount}, is_free_delivery = #{isFreeDelivery}, category_id = #{categoryId} where goods_id = #{goodsId} \u0026lt;/update\u0026gt; MyBatisTestor.java\n@Test public void testUpdate(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = session.selectOne(\u0026#34;selectById\u0026#34;, 739); goods.setTitle(\u0026#34;更新测试商品\u0026#34;); int num = session.update(\u0026#34;goods.update\u0026#34;, goods); if (num == 1) System.out.println(\u0026#34;更新成功\u0026#34;); else System.out.println(\u0026#34;更新失败\u0026#34;); System.out.println(goods.getTitle()); session.commit(); } catch (Exception e) { session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } } ​\ndelete操作 goods.xml\n\u0026lt;delete id=\u0026#34;delete\u0026#34; parameterType=\u0026#34;Integer\u0026#34;\u0026gt; delete from t_goods where goods_id = #{value} \u0026lt;/delete\u0026gt; MyBatisTestor.java\n@Test public void testDelete(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); int num = session.delete(\u0026#34;goods.delete\u0026#34;, 739); if (num == 1) System.out.println(\u0026#34;删除成功\u0026#34;); else System.out.println(\u0026#34;删除失败\u0026#34;); session.commit(); } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } } MyBatis预防SQL注入攻击 SQL注入攻击 SQL注入是指攻击者利用SQL漏洞，绕过系统约束，越权获取数据的攻击方式 MyBatis俩种传值方式 ${}文本替换，未经任何处理对SQL文本替换（可以用于动态使用SQL语句，使用时绝对不能从外界输入） #{}预编译传值，使用预编译传值可以预防SQL注入 MyBatis工作流程 ","permalink":"https://rexhub.space/posts/back/java/jdbctool/mybatis%E5%9F%BA%E7%A1%80/","summary":"MyBatis基础入门 软件开发中的框架 框架是可被应用开发者定制的应用骨架 框架是一种规则，保证开发者遵循相同的方式开发程序 框架提倡“不要重复造轮子”，对基础功能进行封装 框架的优点 极大提高了开发效率 统一的编码规则，有利于团队管理 灵活配置的应用，拥有更好的维护性 SSM开发框架 S -\u0026gt; Spring S -\u0026gt; Spring MVC M -\u0026gt; MyBatis 什么是MyBatis MyBatis是优秀的持久层框架 MyBatis使用XML将SQL与程序解耦，便于维护 MyBatis学习简单，执行高效，是JDBC的延展 MyBatis开发流程 引入MyBatis依赖 创建核心配置文件 创建实体(Entity)类 创建Mapper映射文件 初始化SessionFactory 利用SqlSession对象操作数据 MyBatis环境配置 mybatis-config.xml说明 MyBatis采用XML格式配置数据库环境信息 MyBatis环境配置标签 environment包含数据库驱动、URL、用户名于密码 mybatis-config.xml示例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--根据环境，不同的环境不同的id，dev-\u0026gt;开发环境 prd-\u0026gt;生产环境 --\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--数据连接方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;environment id=\u0026#34;prd\u0026#34;\u0026gt; \u0026lt;!","title":"Mybatis基础"},{"content":"MyBatis进阶 什么是日志 日志文件是用于记录系统操作事件的记录文件或文件集合 日志保存历史数据，是诊断问题以及理解系统活动的重要依据 SLF4j与Logback 日志的使用: 引入logback依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 创建logback.xml，并写入如下代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别（优先级高到低） error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序允许的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;\u0026gt;\u0026lt;/appender-ref\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 动态SQL 动态SQL是指根据参数数据动态组织SQL的技术 代码示例： goods.xml中加入如下sql语句\n\u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;currentPrice != null\u0026#34;\u0026gt; and current_price \u0026amp;lt; #{currentPrice} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; MyBatisTestor.java中使用dynamicSelect\n@Test public void testDynamicSQL(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); HashMap\u0026lt;String, Object\u0026gt; param = new HashMap\u0026lt;\u0026gt;(); param.put(\u0026#34;categoryId\u0026#34;, 44); param.put(\u0026#34;currentPrice\u0026#34;, 500); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.dynamicSelect\u0026#34;, param); for (Goods goods : list) { System.out.println(goods.getTitle()); } } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } } MyBatis二级缓存 一级缓存默认开启，缓存范围SqlSession会话 二级缓存手动开启，属于Mapper Namespace 缓存的范围 二级缓存运行规则 二级开启后默认所有查询操作均使用缓存 写操作commit提交时对该namespace缓存强制清空 配置useCache=false可以不用缓存 配置flushCache=true代表强制清空缓存 二级缓存的使用：\ngoods.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goods\u0026#34;\u0026gt; \u0026lt;!--开启了二级缓存 1.LRU - 最近最久未使用：移除最长时间不被使用的对象 2.LFU - 最近最少使用：移除最近访问频率最低的对象 3.FIFO - 先进后出：按对象进入缓存的顺序来移除他们。 4.SOFT - 软引用：移除基于垃圾收集器状态和软引用规则的对象 5.WEAK - 弱引用：更积极的移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval 代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒 = 10分钟 size 缓存存储上限，用于保存对象或集合（1个集合算1个对象）的数量上限 readOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高 设置为false，代表每次取出的是缓存对象的“副本”，每一次取出的对象都是不同的，这种安全性较高 --\u0026gt; \u0026lt;cache eviction=\u0026#34;LRU\u0026#34; flushInterval=\u0026#34;600000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;!-- useCache=\u0026#34;false\u0026#34;代表不使用缓存--\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useCache=\u0026#34;false\u0026#34;\u0026gt; select * from t_goods order by goods_id desc limit 10 \u0026lt;/select\u0026gt; \u0026lt;!--单参数传递，使用parameterType指定参数的数据类型即可，SQL#{value}提取参数--\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where goods_id = #{value} \u0026lt;/select\u0026gt; \u0026lt;!--多参数传递时，使用parameterType指定java.util.Map, SQL中#{key提取参数}--\u0026gt; \u0026lt;select id=\u0026#34;selectByPriceRange\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limit} \u0026lt;/select\u0026gt; \u0026lt;!--利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值，字段类型根据表结构进行自动判断 优点：易于扩展，易于使用 缺点：太过灵活，无法进行编译时检查 --\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsMap\u0026#34; resultType=\u0026#34;java.util.LinkedHashMap\u0026#34; flushCache=\u0026#34;true\u0026#34;\u0026gt; select g.*, c.category_name, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; \u0026lt;!--结果映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods\u0026#34; type=\u0026#34;com.imooc.mybatis.dto.GoodsDTO\u0026#34;\u0026gt; \u0026lt;!--设置主键字段与属性映射--\u0026gt; \u0026lt;id property=\u0026#34;goods.goodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!--设置非主键字段与属性映射--\u0026gt; \u0026lt;result property=\u0026#34;goods.title\u0026#34; column=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.originalCost\u0026#34; column=\u0026#34;original_cost\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.currentPrice\u0026#34; column=\u0026#34;current_price\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.discount\u0026#34; column=\u0026#34;discount\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.isFreeDelivery\u0026#34; column=\u0026#34;is_free_delivery\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryName\u0026#34; column=\u0026#34;category_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.parentId\u0026#34; column=\u0026#34;parent_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryLevel\u0026#34; column=\u0026#34;category_level\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryOrder\u0026#34; column=\u0026#34;category_order\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;test\u0026#34; column=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsDTO\u0026#34; resultMap=\u0026#34;rmGoods\u0026#34;\u0026gt; select g.*, c.*, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; \u0026lt;!--flushCache=\u0026#34;true\u0026#34;在sql执行后强制清空缓存--\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; keyColumn=\u0026#34;goods_id\u0026#34; flushCache=\u0026#34;true\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId}) \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;!--\u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt;--\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; update t_goods set title = #{title}, sub_title = #{subTitle}, original_cost = #{originalCost}, current_price = #{currentPrice}, discount = #{discount}, is_free_delivery = #{isFreeDelivery}, category_id = #{categoryId} where goods_id = #{goodsId} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;delete\u0026#34; parameterType=\u0026#34;Integer\u0026#34;\u0026gt; delete from t_goods where goods_id = #{value} \u0026lt;/delete\u0026gt; \u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;currentPrice != null\u0026#34;\u0026gt; and current_price \u0026amp;lt; #{currentPrice} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 商品和详情对象关联查询 ​\t关联商品与商品详情信息\n代码案例（一对多）： 在Goods.java中添加goodDetail集合成员\n创建goods_detail.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goodsDetail\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectByGoodsId\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.GoodsDetail\u0026#34;\u0026gt; select * from t_goods_detail where goods_id = #{value} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在mybatis-config.xml中添加goods_detail.xml的映射\n\u0026lt;mapper resource=\u0026#34;mappers/goods_detail.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; 在goods.xml编写select语句\n\u0026lt;!-- resultMap可用于说明一对多或者多对一的映射逻辑 id 是resultMap属性引用的标志 type 指向One的实体(Goods) --\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods1\u0026#34; type=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; \u0026lt;!--映射Goods对象的主键到goods_id字段--\u0026gt; \u0026lt;id column=\u0026#34;goods_id\u0026#34; property=\u0026#34;goodsId\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!-- collection的含义是， 在select * from t_goods limit 0, 1得到结果后，对所有Goods对象遍历得到goods_id字段值， 并带入到goodsDetail命名空间的findByGoodsId的SQL中执行查询 将得到的“商品详情”集合赋值给goodsDetail List对象 --\u0026gt; \u0026lt;collection property=\u0026#34;goodsDetails\u0026#34; select=\u0026#34;goodsDetail.selectByGoodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectOneToMany\u0026#34; resultMap=\u0026#34;rmGoods1\u0026#34;\u0026gt; select * from t_goods limit 0,10 \u0026lt;/select\u0026gt; 在MyBatisUtils中编写测试代码\n@Test public void testOneToMany() throws Exception{ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectOneToMany\u0026#34;); for (Goods goods : list) { System.out.println(goods.getTitle()+\u0026#34;:\u0026#34;+goods.getGoodsDetails().size()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } } 代码案例（多对一）： 在GoodsDetail.java中添加goods成员\n在goods_detail.xml中添加select语句\n\u0026lt;resultMap id=\u0026#34;rmGoodsDetail\u0026#34; type=\u0026#34;com.imooc.mybatis.entity.GoodsDetail\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;gd_id\u0026#34; property=\u0026#34;gdId\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;goods_id\u0026#34; property=\u0026#34;goodsId\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;goods\u0026#34; select=\u0026#34;goods.selectById\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectManyToOne\u0026#34; resultMap=\u0026#34;rmGoodsDetail\u0026#34;\u0026gt; select * from t_goods_detail limit 0, 100 \u0026lt;/select\u0026gt; 在MyBatisTestor.java中添加如下测试代码：\n@Test public void testManyToOne(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;GoodsDetail\u0026gt; list = session.selectList(\u0026#34;goodsDetail.selectManyToOne\u0026#34;); for (GoodsDetail goodsDetail : list) { System.out.println(goodsDetail.getGdPicUrl()+\u0026#34;:\u0026#34;+goodsDetail.getGoods().getTitle()); } } catch (Exception e) { throw e; } finally { MyBatisUtils.closeSession(session); } } 分页插件PageHelper 分页查询的麻烦事 当前页数据查询 - select * from tab limit 0, 10 总记录数查询 - select count(*) from tab 程序计算总页数、上一页码、下一页码 PageHelper使用流程 maven引入PageHelper与jsqlparser\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.jsqlparse\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsqlparser\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; mybatis-config.xml增加Plugin配置\n\u0026lt;!-- 启用PageHelper分页插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.PageInterceptor\u0026#34;\u0026gt; \u0026lt;!-- 设置数据库类型 --\u0026gt; \u0026lt;property name=\u0026#34;helperDialect\u0026#34; value=\u0026#34;mysql\u0026#34;/\u0026gt; \u0026lt;!-- 分页合理化 --\u0026gt; \u0026lt;property name=\u0026#34;reasonable\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 代码中使用PageHelper.startPage()自动分页\ngoods.xml中的查询语句\n\u0026lt;select id=\u0026#34;selectPage\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price \u0026amp;lt; 1000 \u0026lt;/select\u0026gt; MyBatisTestor.java中的查询代码\n@Test public void testSelectPage(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); /*startPage方法会自动将下一次查询进行分页*/ PageHelper.startPage(2, 10); Page\u0026lt;Goods\u0026gt; page = (Page)session.selectList(\u0026#34;goods.selectPage\u0026#34;); System.out.println(\u0026#34;总页数：\u0026#34;+page.getPages()); System.out.println(\u0026#34;总记录数：\u0026#34;+page.getTotal()); System.out.println(\u0026#34;开始行号：\u0026#34;+page.getStartRow()); System.out.println(\u0026#34;结束行号：\u0026#34;+page.getEndRow()); System.out.println(\u0026#34;当前页码：\u0026#34;+page.getPageNum()); List\u0026lt;Goods\u0026gt; data = page.getResult(); for (Goods g : data) { System.out.println(g.getTitle()); } System.out.println(); } catch (Exception e) { throw e; } finally { MyBatisUtils.closeSession(session); } } 不同数据库分页的实现原理 MySQL分页 select * from table limit 10, 20; Oracle分页（商业数据库NO.1） select t3.from( select t2.* rownum as rownum from( select * from table order by id asc )t2 where rownum \u0026lt;=20 )t3 where 52.row_num\u0026gt;11 SQL Server 2000 select top 3 * from table where id not in (select top 15 id from table) SQL Server 2012+ ​\nselect * from table order by id offset 4 rows fetch next 5 row only MyBatis整合C3P0连接池 引入C3P0的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写C3P0DataSourceFactory继承自UnpooledDataSourceFactory\npackage com.imooc.mybatis.datasource; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory; /** * C3P0与MyBatis兼容使用的数据源工厂类 * @author CubeMonkey * @create 2020-10-29 20:04 */ public class C3P0DataSourceFactory extends UnpooledDataSourceFactory { public C3P0DataSourceFactory(){ this.dataSource = new ComboPooledDataSource(); } } 在mybatis-config.xml中配置c3p0数据库连接池\n\u0026lt;dataSource type=\u0026#34;com.imooc.mybatis.datasource.C3P0DataSourceFactory\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=GMT\u0026amp;amp;useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34; value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; MyBatis批处理 批量插入数据的局限： 无法获得插入数据的id 批量生成的SQL太长，可能会被服务器拒绝（可采用数据分段的方式） 批量插入： goods.xml中的insert语句\n\u0026lt;insert id=\u0026#34;insertBatch\u0026#34; parameterType=\u0026#34;java.util.List\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values \u0026lt;foreach collection=\u0026#34;list\u0026#34; separator=\u0026#34;,\u0026#34; item=\u0026#34;item\u0026#34; index=\u0026#34;index\u0026#34;\u0026gt; (#{item.title}, #{item.subTitle}, #{item.originalCost}, #{item.currentPrice}, #{item.discount}, #{item.isFreeDelivery}, #{item.categoryId}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; MyBatisTestor.java中testInsertBatch()\n@Test public void testInsertBatch(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); long st = new Date().getTime(); List\u0026lt;Goods\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; 1000; i++){ Goods goods = new Goods(); goods.setTitle(\u0026#34;测试商品\u0026#34;); goods.setSubTitle(\u0026#34;测试子标题\u0026#34;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); list.add(goods); } session.insert(\u0026#34;goods.insertBatch\u0026#34;, list); session.commit(); long et = new Date().getTime(); System.out.println(\u0026#34;执行时间：\u0026#34; + (et-st) + \u0026#34;毫秒\u0026#34;);//1179 } catch (Exception e) { if (session != null){ session.rollback(); } } finally { MyBatisUtils.closeSession(session); } } 批量删除： goods.xml中delet语句：\n\u0026lt;delete id=\u0026#34;deleteBatch\u0026#34; parameterType=\u0026#34;java.util.List\u0026#34;\u0026gt; delete from t_goods where goods_id in \u0026lt;foreach collection=\u0026#34;list\u0026#34; index=\u0026#34;index\u0026#34; item=\u0026#34;item\u0026#34; separator=\u0026#34;, \u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{item} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; MyBatisTestor.java中testDeleteBatch()\n@Test public void testDeleteBatch(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); long st = new Date().getTime(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1920); list.add(1921); list.add(1922); session.insert(\u0026#34;goods.deleteBatch\u0026#34;, list); session.commit(); long et = new Date().getTime(); System.out.println(\u0026#34;执行时间：\u0026#34; + (et-st) + \u0026#34;毫秒\u0026#34;);//725毫秒 } catch (Exception e) { if (session != null){ session.rollback(); } } finally { MyBatisUtils.closeSession(session); } } MyBatis注解 注解和xml配置的优点： xml有更好的维护性，更适合大型的需要团队协作的项目 注解有更好的程序编码体验，更适合小型敏捷开发的工程 MyBatis常用注解 注解 对应XML 说明 @Insert 新增SQL @Update 更新SQL @Delect 删除SQL @Select 查询SQL @Param \u0026ndash; 参数映射 @Results 结果映射 @Result 字段映射 准备工作（不再使用之前用的工程）； 引入mybatis、logback日志、数据库驱动的依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置mybatis-config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- goods_id ==\u0026gt; goodsId 驼峰命名转换 --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--设置默认指向的数据库--\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--配置环境，不同的环境不同的id名字--\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--采用连接池方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useSSL=false\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 配置好logback.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;[%thread] %d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别(优先级高到低): error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序运行的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 在java目录下创建一个dao包，在dao下创建GoodsDAO\n在mybatis-config.xml中配置mapper映射\n\u0026lt;mappers\u0026gt; \u0026lt;!--当有多个dao接口时，mapper不便于维护--\u0026gt; \u0026lt;!-- \u0026lt;mapper class=\u0026#34;com.imooc.mybatis.dao.GoodsDAO\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt;--\u0026gt; \u0026lt;package name=\u0026#34;com.imooc.mybatis.dao\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 按价格范围查询商品的代码： 在GoodsDAO下写入如下方法：\n@Select(\u0026#34;select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limt}\u0026#34;) public List\u0026lt;Goods\u0026gt; selectByPriceRange(@Param(\u0026#34;min\u0026#34;) Float min, @Param(\u0026#34;max\u0026#34;) Float max, @Param(\u0026#34;limt\u0026#34;) Integer limt); 在MyBatisTestor中使用这个方法:\n@Test public void testSelectByPrice(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List\u0026lt;Goods\u0026gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20); System.out.println(list.size()); } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } } 插入商品的代码： 在GoodsDAO下写入如下方法：\n@Insert(\u0026#34;INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId})\u0026#34;) @SelectKey(statement = \u0026#34;select last_insert_id()\u0026#34;, before = false, keyProperty = \u0026#34;goodsId\u0026#34;, resultType = Integer.class) public int insert(Goods goods); 在MyBatisTestor中使用这个方法:\n@Test public void testInsert() throws Exception { SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(\u0026#34;测试商品\u0026#34;); goods.setSubTitle(\u0026#34;测试子标题\u0026#34;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); int num = goodsDAO.insert(goods); session.commit(); System.out.println(goods.getGoodsId()); } catch (Exception e) { if (session != null){ session.rollback(); } throw e; } finally { MyBatisUtils.closeSession(session); } } 结果映射的代码： 在GoodsDAO下写入如下方法：\n@Select(\u0026#34;select * from t_goods\u0026#34;) //\u0026lt;resultMap\u0026gt; @Results({ @Result(column = \u0026#34;goods_id\u0026#34;, property = \u0026#34;goodsId\u0026#34;, id = true), @Result(column = \u0026#34;title\u0026#34;, property = \u0026#34;title\u0026#34;), @Result(column = \u0026#34;current_price\u0026#34;, property = \u0026#34;currentPrice\u0026#34;) }) public List\u0026lt;GoodsDTO\u0026gt; selectAll(); 在MyBatisTestor中使用这个方法:\n@Test public void selectAll() throws Exception { SqlSession session = null; try { session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List\u0026lt;GoodsDTO\u0026gt; list = goodsDAO.selectAll(); System.out.println(list.size()); } catch (Exception e) { session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } } ","permalink":"https://rexhub.space/posts/back/java/jdbctool/mybatis%E8%BF%9B%E9%98%B6/","summary":"MyBatis进阶 什么是日志 日志文件是用于记录系统操作事件的记录文件或文件集合 日志保存历史数据，是诊断问题以及理解系统活动的重要依据 SLF4j与Logback 日志的使用: 引入logback依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 创建logback.xml，并写入如下代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别（优先级高到低） error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序允许的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;\u0026gt;\u0026lt;/appender-ref\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 动态SQL 动态SQL是指根据参数数据动态组织SQL的技术 代码示例： goods.xml中加入如下sql语句\n\u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;currentPrice !","title":"Mybatis进阶"},{"content":"RESTful开发风格 REST与RESTful REST(Representational State Transfer)-表现层状态转换，资源在网络中以某种表现形式进行状态转移 RESTful是基于REST理念的一套开发风格，是具体的开发规则 RESTful传输数据 RESTful开发规范 使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE-\u0026gt;查|增|改|删) 只返回数据(JSON|XML)，不包含任何展现 RESTful命名要求 URI 说明 修改建议 GET /articles?au=lily 正确用法 GET /a/1 URI必须具有语义 GET /student/1 POST /createArticle/1 URI必须使用名词 POST /article/1 GET /articles/author/1 URI扁平化，不超两级 GET /articles/author?id=1 DELETE /articles/1 URI名词区分单复数 GET /articles?au=lily\nDELETE /article/1 开发第一个RESTful应用 RestfulController.java\npackage com.imooc.restful.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; /** * @author Rex * @create 2021-01-12 12:00 */ @Controller @RequestMapping(\u0026#34;/restful\u0026#34;) public class RestfulController { @GetMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doGetRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;返回查询结果\\\u0026#34;}\u0026#34;; } @PostMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPostRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据新建成功\\\u0026#34;}\u0026#34;; } @PutMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPutRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据更新成功\\\u0026#34;}\u0026#34;; } @DeleteMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doDeleteRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据删除成功\\\u0026#34;}\u0026#34;; } } client.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;RESTful实验室\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./jquery-3.5.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026#34;#btnGet\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnPost\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;post\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnPut\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;put\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnDelete\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;delete\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Get请求\u0026#34; id=\u0026#34;btnGet\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Post请求\u0026#34; id=\u0026#34;btnPost\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Put请求\u0026#34; id=\u0026#34;btnPut\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Delete请求\u0026#34; id=\u0026#34;btnDelete\u0026#34;/\u0026gt; \u0026lt;h1 id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 结果：\n为了解决json乱码问题需要在applicationContext对MediaTypes进行处理\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;text/html; charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;application/json; charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; RestController注解 @RestController = @ResposneBody + @Controller, 默认将String向请求中输出，而不是将请求转发到该路径下\n路径变量(@PathVariable) 路径变量：存放在URI中可变的数值 代码示例： RestfulController.java\n@PostMapping(\u0026#34;/request/{rid}\u0026#34;) public String doPostRequest(@PathVariable(\u0026#34;rid\u0026#34;) Integer requestId){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据新建成功\\\u0026#34;, \\\u0026#34;id\\\u0026#34;:\\\u0026#34;\u0026#34;+requestId+\u0026#34;\\\u0026#34;}\u0026#34;; } client.html\n$(\u0026#34;#btnPost\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request/100\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;post\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message + \u0026#34;:\u0026#34;+json.id); } }) }); 结果：\n简单请求和非简单请求 简单请求是指标准结构的HTTP请求，对应GET/POST请求 非简单请求是指复杂要求的HTTP请求，指PUT/DELETE、扩展标准请求 两者最大区别是非简单请求发送前需要发送预检请求 非简单请求 非简单请求中参数传递 需要配置FormContentFilter过滤器\n代码示例： web.xml\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;formContent\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.FormContentFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;formContent\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; RestfulController.java\n@PutMapping(\u0026#34;/request\u0026#34;) public String doPutRequest(Person person){ System.out.println(person.getName()+\u0026#34;:\u0026#34;+person.getAge()); return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据更新成功\\\u0026#34;}\u0026#34;; } client.html\n$(\u0026#34;#btnPut\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;put\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;data\u0026#34;:\u0026#34;name=lily\u0026amp;age=23\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); 结果：\nJSON序列化 引入jackson-core -\u0026gt; jack核心包 引入jackson-databind-\u0026gt;用于jackson与目标对象交互 引入jackson-annotations用于jackson的注解 tip：日期类型、数字类型、货币类型的处理需要加上@JsonFormat注解，如@JsonFormat(pattern=\u0026quot;\u0026quot;, timezone=\u0026ldquo;GMT+8\u0026rdquo;)\n使用示例： RestController.java\n@GetMapping(\u0026#34;/persons\u0026#34;) public List\u0026lt;Person\u0026gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(\u0026#34;lily\u0026#34;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(\u0026#34;smith\u0026#34;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); return list; } Person.java\npackage com.imooc.restful.entity; import com.fasterxml.jackson.annotation.JsonFormat; import java.util.Date; /** * @author Rex * @create 2021-01-12 14:02 */ public class Person { private String name; private Integer age; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH-mm-ss\u0026#34;, timezone = \u0026#34;GMT+8\u0026#34;) private Date birthday; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } } client.html\n\u0026lt;script\u0026gt; //... $(\u0026#34;#btnPersons\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/persons\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { console.log(json) // $(\u0026#34;#message\u0026#34;).text(json.message); for (var i = 0; i \u0026lt; json.length; i++) { var p = json[i]; $(\u0026#34;#divPersons\u0026#34;).append(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34;+p.name+\u0026#34;-\u0026#34;+p.age+\u0026#34;-\u0026#34;+p.birthday+\u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;) } } }) }); \u0026lt;/script\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPersons\u0026#34; value=\u0026#34;查询所有人员\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;divPersons\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 结果：\n浏览器的跨域访问 浏览器的同源策略 同源策略阻止从一个域加载的脚本去获取另一个域上的资源 只要协议、域名、端口号有任何一个不同，都被当作是不同的域 浏览器Console看到Access-Control-Allow-Origin就代表跨域了 同源策略示例 源URL 目标URL 直接访问？ http://imooc.com https://xxx.com:8080/test 不能 http://imooc.com https://imooc.com 不能 http://imooc.com http://abc.imooc.com 不能 http://imooc.com http://imooc.com:8080 不能 http://localhost http://127.0.0.1 不能 http://imooc.com http://imooc.com/user/test 可以 HTML中允许跨域的标签 \u0026lt;img\u0026gt; - 显示远程图片 \u0026lt;script\u0026gt; - 加载远程JS \u0026lt;link\u0026gt; - 加载远程CSS SpringMVC跨域访问 CORS跨域资源访问 CORS是一种机制，使用额外的HTTP头通知浏览器可以访问其他域 URL响应头包含 Access-Control-*指明请求允许跨域 SpringMVC解决跨域访问 @CrossOrigin - Controller跨域注解\n代码示例：\n80端口下的RestfulController.java：\npackage com.imooc.restful.controller; import com.imooc.restful.entity.Person; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * @author Rex * @create 2021-01-12 12:00 */ @RestController @RequestMapping(\u0026#34;/restful\u0026#34;) //@CrossOrigin(origins = {\u0026#34;http://localhost:8080\u0026#34;, \u0026#34;http://www.imooc.com\u0026#34;}) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600)//匹配每一个URL, maxAge-\u0026gt;设置预检请求的访问时间 public class RestfulController { //.... } 8080端口下的client.html\n$(\u0026#34;#btnPersons\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;http://localhost/restful/persons\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { console.log(json) // $(\u0026#34;#message\u0026#34;).text(json.message); for (var i = 0; i \u0026lt; json.length; i++) { var p = json[i]; $(\u0026#34;#divPersons\u0026#34;).append(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34;+p.name+\u0026#34;-\u0026#34;+p.age+\u0026#34;-\u0026#34;+p.birthday+\u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;) } } }) }); 结果：\n\u0026lt;mvc:cors\u0026gt; - Spring MVC 全局跨域配置\napplicationContext.xml\n\u0026lt;mvc:cors\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/restful/**\u0026#34; allowed-origins=\u0026#34;http://localhost:8080, http://www.imooc.com\u0026#34; max-age=\u0026#34;3600\u0026#34;/\u0026gt; \u0026lt;/mvc:cors\u0026gt; ","permalink":"https://rexhub.space/posts/back/java/framework/springmvc/restful/","summary":"RESTful开发风格 REST与RESTful REST(Representational State Transfer)-表现层状态转换，资源在网络中以某种表现形式进行状态转移 RESTful是基于REST理念的一套开发风格，是具体的开发规则 RESTful传输数据 RESTful开发规范 使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE-\u0026gt;查|增|改|删) 只返回数据(JSON|XML)，不包含任何展现 RESTful命名要求 URI 说明 修改建议 GET /articles?au=lily 正确用法 GET /a/1 URI必须具有语义 GET /student/1 POST /createArticle/1 URI必须使用名词 POST /article/1 GET /articles/author/1 URI扁平化，不超两级 GET /articles/author?id=1 DELETE /articles/1 URI名词区分单复数 GET /articles?au=lily\nDELETE /article/1 开发第一个RESTful应用 RestfulController.java\npackage com.imooc.restful.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; /** * @author Rex * @create 2021-01-12 12:00 */ @Controller @RequestMapping(\u0026#34;/restful\u0026#34;) public class RestfulController { @GetMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doGetRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;返回查询结果\\\u0026#34;}\u0026#34;; } @PostMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPostRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据新建成功\\\u0026#34;}\u0026#34;; } @PutMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPutRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据更新成功\\\u0026#34;}\u0026#34;; } @DeleteMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doDeleteRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据删除成功\\\u0026#34;}\u0026#34;; } } client.","title":"Restful开发风格"},{"content":"Spring MVC Spring MVC介绍 MVC是什么 Spring MVC Spring MVC是Spring体系的轻量级WEB MVC框架 Spring MVC的核心Controller控制器，用于处理请求，产生响应 Spring MVC基于Spring IoC容器运行，所有对象被IoC管理 Spring 5.X版本变化 Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+) Spring 5.x支持JDK8/9,可以使用新特性 Spring 5.x最重要的新特性支持响应式编程 Spring MVC环境配置 Maven依赖spring-webmvc web.xml配置DispatcherServlet 配置applicationContext的mvc标记 开发Controller控制器 简单示例： applicationContext.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mv=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中，自动创建并管理com.imooc.springmvc及子包 拥有以下注解的对象 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc.springmvc\u0026#34;/\u0026gt; \u0026lt;!--启用Spring MVC的注解开发模式--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--将图片/JS/CSS等静态资源排除在外，可提高执行效率--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;/beans\u0026gt; web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\u0026#34; version=\u0026#34;3.1\u0026#34;\u0026gt; \u0026lt;!--DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- DispatcherServlet是Spring MVC最核心的对象 DispatcherServlet用于拦截Http请求, 并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理 --\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--applicationContext.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 在Web应用启动时自动创建Spring IOC容器, 并初始化DispatcherServlet --\u0026gt; \u0026lt;load-on-startup\u0026gt;0\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!--\u0026#34;/\u0026#34; 代表拦截所有请求--\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; TestController.java\npackage com.imooc.springmvc.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; /** * @author Rex * @create 2021-01-08 16:59 */ @Controller public class TestController { @GetMapping(\u0026#34;/t\u0026#34;) @ResponseBody //直接向响应输出字符串数据，不跳转页面 public String test(){ return \u0026#34;HELLO WORLD\u0026#34;; } } 结果： Spring MVC数据绑定 URL Mapping URL Mapping指将URL与Controller方法绑定 通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务 URL Mapping注解 @RequestMapping - 通用绑定 @GetMapping - 绑定Get请求 @PostMapping - 绑定Post请求 接受请求参数的常用做法 使用Controller方法参数接受（@RequestParam） 使用Java Bean接受数据 接受表单复合数据 利用数组或者List接受请求中给的复合数据 利用@RequestParam为参数设置默认值 使用Map对象接受请求参数及注意事项 关联对象赋值 日期类型转换 @DateTimeFormat\n自定义转换器\nMyDateConverter.java\npackage com.imooc.springmvc.converter; import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-09 10:34 */ public class MyDateConverter implements Converter\u0026lt;String, Date\u0026gt; { @Override public Date convert(String s) { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); try { Date d = sdf.parse(s); return d; } catch (ParseException e) { return null; } } } applicationContext.xml\n\u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;conversionService\u0026#34; class=\u0026#34;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;converters\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;bean class=\u0026#34;com.imooc.springmvc.converter.MyDateConverter\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; tip: @DateTimeFormat和自定义转换器最好不要同时使用，spring会优先使用自定义转换器\n解决中文乱码问题 Web应用的中文乱码由来 Tomcat默认使用字符集ISO-8859-1，属于西欧字符集 解决乱码的核心思路是将ISO-8859-1转换为UTF-8 Controller中请求与响应都需要设置UTF-8字符集 中文乱码的配置 Get请求乱码-server.xml增加URIEncoding属性\nPost请求乱码-web.xml配置CharacterEncodingFilter\nResponse响应乱码-Spring配置StringHttpMessageConverter\n示例代码：\nweb.xml\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; applicationContext.xml\n\u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;!--response.setContentType(\u0026#34;text/html; charset=utf-8\u0026#34;)--\u0026gt; \u0026lt;value\u0026gt;text/html;charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 响应输出 响应中产生结果 @ResponseBody - 产生响应文本 ModelAndView - 利用模板引擎渲染输出 @ResponseBody @ResponseBody直接产生响应体的数据，过程中不产生任何视图 @ResponseBody可产生标准字符串/JSON/XML等格式数据 @ResponseBody被StringHttpMessageConverty所影响 ModelAndView概述 ModelAndView是指“模型(数据)与视图(界面)”对象 通过ModelAndView可将数据对象与模板引擎进行绑定 SpringMVC中默认的View是JSP，也可以配置其他模板引擎 使用示例： URLMappingController.java\n@GetMapping(\u0026#34;/view\u0026#34;) public ModelAndView showView(Integer userId){ ModelAndView mav = new ModelAndView(\u0026#34;/view.jsp\u0026#34;); User user = new User(); if (userId == 1){ user.setUsername(\u0026#34;lily\u0026#34;); }else if(userId == 2){ user.setUsername(\u0026#34;smith\u0026#34;); }else if(userId == 3){ user.setUsername(\u0026#34;lina\u0026#34;); } mav.addObject(\u0026#34;u\u0026#34;, user); return mav; } view.jsp\n\u0026lt;%-- Created by IntelliJ IDEA. User: CubeMonkey Date: 2021/1/9 Time: 11:27 Email:2192231938@qq.com To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;View\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;I\u0026#39;m view page\u0026lt;/h1\u0026gt;\u0026lt;hr/\u0026gt; \u0026lt;h2\u0026gt;Username:${u.username}\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ModelAndView方法 mav.addObject()方法设置的属性默认存放在当前请求中 默认ModelAndView使用请求转发(forward)至页面 重定向使用new ModelAndView(\u0026ldquo;redirect:/index.jsp\u0026rdquo;) String+ModelMap 实现ModelAndView（常见） 示例代码: //String 与 ModelMap //Controller方法返回String的情况 //1. 方法被@ResponseBody描述，SpringMVC直接响应String字符串本身 //2. 方法不存在@ResponseBody，则SpringMVC处理String指代的视图(页面) @GetMapping(\u0026#34;/xxxx\u0026#34;) @ResponseBody public String showView1(Integer userId, ModelMap modelMap){ String view = \u0026#34;/view.jsp\u0026#34;; User user = new User(); if (userId == 1){ user.setUsername(\u0026#34;lily\u0026#34;); }else if(userId == 2){ user.setUsername(\u0026#34;smith\u0026#34;); }else if(userId == 3){ user.setUsername(\u0026#34;lina\u0026#34;); } modelMap.addAttribute(\u0026#34;u\u0026#34;, user); return view; } SpringMVC整合Freemarker pom.xml引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 启用Freemarker模板引擎(FreeMarkerViewResolver)\n\u0026lt;bean id=\u0026#34;ViewReslover\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\u0026#34;\u0026gt; \u0026lt;!--向客户端输出内容的时候设置的字符集--\u0026gt; \u0026lt;property name=\u0026#34;contentType\u0026#34; value=\u0026#34;text/html;charset=utf-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.ftl\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 配置Freemarker参数(FreemarkerConfigurer)\n\u0026lt;bean id=\u0026#34;freemarkerConfig\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;templateLoaderPath\u0026#34; value=\u0026#34;/WEB-INF/ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;freemarkerSettings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!--为产生结果的时候的字符集--\u0026gt; \u0026lt;prop key=\u0026#34;defaultEnocding\u0026#34;\u0026gt;UTF-8\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 使用Freemarker\ntest.ftl\n\u0026lt;h1\u0026gt;${u.username}\u0026lt;/h1\u0026gt; FreemarkerController.java\npackage com.imooc.springmvc.controller; import com.imooc.springmvc.entity.User; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; /** * @author Rex * @create 2021-01-09 14:25 */ @Controller @RequestMapping(\u0026#34;/fm\u0026#34;) public class FreemarkerController { @GetMapping(\u0026#34;/test\u0026#34;) public ModelAndView showTest(){ ModelAndView mav = new ModelAndView(\u0026#34;/test\u0026#34;); User user = new User(); user.setUsername(\u0026#34;andy\u0026#34;); mav.addObject(\u0026#34;u\u0026#34;, user); return mav; } } ","permalink":"https://rexhub.space/posts/back/java/framework/springmvc/springmvc%E5%9F%BA%E7%A1%80/","summary":"Spring MVC Spring MVC介绍 MVC是什么 Spring MVC Spring MVC是Spring体系的轻量级WEB MVC框架 Spring MVC的核心Controller控制器，用于处理请求，产生响应 Spring MVC基于Spring IoC容器运行，所有对象被IoC管理 Spring 5.X版本变化 Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+) Spring 5.x支持JDK8/9,可以使用新特性 Spring 5.x最重要的新特性支持响应式编程 Spring MVC环境配置 Maven依赖spring-webmvc web.xml配置DispatcherServlet 配置applicationContext的mvc标记 开发Controller控制器 简单示例： applicationContext.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mv=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中，自动创建并管理com.imooc.springmvc及子包 拥有以下注解的对象 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc.springmvc\u0026#34;/\u0026gt; \u0026lt;!--启用Spring MVC的注解开发模式--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--将图片/JS/CSS等静态资源排除在外，可提高执行效率--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;/beans\u0026gt; web.xml\n\u0026lt;?xml version=\u0026#34;1.","title":"SpringMVC基础"},{"content":"SpringMVC拦截器 拦截器-Interceptor 拦截器(Interveptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring AOP面向切面编程实现 拦截器开发流程 Maven依赖servlet-api\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 实现HandlerInterceptor\npackage com.imooc.restful.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author Rex * @create 2021-01-12 17:55 */ public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-准备执行\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-目标处理成功\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-响应内容已产生\u0026#34;); } } applicationContext配置过滤地址\n\u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.imooc.restful.interceptor.MyInterceptor\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 执行结果\nHandlerInterceptor接口 preHandle - 前置执行处理 postHandle - 目标资源已被Spring MVC框架处理 afterCompletion - 响应文本已经产生 多Interceptor执行先后顺序 ","permalink":"https://rexhub.space/posts/back/java/framework/springmvc/springmvc%E6%8B%A6%E6%88%AA%E5%99%A8/","summary":"SpringMVC拦截器 拦截器-Interceptor 拦截器(Interveptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring AOP面向切面编程实现 拦截器开发流程 Maven依赖servlet-api\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 实现HandlerInterceptor\npackage com.imooc.restful.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author Rex * @create 2021-01-12 17:55 */ public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-准备执行\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.","title":"SpringMVC拦截器"},{"content":"Redis入门 Redis介绍 Redis是Key-Value型NoSQL数据库 Redis将数据存储在内存中，同时也能持久化到磁盘 Redis常用于缓存，利用内存的高效提高程序的处理速度 Redis特点 速度快 持久化 主从复制 广泛的语言支持 多种数据结构 分布式与高可用 Redis的安装与使用 在Linux系统中安装Redis https://redis.io/download\n在windows系统中安装Redis https://github.com/microsoftarchive/redis/releases\nRedis的常用基本配置 配置项 示例 说明 daemonize daemonize yes 是否启用后台允许，默认no port port 6379 设置端口号，默认6379 logfile logfile 日志文件 设置日志文件 databases databases 255 设置redis数据库总量 dir dir数据文件目录 设置数据文件存储目录 requirepass requirepass 12345 设置使用密码 Redis通用命令 命令 示例 说明 select select 0 选择0号数据库 set set name lily 设置key=name,value=lily get get hello 获得key=hello结果 keys keys he* 根据Pattern表达式查询符合条件的Key dbsize dbsize 返回key的总数 exists exists a 检查key=a是否存在 del del a 删除key=a的数据 expire expire hello 20 设置key=hello 20秒后过期 ttl ttl 查看key=a的过期剩余时间 Redis数据类型 String - 字符串类型 Hash - Hash类型 List - 列表类型 Set - 集合类型 Zset - 有序集合类型 String字符串类型 String最大512mb 建议单个kv不超过100kb\n字符串命令\n命令 示例 说明 get get hello 获得key=hello结果 set set hello world 设置key=hello，value=hello mset\nmget mset hello world java best\nmget hello java 一次性设置或者获取多个值 del del hello 删除key=hello incr/decr incr count\ndecr count key值自增/自减1 incrby/decrby incrby count 99\ndecrby count 99 自增自减指定步长 Hash键值类型 Hash类型用于存储结构化数据 Hash命令 命令 示例 说明 hget hget emp:1 age 获取hash中key=age的值 hset hset emp:1 age 23 设置hash中age=23 hmset\nhmget\nhgetall hmset emp:1 age 30 name kaka\nhmget emp:1 age name\nhgetall emp:1 name 设置hash多个值\n获取hash多个值\n获取hash所有值 hdel hdel emp:1 age 删除emp:1的age hexists hexists emp:1 name 检查是否存在 hlen hlen emp:1 获取指定长度 List列表类型 List列表就是一系列字符串的“数组”，按插入顺序排序\nList列表最大长度为2的32次方-1，可以包含40亿个元素\nList命令\n​\n命令 示例 说明 rpush rpush listkey c b a 右侧插入 lpush lpush listkey f e d 左侧插入 rpop rpop listkey 右侧插入 lpop lpop listkey 左侧插入 Set与Zset集合类型 Set集合是字符串的无序集合，集合成员是唯一的 Zset集合是字符串的有序集合，集合成员是唯一的 Java客户端-Jedis Jedis是Java语言开发的Redis客户端工具包 Jedis只是对Redis命令的封装，掌握Redis命令便可轻易上手 ","permalink":"https://rexhub.space/posts/nosql/redis%E5%9F%BA%E7%A1%80/","summary":"Redis入门 Redis介绍 Redis是Key-Value型NoSQL数据库 Redis将数据存储在内存中，同时也能持久化到磁盘 Redis常用于缓存，利用内存的高效提高程序的处理速度 Redis特点 速度快 持久化 主从复制 广泛的语言支持 多种数据结构 分布式与高可用 Redis的安装与使用 在Linux系统中安装Redis https://redis.io/download\n在windows系统中安装Redis https://github.com/microsoftarchive/redis/releases\nRedis的常用基本配置 配置项 示例 说明 daemonize daemonize yes 是否启用后台允许，默认no port port 6379 设置端口号，默认6379 logfile logfile 日志文件 设置日志文件 databases databases 255 设置redis数据库总量 dir dir数据文件目录 设置数据文件存储目录 requirepass requirepass 12345 设置使用密码 Redis通用命令 命令 示例 说明 select select 0 选择0号数据库 set set name lily 设置key=name,value=lily get get hello 获得key=hello结果 keys keys he* 根据Pattern表达式查询符合条件的Key dbsize dbsize 返回key的总数 exists exists a 检查key=a是否存在 del del a 删除key=a的数据 expire expire hello 20 设置key=hello 20秒后过期 ttl ttl 查看key=a的过期剩余时间 Redis数据类型 String - 字符串类型 Hash - Hash类型 List - 列表类型 Set - 集合类型 Zset - 有序集合类型 String字符串类型 String最大512mb 建议单个kv不超过100kb","title":"Redis基础"},{"content":"Spring JDBC与事务管理 Spring JDBC Spring JDBC是Spring框架用于处理关系型数据库的模块 Spring JDBC对JDBC API进行封装，极大简化开发工作量 JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法 Spring JDBC的使用步骤 Maven工程引入依赖spring-jdbc applicationContext.xml配置DataSource数据源 在Dao注入JdbcTemplate对象，实现数据CRUD JdbcTemplate实现增删改查 Spring JDBC配置过程代码示例： applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate提供CRUD的API--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.dao.EmployeeDao\u0026#34;\u0026gt; \u0026lt;!--为Dao注入JdbcTemplate对象--\u0026gt; \u0026lt;property name=\u0026#34;jdbcTemplate\u0026#34; ref=\u0026#34;jdbcTemplate\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Employee.java\npackage com.imooc.spring.jdbc.entity; import java.util.Date; /** * @author Rex * @create 2021-01-05 14:44 */ public class Employee { private Integer eno; private String ename; private Float salary; private String dname; private Date hiredate; public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } public Date getHiredate() { return hiredate; } public void setHiredate(Date hiredate) { this.hiredate = hiredate; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;eno=\u0026#34; + eno + \u0026#34;, ename=\u0026#39;\u0026#34; + ename + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#34;, dname=\u0026#39;\u0026#34; + dname + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, hiredate=\u0026#34; + hiredate + \u0026#39;}\u0026#39;; } } EmployeeDao.java\npackage com.imooc.spring.jdbc.dao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; /** * @author Rex * @create 2021-01-05 14:46 */ @Repository public class EmployeeDao { private JdbcTemplate jdbcTemplate; public Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public JdbcTemplate getJdbcTemplate() { return jdbcTemplate; } public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } } SpringApplication.java\npackage com.imooc.spring.jdbc; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-05 14:52 */ public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); EmployeeDao employeeDao = context.getBean(\u0026#34;employeeDao\u0026#34;, EmployeeDao.class); Employee employee = employeeDao.findById(3308); System.out.println(employee); } } JDBC Template的数据查询代码示例： EmployeeDao.java\npublic Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; //查询单条数据 Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public List\u0026lt;Employee\u0026gt; findByDname(String dname){ String sql = \u0026#34;select * from Employee where dname = ?\u0026#34;; //查询复合数据 List\u0026lt;Employee\u0026gt; list = jdbcTemplate.query(sql, new Object[]{dname}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return list; } public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; findMapByDname(String dname){ String sql = \u0026#34;select eno as empno, salary as s from employee where dname=?\u0026#34;; //将查询结果作为Map进行封装 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; maps = jdbcTemplate.queryForList(sql, new Object[]{dname}); return maps; } 单条查询测试\n@Test public void testFindById(){ Employee employee = employeeDao.findById(3308); System.out.println(employee); } 查询结果：\n[Employee{eno=3308, ename=\u0026#39;张三\u0026#39;, salary=6000.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2011-05-08 00:00:00.0}, Employee{eno=3420, ename=\u0026#39;李四\u0026#39;, salary=8700.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2006-11-11 00:00:00.0}] 多条记录查询测试\n@Test public void testFindByDname(){ List\u0026lt;Employee\u0026gt; list = employeeDao.findByDname(\u0026#34;研发部\u0026#34;); System.out.println(list); } 查询结果：\nEmployee{eno=3308, ename=\u0026#39;张三\u0026#39;, salary=6000.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2011-05-08 00:00:00.0} 将查询结果以Map作为封装测试\n@Test public void testFindMapByDname(){ System.out.println(employeeDao.findMapByDname(\u0026#34;研发部\u0026#34;)); } 查询结果：\n[{empno=3308, s=6000.0}, {empno=3420, s=8700.0}] JdbcTemplate数据写入代码示例 数据新增：\npublic int insert(Employee employee){ String sql = \u0026#34;insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)\u0026#34;; //利用update方法实现数据写入操作 return jdbcTemplate.update(sql, new Object[]{employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()}); } 测试代码：\n@Test public void testInsert(){ Employee employee = new Employee(); employee.setEno(8888); employee.setEname(\u0026#34;赵六\u0026#34;); employee.setSalary(6666f); employee.setDname(\u0026#34;研发部\u0026#34;); employee.setHiredate(new Date()); int count = employeeDao.insert(employee); System.out.println(\u0026#34;本次新增\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次插入1条数据 数据修改：\npublic int update(Employee employee){ String sql = \u0026#34;update employee set ename = ?, salary = ?, dname = ?, hiredate = ? where eno = ?\u0026#34;; int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()}); return count; } 测试代码：\n@Test public void testUpdate(){ Employee employee = employeeDao.findById(8888); employee.setSalary(employee.getSalary()+1000f); int count = employeeDao.update(employee); System.out.println(\u0026#34;本次更新\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次更新1条数据 数据删除：\npublic int delete(Integer eno){ String sql = \u0026#34;delete from employee where eno = ?\u0026#34;; return jdbcTemplate.update(sql, new Object[]{eno}); } 测试代码：\n@Test public void testDelete(){ int count = employeeDao.delete(8888); System.out.println(\u0026#34;本次删除\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次删除1条数据 Spring编程式事务 什么是事务 事务以一种可靠的、一致的方式，访问和造作数据库的程序单元 说人话：要么把事情做完，要么什么都不做，不要做一半 事务依赖于数据库实现，MySQL通过事务区作为数据缓冲地带 编程式事务 编程式事务是指通过代码手动提交回滚事务的事务控制方法 SpringJDBC通过TransactionManage事务管理器实现事务控制 事务管理器提供commit/rollback方法进行事务提交与回滚 代码示例： ApplicationContext.xml\n\u0026lt;bean id=\u0026#34;employeeService\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.service.EmployeeService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;employeeDao\u0026#34; ref=\u0026#34;employeeDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.TransactionDefinition; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.DefaultTransactionDefinition; import java.util.Date; /** * @author Rex * @create 2021-01-05 16:31 */ public class EmployeeService { private EmployeeDao employeeDao; private DataSourceTransactionManager transactionManager; public void batchImport(){ //定义了事务默认的标准配置 TransactionDefinition definition = new DefaultTransactionDefinition(); //开始一个事务 TransactionStatus status = transactionManager.getTransaction(definition); try { for (int i = 0; i \u0026lt; 10; i++) { if ( i == 3) { throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } // //提交事务 transactionManager.commit(status); }catch (RuntimeException e){ transactionManager.rollback(status); throw e; } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } public DataSourceTransactionManager getTransactionManager() { return transactionManager; } public void setTransactionManager(DataSourceTransactionManager transactionManager) { this.transactionManager = transactionManager; } } JdbcTemplateTestor.java\n@Test public void testBatchImport(){ employeeService.batchImport(); System.out.println(\u0026#34;批量导入成功\u0026#34;); } 测试结果：\n... 16:55:40.411 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.490 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.405\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.498 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update 16:55:40.498 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.502 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.498\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.502 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update 16:55:40.503 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.507 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.502\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.507 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback 16:55:40.507 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@3646a422] 16:55:40.521 [main] DEBUG ... java.lang.RuntimeException: 意料之外的异常... Spring声明式事务 声明式事务 声明式事务指在不修改源码情况下通过配置形式自动实现事务控制，声明式事务本质就是AOP环绕通知 当目标方法执行成功时，自动提交事务 当目标方法抛出运行时异常时，自动事务回滚 配置过程 配置TransactionManager事务管理器 配置事务通知与事务属性 为事务通知绑定PointCut切点 代码示例： applicationContext.xml\n\u0026lt;!--1.事务管理器，用于创建事务/提交/回滚--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--2.事务通知配置，决定哪些方法使用事务，哪些方法不使用事务--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--目标方法名为batchImport时，启用声明式事务，成功提交，运行时异常回滚--\u0026gt; \u0026lt;tx:method name=\u0026#34;batchImport\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;batch*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;\u0026gt;\u0026lt;/tx:method\u0026gt; \u0026lt;!--设置所有findXXX方法不需要使用事务--\u0026gt; \u0026lt;tx:method name=\u0026#34;find*\u0026#34; propagation=\u0026#34;NOT_SUPPORTED\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;get*\u0026#34; propagation=\u0026#34;NOT_SUPPORTED\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--3.定义声明式事务的作用范围--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(public * com.imooc..*Service.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; \u0026lt;/aop:config\u0026gt; EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import java.util.Date; public class EmployeeService { private EmployeeDao employeeDao; public void batchImport() { for (int i = 1; i \u0026lt;= 10; i++) { if(i == 3){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } 执行结果： 同上\n事务传播行为 事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式 XML：\u0026lt;tx:method name=\u0026quot;\u0026hellip;\u0026quot; propagation=\u0026ldquo;REQUIRED\u0026rdquo;\u0026gt; 注解：@Transactional(propagation=Propagation.REQUIRED) 事务传播行为七种类型 事务传播类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务，加入到这个事务中。这是最常见的选择 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行 PROPAGATION_MANADATORY 使用当前的事务，如果当前没有事务，就抛出异常 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，就把当前事务挂起 PROPAGATION_NOT_SUPPORT 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作 Spring注解配置声明式事务 代码示例 applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;/\u0026gt; \u0026lt;!--数据源--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;usePublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--启用注解形式声明式事务--\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionManager\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; Employee.java\npackage com.imooc.spring.jdbc.entity; import java.util.Date; public class Employee { private Integer eno; private String ename; private Float salary; private String dname; private Date hiredate; public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } public Date getHiredate() { return hiredate; } public void setHiredate(Date hiredate) { this.hiredate = hiredate; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;eno=\u0026#34; + eno + \u0026#34;, ename=\u0026#39;\u0026#34; + ename + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#34;, dname=\u0026#39;\u0026#34; + dname + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, hiredate=\u0026#34; + hiredate + \u0026#39;}\u0026#39;; } } EmployeeDao.java\npackage com.imooc.spring.jdbc.dao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; import java.util.Map; @Repository public class EmployeeDao { @Resource private JdbcTemplate jdbcTemplate; public Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; //查询单条数据 Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public List\u0026lt;Employee\u0026gt; findByDname(String dname){ String sql = \u0026#34;select * from employee where dname = ?\u0026#34;; //查询复合数据 List\u0026lt;Employee\u0026gt; list = jdbcTemplate.query(sql, new Object[]{dname}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return list; } public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; findMapByDname(String dname){ String sql = \u0026#34;select eno as empno , salary as s from employee where dname = ?\u0026#34;; //将查询结果作为Map进行封装 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; maps = jdbcTemplate.queryForList(sql, new Object[]{dname}); return maps; } public void insert(Employee employee){ String sql = \u0026#34;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)\u0026#34;; //利用update方法实现数据写入操作 jdbcTemplate.update(sql,new Object[]{ employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate() }); } public int update(Employee employee){ String sql = \u0026#34;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?\u0026#34;; int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()}); return count; } public int delete(Integer eno){ String sql = \u0026#34;delete from employee where eno = ?\u0026#34;; return jdbcTemplate.update(sql, new Object[]{eno}); } public JdbcTemplate getJdbcTemplate() { return jdbcTemplate; } public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } } BatchService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service @Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true) public class BatchService { @Resource private EmployeeDao employeeDao; @Transactional(propagation = Propagation.REQUIRES_NEW) public void importJob1(){ for (int i = 1; i \u0026lt;= 10; i++) { Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;研发部员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;研发部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } @Transactional(propagation = Propagation.REQUIRES_NEW) public void importJob2(){ for (int i = 1; i \u0026lt;= 10; i++) { Employee employee = new Employee(); employee.setEno(9000 + i); employee.setEname(\u0026#34;市场部员工\u0026#34; + i); employee.setSalary(4500f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service //声明式事务核心注解 //放在类上，将声明式事务配置应用于当前类所有方法，默认事务传播为REQUIRED @Transactional public class EmployeeService { @Resource private EmployeeDao employeeDao; @Resource private BatchService batchService; @Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true) public Employee findById(Integer eno){ return employeeDao.findById(eno); } public void batchImport() { for (int i = 1; i \u0026lt;= 10; i++) { /*if(i==3){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); }*/ Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public void startImportJob(){ batchService.importJob1(); if(1==1){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } batchService.importJob2(); System.out.println(\u0026#34;批量导入成功\u0026#34;); } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } public BatchService getBatchService() { return batchService; } public void setBatchService(BatchService batchService) { this.batchService = batchService; } } ","permalink":"https://rexhub.space/posts/back/java/framework/spring/springjdbc/","summary":"Spring JDBC与事务管理 Spring JDBC Spring JDBC是Spring框架用于处理关系型数据库的模块 Spring JDBC对JDBC API进行封装，极大简化开发工作量 JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法 Spring JDBC的使用步骤 Maven工程引入依赖spring-jdbc applicationContext.xml配置DataSource数据源 在Dao注入JdbcTemplate对象，实现数据CRUD JdbcTemplate实现增删改查 Spring JDBC配置过程代码示例： applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate提供CRUD的API--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.dao.EmployeeDao\u0026#34;\u0026gt; \u0026lt;!--为Dao注入JdbcTemplate对象--\u0026gt; \u0026lt;property name=\u0026#34;jdbcTemplate\u0026#34; ref=\u0026#34;jdbcTemplate\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Employee.java\npackage com.","title":"Springjdbc"},{"content":"Spring 框架概述 1、Spring 是轻量级的开源的JavaEE框架 2、Spring 解决企业应用开发的复杂性 3、Spring有两个核心的部分：IOC和AOP （1）IOC：控制反转，把创建对象的过程交给Spring进行管理 （2）AOP：面向切面，不修改源代码进行功能增强 4、Spring特点 （1）方便解耦，简化开发 （2）AOP编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低API的开发难度 Core Container Beans Core Context Expression ","permalink":"https://rexhub.space/posts/back/java/framework/spring/spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/","summary":"Spring 框架概述 1、Spring 是轻量级的开源的JavaEE框架 2、Spring 解决企业应用开发的复杂性 3、Spring有两个核心的部分：IOC和AOP （1）IOC：控制反转，把创建对象的过程交给Spring进行管理 （2）AOP：面向切面，不修改源代码进行功能增强 4、Spring特点 （1）方便解耦，简化开发 （2）AOP编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低API的开发难度 Core Container Beans Core Context Expression ","title":"Spring框架概述"},{"content":"Spring AOP面向切面编程 Spring AOP Spring AOP - Aspect Oriented Programming 面向切面编程 AOP的做法是将通用、于业务无关的功能抽象封装为切面类 切面可配置在目标方法的执行前、后运行，真正做到即插即用 Spring AOP 用到的依赖dependency：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; applicationContext.xml中schema依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- bean definitions here --\u0026gt; \u0026lt;/beans\u0026gt; Spring AOP概念 Spring AOP与AspectJ的关系 Eclipse AspectJ，一种基于Java平台的面向切面编程的语言 Spring AOP使用AspectJWeaver实现类与方法的匹配 Spring AOP利用代理模式实现对象运行时功能扩展 几个关键概念 注解 说明 Aspect 切面，具体的可插拔组件功能类，通常一个切面只实现一个通用功能 Target Class/Method 目标类、目标方法，指真正要执行与业务相关的方法 PointCut 切入点，使用execution表达式说明切面要作用在系统的哪些类上 JoinPoint 连接点，切面运行过程中时包括了目标类/方法元数据的对象 Advice 通知，说明具体的切面的执行时机，Spring包含了五种不同类型通知 AOP配置过程 依赖AspectJ 实现切面类/方法 配置Aspect Bean 定义PointCut 配置Advice JoinPoint核心方法 注解 说明 Object getTarget() 获取IoC容器内目标对象 Signature getSignature() 获取目标方法 Object[] getArgs() 获取目标方法参数 PointCut切点表达式 通知 五种通知类型 注解 说明 Before Advice 前置通知，目标方法运行前执行 After Returning Advice 返回后通知，目标方法返回数据后执行 After Throwing Advice 异常通知，目标方法抛出异常后执行 After Advice 后置通知，目标方法运行 Around Advice 最强大通知，自定义通知执行时机，可决定目标方法是否运行 特殊的“通知”-引介增强 引介增强(Introduction Interceptor)是对类的增强，而非方法 引介增强允许在运行时为目标类增加新属性或方法 引介增强允许在运行时改变类的行为，让类随运行环境动态变更 Spring AOP实现原理 Spring基于代理模式实现功能动态扩展，包含俩种形式 目标类拥有接口，通过JDK动态代理实现功能扩展 目标类没有接口，通过CGLib组件实现功能扩展 代理模式： 代理模式通过代理对象对原对象的实现功能扩展 静态代理示例： UserService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public interface UserService { public void createUser(); } UserService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println(\u0026#34;执行创建用户业务逻辑\u0026#34;); } } UserServiceProxy.java\npackage com.imooc.spring.aop.service; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-05 11:49 */ //静态代理是指必须手动创建代理类的代理模式使用方式 public class UserServiceProxy implements UserService{ //持有委托类的对象 private UserService userService; public UserServiceProxy(UserService userService){ this.userService = userService; } @Override public void createUser() { System.out.println(\u0026#34;======\u0026#34; + new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;).format(new Date()) +\u0026#34;==========\u0026#34;); this.userService.createUser(); } } UserServiceProxy1.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:54 */ public class UserServiceProxy1 implements UserService { private UserService userService; public UserServiceProxy1(UserService userService){ this.userService = userService; } @Override public void createUser() { userService.createUser(); System.out.println(\u0026#34;=======后置扩展功能======\u0026#34;); } } 运行结果：\n======2021-01-05 12:28:08 008========== 执行创建用户业务逻辑 =======后置扩展功能====== 动态代理示例 UserSerivce.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public interface UserService { public void createUser(); } UserServiceImpl.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println(\u0026#34;执行创建用户业务逻辑\u0026#34;); } } EmployeeService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 12:20 */ public interface EmployeeService { public void createEmployee(); } EmployeeServiceImpl.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 12:20 */ public class EmployeeServiceImpl implements EmployeeService{ @Override public void createEmployee() { System.out.println(\u0026#34;执行创建员工实现类\u0026#34;); } } ProxyInvocationHandler.java\npackage com.imooc.spring.aop.service; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.text.SimpleDateFormat; import java.util.Date; /** * InvocationHandler是JDK提供的反射类，用于在JDK动态代理中对目标方法进行增强 * InvocationHandler实现类与切面类的的环绕通知类似 * @author Rex * @create 2021-01-05 12:06 */ public class ProxyInvocationHandler implements InvocationHandler { private Object target; //目标对象 private ProxyInvocationHandler(Object target){ this.target = target; } /** * 在invoke()方法对目标方法进行增强 * @param proxy 代理类对象 * @param method 目标方法对象 * @param args 目标方法实参 * @return 目标方法运行后返回值 * @throws Throwable 目标方法抛出的异常 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;======\u0026#34; +new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;).format(new Date()) + \u0026#34;======\u0026#34;); Object ret = method.invoke(target, args);//调用目标方法， ProceedingJoinPoint.proceed() return ret; } public static void main(String[] args) { UserService userService = new UserServiceImpl(); ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler(userService); //动态创建代理类 UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), proxyInvocationHandler); userServiceProxy.createUser(); //动态代理，必须实现接口才可以运行 EmployeeService employeeService = new EmployeeServiceImpl(); EmployeeService employeeServiceProxy = (EmployeeService) Proxy.newProxyInstance(employeeService.getClass().getClassLoader(), employeeService.getClass().getInterfaces(), new ProxyInvocationHandler(employeeService)); employeeServiceProxy.createEmployee(); } } 运行结果：\n======2021-01-05 12:23:20 020====== 执行创建用户业务逻辑 ======2021-01-05 12:23:20 020====== 执行创建员工实现类 CGLib实现代理类 CGLib是运行时字节码增强技术 Spring AOP扩展无接口类使用CGLib AOP会运行时生成目标继承类字节码的方式进行行为扩展 AOP代码实例： XML形式 applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.imooc.spring.aop.dao.UserDao\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.aop.dao.EmployeeDao\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.imooc.spring.aop.service.UserService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeService\u0026#34; class=\u0026#34;com.imooc.spring.aop.service.EmployeeService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;employeeDao\u0026#34; ref=\u0026#34;employeeDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;methodChecker\u0026#34; class=\u0026#34;com.imooc.spring.aop.aspect.MethodChecker\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.imooc..*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;methodChecker\u0026#34;\u0026gt; \u0026lt;aop:around method=\u0026#34;check\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:around\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; UserDao.java\npackage com.imooc.spring.aop.dao; /** * 用户表Dao */ public class UserDao { public void insert(){ System.out.println(\u0026#34;新增用户数据\u0026#34;); } } EmployeeDao.java\npackage com.imooc.spring.aop.dao; /** * 员工表Dao * @author Rex * @create 2021-01-04 23:20 */ public class EmployeeDao { public void insert(){ System.out.println(\u0026#34;新增员工数据\u0026#34;); } } Userervice.java\npackage com.imooc.spring.aop.service; import com.imooc.spring.aop.dao.UserDao; /** * 用户服务 * @author Rex * @create 2021-01-04 22:46 */ public class UserService { private UserDao userDao; public void createUser(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;执行员工入职业务逻辑\u0026#34;); userDao.insert(); } public String generateRandomPassword(String type, Integer length){ System.out.println(\u0026#34;按\u0026#34; + type + \u0026#34;方式生成\u0026#34; + length + \u0026#34;位随机密码\u0026#34;); return \u0026#34;Zxcquil\u0026#34;; } public UserDao getUserDao() { return userDao; } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } EmployeeService.java\npackage com.imooc.spring.aop.service; import com.imooc.spring.aop.dao.EmployeeDao; /** * 员工服务 * @author Rex * @create 2021-01-04 23:20 */ public class EmployeeService { private EmployeeDao employeeDao; public void entry(){ System.out.println(\u0026#34;执行员工入职业务逻辑\u0026#34;); employeeDao.insert(); } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } MethodCheck.java\npackage com.imooc.spring.aop.aspect; import org.aspectj.lang.ProceedingJoinPoint; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-04 23:07 */ public class MethodChecker { //ProceedingJoinPoint是JoinPoint的升级版，在原有功能外，还可以控制目标方法是否执行 public Object check(ProceedingJoinPoint pjp) throws Throwable { try { long startTime = new Date().getTime(); Object ret = pjp.proceed();//执行目标方法 long endTime = new Date().getTime(); long duration = endTime - startTime; if (duration \u0026gt;= 1000){ String className = pjp.getTarget().getClass().getName(); String methodName = pjp.getSignature().getName(); SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;); String now = sdf.format(new Date()); System.out.println(\u0026#34;===========\u0026#34;+now+\u0026#34;:\u0026#34;+className+\u0026#34;.\u0026#34;+methodName + \u0026#34;(\u0026#34; + duration+\u0026#34;ms)======\u0026#34;); } return ret; } catch (Throwable throwable) { System.out.println(\u0026#34;Exception message:\u0026#34;+throwable.getMessage()); throw throwable; } } } SpringContext.java\npackage com.imooc.spring.aop; import com.imooc.spring.aop.service.UserService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-04 23:20 */ public class SpringContext { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); userService.createUser(); } } 执行结果：\n执行员工入职业务逻辑 新增用户数据 ===========2021-01-05 14:15:17 017:com.imooc.spring.aop.service.UserService.createUser(3046ms)====== 注解形式 applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;/beans\u0026gt; BookShop.java\npackage com.imooc.spring.aop.entity; import org.springframework.stereotype.Component; /** * @author Rex * @create 2021-01-05 10:53 */ @Component public class BookShop { public void sellingBooks(){ System.out.println(\u0026#34;卖出一本java基础书籍\u0026#34;); } } MethodPro.java\npackage com.imooc.spring.aop.aspect; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; /** * @author Rex * @create 2021-01-05 10:54 */ @Component @Aspect public class MethodPro { // @Around(\u0026#34;execution(public * com.imooc..*.*())\u0026#34;) public void welcome(ProceedingJoinPoint pjd) throws Throwable { System.out.println(\u0026#34;欢迎光临慕课小店\u0026#34;); pjd.proceed(); System.out.println(\u0026#34;欢迎再次光临\u0026#34;); } @Before(\u0026#34;execution(public * com.imooc..*.*(..))\u0026#34;) public void preSales(){ System.out.println(\u0026#34;=====售前服务=====\u0026#34;); } @After(\u0026#34;execution(public * com.imooc..*.*(..))\u0026#34;) public void afterSale(){ System.out.println(\u0026#34;=====售后服务======\u0026#34;); } } SpringApplication.java\npackage com.imooc.spring.aop; import com.imooc.spring.aop.entity.BookShop; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-05 11:03 */ @ComponentScan public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); BookShop bookShop = context.getBean(\u0026#34;bookShop\u0026#34;, BookShop.class); bookShop.sellingBooks(); } } 执行结果：\n=====售前服务===== 卖出一本java基础书籍 =====售后服务====== ","permalink":"https://rexhub.space/posts/back/java/framework/spring/springaop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/","summary":"Spring AOP面向切面编程 Spring AOP Spring AOP - Aspect Oriented Programming 面向切面编程 AOP的做法是将通用、于业务无关的功能抽象封装为切面类 切面可配置在目标方法的执行前、后运行，真正做到即插即用 Spring AOP 用到的依赖dependency：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; applicationContext.xml中schema依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- bean definitions here --\u0026gt; \u0026lt;/beans\u0026gt; Spring AOP概念 Spring AOP与AspectJ的关系 Eclipse AspectJ，一种基于Java平台的面向切面编程的语言 Spring AOP使用AspectJWeaver实现类与方法的匹配 Spring AOP利用代理模式实现对象运行时功能扩展 几个关键概念 注解 说明 Aspect 切面，具体的可插拔组件功能类，通常一个切面只实现一个通用功能 Target Class/Method 目标类、目标方法，指真正要执行与业务相关的方法 PointCut 切入点，使用execution表达式说明切面要作用在系统的哪些类上 JoinPoint 连接点，切面运行过程中时包括了目标类/方法元数据的对象 Advice 通知，说明具体的切面的执行时机，Spring包含了五种不同类型通知 AOP配置过程 依赖AspectJ 实现切面类/方法 配置Aspect Bean 定义PointCut 配置Advice JoinPoint核心方法 注解 说明 Object getTarget() 获取IoC容器内目标对象 Signature getSignature() 获取目标方法 Object[] getArgs() 获取目标方法参数 PointCut切点表达式 通知 五种通知类型 注解 说明 Before Advice 前置通知，目标方法运行前执行 After Returning Advice 返回后通知，目标方法返回数据后执行 After Throwing Advice 异常通知，目标方法抛出异常后执行 After Advice 后置通知，目标方法运行 Around Advice 最强大通知，自定义通知执行时机，可决定目标方法是否运行 特殊的“通知”-引介增强 引介增强(Introduction Interceptor)是对类的增强，而非方法 引介增强允许在运行时为目标类增加新属性或方法 引介增强允许在运行时改变类的行为，让类随运行环境动态变更 Spring AOP实现原理 Spring基于代理模式实现功能动态扩展，包含俩种形式 目标类拥有接口，通过JDK动态代理实现功能扩展 目标类没有接口，通过CGLib组件实现功能扩展 代理模式： 代理模式通过代理对象对原对象的实现功能扩展 静态代理示例： UserService.","title":"Springaop面向切面编程"},{"content":"Spring IoC与Bean管理 Spring快速入门 IoC控制反转 IoC控制反转，全称Inverse of Control，是一种设计理念，把对象创建和对象之间的调用过程，交给spring进行管理 由代理人来创建与管理对象，消费者通过代理人来获取对象 IoC的目的是降低对象之间直接耦合 加入IoC容器将对象统一管理，让对象关联变为弱耦合 DI依赖注入 IoC是设计理念，是现代程序设计遵循的标准，是宏观目标 DI(Dependency Injection)是具体技术实现，是微观实现 DI在Java中利用反射技术实现对象注入（Injection） Spring Spring的含义 Spring可从狭义与广义俩个角度看待 狭义的Spring是指Spring框架（Spring Framework） 广义的Spring是指Spring生态体系 狭义的Spring Spring框架是企业开发复杂性的一站式解决方案 Spring框架的核心是IoC容器与AOP面向切面变成 Spring IoC负责创建与管理系统对象，并在此基础上扩展功能 传统开发方式 对象直接引用导致对象硬性关联，程序难以扩展维护 Spring IoC IoC容器是Spring生态的地基用于统一创建与管理对象依赖 Spring IoC容器职责 对象的控制器交由第三方统一管理（IoC控制反转） 利用Java反射技术实现运行时对象创建与关联（DI依赖注入） 基于配置提高应用程序的可维护性与扩展性 IOC底层原理： xml解析、工厂模式、反射 IOC(接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\nSpring提供IOC容器实现两种方式：（两个接口）\nBeanFactory：IOC容器基本实现方式，是Spring内部的使用的接口，不提供给开发人员使用\n特点：\n​\t加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\nApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能， 一般由开发人员进行使用\n特点：加载配置文件时候就会把配置文件对象进行创建\nApplicationContext接口\n代码示例： 需要引入的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Apple.java\npackage com.imooc.spring.ioc.entity; /** * @author CubeMonkey * @create 2020-11-27 23:57 */ public class Apple { private String title; private String color; private String origin; public Apple() { } public Apple(String title, String color, String origin) { this.title = title; this.color = color; this.origin = origin; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public String getOrigin() { return origin; } public void setOrigin(String origin) { this.origin = origin; } } applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中--\u0026gt; \u0026lt;bean id=\u0026#34;sweetApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;sourApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;青苹果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中亚\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;绿色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;softApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;金帅\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中国\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;金色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;rdApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;蛇果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;美国\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;lily\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;莉莉\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;softApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;andy\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;安迪\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;rdApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;luna\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;露娜\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;sweetApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; SpringApplication.java\npackage com.imooc.spring.ioc; import com.imooc.spring.ioc.entity.Apple; import com.imooc.spring.ioc.entity.Child; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author CubeMonkey * @create 2020-11-30 16:14 */ public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); Apple sweetApple = context.getBean(\u0026#34;sweetApple\u0026#34;, Apple.class); System.out.println(sweetApple.getTitle()); //从Ioc容器中提取beanId = lily的对象 Child lily = context.getBean(\u0026#34;lily\u0026#34;, Child.class); lily.eat(); Child andy = context.getBean(\u0026#34;andy\u0026#34;, Child.class); andy.eat(); Child luna = context.getBean(\u0026#34;luna\u0026#34;, Child.class); luna.eat(); } } XML管理对象(Bean) 三种配置方式 1. 基于XML配置Bean 实例化Bean的三种方式 基于构造方法对象实例化\n核心代码：\napplicationContext.xml\n\u0026lt;bean id=\u0026#34;apple2\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 基于静态工厂实例化\n核心代码：\napplicationContext.xml\n\u0026lt;!--利用静态工厂获取对象--\u0026gt; \u0026lt;bean id=\u0026#34;apple4\u0026#34; class=\u0026#34;com.imooc.spring.ioc.factory.AppleStaticFactory\u0026#34; factory-method=\u0026#34;createSweetApple\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; ​\tAppleStaticFactory.java\npackage com.imooc.spring.ioc.factory; import com.imooc.spring.ioc.entity.Apple; /** * 静态工厂通过静态方法创建对象，隐藏创建对象的细节 * @author CubeMonkey * @create 2020-12-01 18:50 */ public class AppleStaticFactory { public static Apple createSweetApple(){ //logger.info(\u0026#34;\u0026#34;) Apple apple = new Apple(); apple.setTitle(\u0026#34;红富士\u0026#34;); apple.setOrigin(\u0026#34;欧洲\u0026#34;); apple.setColor(\u0026#34;红色\u0026#34;); return apple; } } 基于工厂实例方法实例化\n核心代码：\napplicationContext.xml\n\u0026lt;!--利用工厂实例方法获取对象--\u0026gt; \u0026lt;bean id=\u0026#34;factoryInstance\u0026#34; class=\u0026#34;com.imooc.spring.ioc.factory.AppleFactoryInstance\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;apple5\u0026#34; factory-bean=\u0026#34;factoryInstance\u0026#34; factory-method=\u0026#34;createSweetApple\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; AppleFactoryInstance.java\npackage com.imooc.spring.ioc.factory; import com.imooc.spring.ioc.entity.Apple; /** * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程 * @author CubeMonkey * @create 2020-12-01 18:56 */ public class AppleFactoryInstance { public Apple createSweetApple(){ Apple apple = new Apple(); apple.setTitle(\u0026#34;红富士\u0026#34;); apple.setOrigin(\u0026#34;欧洲\u0026#34;); apple.setColor(\u0026#34;红色\u0026#34;); return apple; } } 2. 基于注解配置Bean 3. 基于Java代码配置Bean 从IoC容器获取bean 方法： Apple apple4 = context.getBean(\u0026#34;apple4\u0026#34;, Apple.class);//推荐 System.out.println(apple4.getTitle()); Apple apple3 = (Apple)context.getBean(\u0026#34;apple3\u0026#34;); System.out.println(apple3.getTitle()); id与name属性相同点 bean id 与name都是设置对象在IoC容器中唯一标识 两者在同一配置文件中都不允许出现重复 两者允许在多个配置文件中出现重复，新对象覆盖旧对象 id与name属性区别 id要求更为严格，一次只能定义一个对象标识（推荐） name更为宽松，一次允许定义多个对象标识 tips:id与name的命名有意义，按驼峰命名书写 路径表达式 加载单个配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); 加载多配置文件 String[] configLocations = new String[]{\u0026#34;classpath:applicationContext.xml\u0026#34;, {\u0026#34;classpath:applicationContext-1.xml\u0026#34;}}; ApplicationContext context = new ClassPathXmlApplicationContext(configLocations) 路径表达式说明 表达式实例 说明 classpath:config.xml 扫描classpath根路径(不包含jar)的config.xml classpath:com/imooc/config.xml 扫描classpath下(不包含jar)com.imooc包中的config.xml classpath*:com/imooc/config.xml 扫描classpath下(包含jar)com.imooc包中的config.xml classpath:config-*.xml 扫描classpath根路径下所有以config-开头的XML文件 classpath:com/**/config.xml 扫描com包下(包含任何子包)的config.xml file:c/config.xml 扫描c盘根路径config.xml 依赖注入 对象依赖注入 依赖注入是指运行时将容器内对象利用反射赋给其他对象的操作\n基于setter方法注入对象\n\u0026lt;bean name=\u0026#34;sweetApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;!-- IoC容器自动利用反射机制运行时调用setXxx方法为属性赋值--\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;123\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean name=\u0026#34;lily\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;莉莉\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--利用ref注入依赖对象--\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;sweetApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 基于构造方法注入对象\n\u0026lt;bean id=\u0026#34;sourApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;青苹果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;绿色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中亚\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;9.8\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;andy\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;安迪\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;apple\u0026#34; ref=\u0026#34;sourApple\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 集合依赖注入 注入List \u0026lt;bean id = \u0026#34;...\u0026#34; class = \u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;具体值\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Set \u0026lt;bean id = \u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someSet\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;具体值\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Map \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;k1\u0026#34; value=\u0026#34;v1\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;k2\u0026#34; value-ref=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Properties \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;properties name=\u0026#34;someProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;k1\u0026#34;\u0026gt;v1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;k2\u0026#34;\u0026gt;v2\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/bean\u0026gt; 查看容器内对象 String[] beanNames = context.getBeanDefinitionNames(); bean scope属性 bean scope属性用于决定对象何时被创建与作用范围 bean scope配置将影响容器内对象的数量 bean scope默认值singleton(单例)，指全局共享同一个对象实例 bean scope属性清单 scope属性 说明 singleton 单例(默认值)，每一个容器有且只有唯一的实例，实例被全局共享 prototype 多例，每次使用时都是创建一个实例 request web环境下，每一次独立请求存在唯一实例 session web环境下，每一个session存在有唯一实例 applicaiton web环境下，每一个ServletContext存在唯一实例 websocket 每一次WebSocket连接中存在唯一实例 singleton与prototype对比 singleton prototype 对象数量 全局唯一 存在多个 实例化时机 IoC容器启动时 getBean()或对象注入时 线程安全问题 存在 不存在 执行效率 高 低 bean生命周期 Ioc容器极简实现 示例代码： package com.imooc.spring.ioc.context; import org.dom4j.Document; import org.dom4j.Element; import org.dom4j.Node; import org.dom4j.io.SAXReader; import java.io.File; import java.lang.reflect.Method; import java.net.URLDecoder; import java.util.HashMap; import java.util.List; import java.util.Locale; import java.util.Map; /** * @author Rex * @create 2020-12-31 16:08 */ public class ClassPathXmlApplicationContext implements ApplicationContext{ private Map iocContainer = new HashMap(); public ClassPathXmlApplicationContext(){ try { String filePath = this.getClass().getResource(\u0026#34;/applicationContext.xml\u0026#34;).getPath(); filePath = new URLDecoder().decode(filePath, \u0026#34;utf-8\u0026#34;); SAXReader reader = new SAXReader(); Document document = reader.read(new File(filePath)); List\u0026lt;Node\u0026gt; nodes = document.getRootElement().selectNodes(\u0026#34;bean\u0026#34;); for (Node node : nodes) { Element ele = (Element) node; String id = ele.attributeValue(\u0026#34;id\u0026#34;); String className = ele.attributeValue(\u0026#34;class\u0026#34;); Class\u0026lt;?\u0026gt; c = Class.forName(className); Object obj = c.newInstance(); List\u0026lt;Node\u0026gt; properties = ele.selectNodes(\u0026#34;property\u0026#34;); for (Node p : properties) { Element property = (Element) p; String propName = property.attributeValue(\u0026#34;name\u0026#34;); String propValue = property.attributeValue(\u0026#34;value\u0026#34;); String setMethodName = \u0026#34;set\u0026#34;+propName.substring(0, 1).toUpperCase() + propName.substring(1); System.out.println(\u0026#34;准备执行\u0026#34;+setMethodName+\u0026#34;方法注入数据\u0026#34;); Method setMethod = c.getMethod(setMethodName, String.class); setMethod.invoke(obj, propValue); } iocContainer.put(id, obj); } System.out.println(iocContainer); System.out.println(\u0026#34;IOC容器初始化完毕\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } @Override public Object getBean(String beanId) { return iocContainer.get(beanId); } } ","permalink":"https://rexhub.space/posts/back/java/framework/spring/springioc%E4%B8%8Ebean%E7%AE%A1%E7%90%86/","summary":"Spring IoC与Bean管理 Spring快速入门 IoC控制反转 IoC控制反转，全称Inverse of Control，是一种设计理念，把对象创建和对象之间的调用过程，交给spring进行管理 由代理人来创建与管理对象，消费者通过代理人来获取对象 IoC的目的是降低对象之间直接耦合 加入IoC容器将对象统一管理，让对象关联变为弱耦合 DI依赖注入 IoC是设计理念，是现代程序设计遵循的标准，是宏观目标 DI(Dependency Injection)是具体技术实现，是微观实现 DI在Java中利用反射技术实现对象注入（Injection） Spring Spring的含义 Spring可从狭义与广义俩个角度看待 狭义的Spring是指Spring框架（Spring Framework） 广义的Spring是指Spring生态体系 狭义的Spring Spring框架是企业开发复杂性的一站式解决方案 Spring框架的核心是IoC容器与AOP面向切面变成 Spring IoC负责创建与管理系统对象，并在此基础上扩展功能 传统开发方式 对象直接引用导致对象硬性关联，程序难以扩展维护 Spring IoC IoC容器是Spring生态的地基用于统一创建与管理对象依赖 Spring IoC容器职责 对象的控制器交由第三方统一管理（IoC控制反转） 利用Java反射技术实现运行时对象创建与关联（DI依赖注入） 基于配置提高应用程序的可维护性与扩展性 IOC底层原理： xml解析、工厂模式、反射 IOC(接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\nSpring提供IOC容器实现两种方式：（两个接口）\nBeanFactory：IOC容器基本实现方式，是Spring内部的使用的接口，不提供给开发人员使用\n特点：\n​\t加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\nApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能， 一般由开发人员进行使用\n特点：加载配置文件时候就会把配置文件对象进行创建\nApplicationContext接口\n代码示例： 需要引入的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Apple.java\npackage com.imooc.spring.ioc.entity; /** * @author CubeMonkey * @create 2020-11-27 23:57 */ public class Apple { private String title; private String color; private String origin; public Apple() { } public Apple(String title, String color, String origin) { this.","title":"Springioc与bean管理"},{"content":"Spring Test与JUnit4整合 Spring Test测试模块 Spring Test是Spring中用于测试的模块 Sprint Test对JUnit单元测试框架有良好的整合 通过Spring Test可在JUnit在单元测试时自动初始化IoC容器 Spring与JUnit4整合过程 Maven工程依赖spring-test 利用@RunWith与@ContextConfiguration描述测试用例类 测试用例类从容器获取对象完成测试用例的执行 ","permalink":"https://rexhub.space/posts/back/java/framework/spring/springtest%E4%B8%8Ejunit4%E6%95%B4%E5%90%88/","summary":"Spring Test与JUnit4整合 Spring Test测试模块 Spring Test是Spring中用于测试的模块 Sprint Test对JUnit单元测试框架有良好的整合 通过Spring Test可在JUnit在单元测试时自动初始化IoC容器 Spring与JUnit4整合过程 Maven工程依赖spring-test 利用@RunWith与@ContextConfiguration描述测试用例类 测试用例类从容器获取对象完成测试用例的执行 ","title":"Springtest与junit4整合"},{"content":"基于Java Config配置的IoC容器 基于Java Config的优势 完全摆脱XML的束缚，使用独立Java类管理对象与依赖 注解配置相对分散，利用Java Config可对配置集中管理 可以在编译时进行依赖检查，不容易出错 Java Config核心注解 注解 说明 @Configuration 描述类，说明当前类是Java Config配置类，完全替代XML文件 @Bean 描述方法，方法返回对象将被IoC容器管理，beanId默认为方法名 @ImportResource 描述类，加载静态文件，可使用@Value注解获取 @CompoenentScan 描述类，同XML的context:component-scan标签 ","permalink":"https://rexhub.space/posts/back/java/framework/spring/%E5%9F%BA%E4%BA%8Ejavaconfig%E9%85%8D%E7%BD%AE%E7%9A%84ioc%E5%AE%B9%E5%99%A8/","summary":"基于Java Config配置的IoC容器 基于Java Config的优势 完全摆脱XML的束缚，使用独立Java类管理对象与依赖 注解配置相对分散，利用Java Config可对配置集中管理 可以在编译时进行依赖检查，不容易出错 Java Config核心注解 注解 说明 @Configuration 描述类，说明当前类是Java Config配置类，完全替代XML文件 @Bean 描述方法，方法返回对象将被IoC容器管理，beanId默认为方法名 @ImportResource 描述类，加载静态文件，可使用@Value注解获取 @CompoenentScan 描述类，同XML的context:component-scan标签 ","title":"基于javaconfig配置的ioc容器"},{"content":"基于注解配置IoC容器 基于注解的优势 摆脱繁琐的XML形式的bean与依赖注入配置 基于“声明式”的原则，更适合轻量级的现代企业应用 让代码可读性变得更好，让研发人员拥有更好的开发体验 三类注解 组件类型注解-声明当前类的功能与职责 自动装配注解-根据属性特征自动注入对象 元数据注解-更细化的辅助IoC容器管理对象的 注解 组件类型注解： 四种组件类型注解 注解 说明 @Component 组件注解，通用注解，被该注解描述的类将被IoC容器管理并实例化 @Controller xA语义注解，说明当前类是MVC应用中的控制器类 @Service 语义注解，说明当前类是Service业务服务类 @Repository 语义注解，说明当前类用于业务持久层，通常描述对应Dao类 开启组件扫描： \u0026lt;!--XML配置开启组件扫描，才能使用注解--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;regex\u0026#34; expression=\u0026#34;com.imooc.exl.*\u0026#34;\u0026gt; \u0026lt;/context:exclude-filter\u0026gt; \u0026lt;/context:component-scan\u0026gt; 基于注解初始化IoC容器 ​\tapplicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--在IoC容器初始化时自动扫描四种组件类型注解并完成实例化 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 自动装配注解： 两类自动装配注解： 分类 注解 说明 按类型装配 @Autowired 按容器内对象类型动态注入属性，由Spring机构提供 @Inject 基于JSR-330(Dependency Injection for Java)标准，其他同@Autowired,但不支持request属性 按名称装配 @Named 与@Inject配合使用，JSR-330规范，按属性名自动装配属性 @Resource 基于JSR-250规范，优先按名称，再按类型智能匹配 Autowired: pring IoC容器会自动通过反射技术将属性private修饰符自动改为public，直接进行赋值, 不再执行set方法。如果装配注解放在set方法上，则自动按类型/名称对set方法参数进行注入\nResource: @Resource设置name属性，则按照name在IoC容器中将bean注入 @Resource未设置name属性 2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配注入 2.2 按属性名未匹配，则按类型进行匹配，同autowired，需加入@Primary解决冲突 使用建议：在使用@Resource对象时，推荐设置name或保证属性名与bean名称一致 元数据注解 注解 说明 @Primary 按类型装配时出现多个相同类型对象，拥有此注解对象优先被注入 @PostConstruct 描述方法，相当于XML中init-method配置的注解版本 @PreDestory 描述方法，相当于XML中destroy-method配置的注解版本 @Scope 设置对象的scope属性 @Value 为属性注入静态数据 ","permalink":"https://rexhub.space/posts/back/java/framework/spring/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEioc%E5%AE%B9%E5%99%A8/","summary":"基于注解配置IoC容器 基于注解的优势 摆脱繁琐的XML形式的bean与依赖注入配置 基于“声明式”的原则，更适合轻量级的现代企业应用 让代码可读性变得更好，让研发人员拥有更好的开发体验 三类注解 组件类型注解-声明当前类的功能与职责 自动装配注解-根据属性特征自动注入对象 元数据注解-更细化的辅助IoC容器管理对象的 注解 组件类型注解： 四种组件类型注解 注解 说明 @Component 组件注解，通用注解，被该注解描述的类将被IoC容器管理并实例化 @Controller xA语义注解，说明当前类是MVC应用中的控制器类 @Service 语义注解，说明当前类是Service业务服务类 @Repository 语义注解，说明当前类用于业务持久层，通常描述对应Dao类 开启组件扫描： \u0026lt;!--XML配置开启组件扫描，才能使用注解--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;regex\u0026#34; expression=\u0026#34;com.imooc.exl.*\u0026#34;\u0026gt; \u0026lt;/context:exclude-filter\u0026gt; \u0026lt;/context:component-scan\u0026gt; 基于注解初始化IoC容器 ​\tapplicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--在IoC容器初始化时自动扫描四种组件类型注解并完成实例化 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 自动装配注解： 两类自动装配注解： 分类 注解 说明 按类型装配 @Autowired 按容器内对象类型动态注入属性，由Spring机构提供 @Inject 基于JSR-330(Dependency Injection for Java)标准，其他同@Autowired,但不支持request属性 按名称装配 @Named 与@Inject配合使用，JSR-330规范，按属性名自动装配属性 @Resource 基于JSR-250规范，优先按名称，再按类型智能匹配 Autowired: pring IoC容器会自动通过反射技术将属性private修饰符自动改为public，直接进行赋值, 不再执行set方法。如果装配注解放在set方法上，则自动按类型/名称对set方法参数进行注入","title":"基于注解配置ioc容器"},{"content":"反射Reflect 什么是反射 反射(Reflect)是在运行时动态访问类与对象的技术 反射是JDK1.2版本后的高级特性，隶属于java.lang.reflect 大多是Java框架都基于反射实现参数、动态注入等特性 反射的核心类 Class类 Constructor构造方法类 Method方法类 Field成员变量类 Class类 Class是JVM中代表\u0026quot;类和接口\u0026quot;类 Class对象具体包含了某个特定类的结构信息 通过Class对象可获取对应类的构造方法/方法/成员变量 Class核心方法 方法 用途 Class.forName() 静态方法，用于获取指定Class对象 classObj.newInstance() 通过默认构造方法创建新的对象 classObj.getConstructor() 获得指定的public修饰构造方法Construct对象 classObj.getMethod() 获取指定的public修饰方法Method对象 classObj.getField() 获取指定的public修饰成员变量的Field对象 使用案例： Employee.java\npackage com.imooc.reflect.entity; /** * 员工实体类 * @author CubeMonkey * @create 2020-10-21 16:01 */ public class Employee { static{ System.out.println(\u0026#34;Employee已被加载到内存中，并已初始化\u0026#34;); } private Integer eno; private String ename; private Float salary; private String dname; public Employee(){ System.out.println(\u0026#34;Employee默认构造方法已被执行\u0026#34;); } public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } } ClassSample.java\npackage com.imooc.reflect; import com.imooc.reflect.entity.Employee; /** * @author CubeMonkey * @create 2020-10-21 16:03 */ public class ClassSample { public static void main(String[] args) { try { //Class.forName()方法将指定的类加载到jvm中，并返回对应Class对象 Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); System.out.println(\u0026#34;Employee已被加载到jvm\u0026#34;); //newInstance通过默认构造方法创建新的对象 Employee employee = (Employee) employeeClass.newInstance(); System.out.println(employee); } catch (ClassNotFoundException e) { //类名与类路径书写错误时抛出“ClassNotFoundException”异常 e.printStackTrace(); } catch (IllegalAccessException e) { //非法访问异常，当在作用域外访问对象方法或成员变量时抛出 e.printStackTrace(); } catch (InstantiationException e) { //对象无法被实例化，抛出“InstantiationException”异常 e.printStackTrace(); } } } Constructor构造器类 Constructor类是对Java类中的构造方法的抽象 Constructor对象包含了具体类的某个具体构造方法的声明 通过Constructor对象调用带参构造方法创建对象 Constructor类核心方法 方法 用途 classObj.getConstructor() 获取指定public修饰的构造方法对象 constructorObj.newInstance() 通过对应的构造方法创建对象 使用案例： ConstructorSample.java\npackage com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /** * 利用带参构造方法创建对象 * @author CubeMonkey * @create 2020-10-22 15:08 */ public class ConstructorSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李雷\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); System.out.println(employee); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { //没有找到与之对应格式的方法 e.printStackTrace(); } catch (IllegalAccessException e) { //非法访问 e.printStackTrace(); } catch (InstantiationException e) { //实例化异常（接口、抽象类） e.printStackTrace(); } catch (InvocationTargetException e) { //当被调用的方法的内部抛出了异常而没有被捕获时 e.printStackTrace(); } } } Method方法类 Method对象指代某个类中的方法的描述 Method对象使用classObj.getMethod()方法获取 通过Method对象调用指定对象的对应方法 Method类核心方法 方法 用途 classObj.getMethod() 获取指定public修饰的方法对象 methodObj.invoke() 调用指定对象的方法 使用案例： package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * 利用Method方法类调用 * @author CubeMonkey * @create 2020-10-22 15:29 */ public class MethodSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李雷\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Method updateSalaryMethod = employeeClass.getMethod(\u0026#34;updateSalry\u0026#34;, Float.class); Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, 1000f); System.out.println(employee1); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } Field成员变量类 Field对应某个具体类中的成员变量的声明 Field对象使用classObj.getField()方法获取 通过Field对象可为某对象成员变量赋值/取值（运行时） Field类核心方法 ​\n方法 用途 classObj.getField() 获取指定public修饰的成员变量 fieldObj.set() 为某对象指定成员变量赋值 fieldObj.get() 获取某对象指定成员变量数值 使用案例 package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; /** * @author CubeMonkey * @create 2020-10-23 9:45 */ public class FieldSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李磊\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Field enameField = employeeClass.getField(\u0026#34;ename\u0026#34;); enameField.set(employee, \u0026#34;李雷\u0026#34;); String ename = (String) enameField.get(employee); System.out.println(\u0026#34;ename：\u0026#34;+ename); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { //没有找到对应成员变量 e.printStackTrace(); } } } getDeclare系列方法 getDeclaredConstructor(s) | Method(s) | Field(s) 获取对应对象 getConstructor | Method | Field 只能获取public对象 访问非作用域内构造方法、方法、成员变量、会抛出异常 使用案例： package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author CubeMonkey * @create 2020-10-23 10:02 */ public class GetDeclareSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李磊\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Field[] fields = employeeClass.getDeclaredFields(); for (Field field : fields){ // System.out.println(field.getName()); if (field.getModifiers() == 1){//public修饰 Object val = field.get(employee); System.out.println(val); }else if(field.getModifiers() == 2){//private String methodName = \u0026#34;get\u0026#34;+field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1); Method getMethod = employeeClass.getMethod(methodName); Object ret = getMethod.invoke(employee); System.out.println(ret); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } 反射在项目中的应用（I18N） I18N.java接口\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 12:55 */ public interface I18N { public String say(); } Zhcn.java类\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 12:56 */ public class Zhcn implements I18N{ @Override public String say() { return \u0026#34;生命不息奋斗不止\u0026#34;; } } En.java类\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 13:05 */ public class En implements I18N { @Override public String say() { return \u0026#34;Cease to the struggle and cease to the life\u0026#34;; } } config.properties\nlanguage=com.imooc.i18n.En Application.java\npackage com.imooc.i18n; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.Properties; /** * @author CubeMonkey * @create 2020-10-23 12:59 */ public class Application { public static void say(){ Properties properties = new Properties(); String configPath = Application.class.getResource(\u0026#34;/config.properties\u0026#34;).getPath(); try { configPath = new URLDecoder().decode(configPath, \u0026#34;utf-8\u0026#34;); properties.load(new FileInputStream(configPath)); String language = properties.getProperty(\u0026#34;language\u0026#34;); I18N i18n = (I18N) Class.forName(language).newInstance(); System.out.println(i18n.say()); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static void main(String[] args) { Application.say(); } } ","permalink":"https://rexhub.space/posts/back/java/reflect/","summary":"反射Reflect 什么是反射 反射(Reflect)是在运行时动态访问类与对象的技术 反射是JDK1.2版本后的高级特性，隶属于java.lang.reflect 大多是Java框架都基于反射实现参数、动态注入等特性 反射的核心类 Class类 Constructor构造方法类 Method方法类 Field成员变量类 Class类 Class是JVM中代表\u0026quot;类和接口\u0026quot;类 Class对象具体包含了某个特定类的结构信息 通过Class对象可获取对应类的构造方法/方法/成员变量 Class核心方法 方法 用途 Class.forName() 静态方法，用于获取指定Class对象 classObj.newInstance() 通过默认构造方法创建新的对象 classObj.getConstructor() 获得指定的public修饰构造方法Construct对象 classObj.getMethod() 获取指定的public修饰方法Method对象 classObj.getField() 获取指定的public修饰成员变量的Field对象 使用案例： Employee.java\npackage com.imooc.reflect.entity; /** * 员工实体类 * @author CubeMonkey * @create 2020-10-21 16:01 */ public class Employee { static{ System.out.println(\u0026#34;Employee已被加载到内存中，并已初始化\u0026#34;); } private Integer eno; private String ename; private Float salary; private String dname; public Employee(){ System.out.println(\u0026#34;Employee默认构造方法已被执行\u0026#34;); } public Integer getEno() { return eno; } public void setEno(Integer eno) { this.","title":"Reflect"},{"content":"Emos项目学习记录 学习点： 加密算法\n这里采用的是IBM开发的AES算法。这种对称加密算法在加密和解密数据的时候，使用相同的密钥。也就是说密钥既可以用来加密数据，也可以解密数据。关于AES算法的优点我这里不展开说明了，大家可以自己百度查阅资料。MySQL数据库提供了内置的DES加密和解密的函数，我们只需要调用即可。加密的函数叫做AES_ENCRPT()，解密的函数叫做AES_DECRPT()\n​\t数据库：登录sql，若查询记录结果只有一条，可以加limit 1加快查询个数\n\u0026lt;select id=\u0026#34;login\u0026#34; parameterType=\u0026#34;com.example.emos.api.emos.model.form.LoginForm\u0026#34; resultType=\u0026#34;Integer\u0026#34;\u0026gt; SELECT id FROM tb_user WHERE username = #{username} AND password = HEX(AES_ENCRYPT(#{password}, #{username})) LIMIT 1; \u0026lt;/select\u0026gt; 数据库：数据库查询操作的返回值用封装类，防止结果为null值不能赋给一般数据类型；若是增删改返回结果肯定为数字且不为null，表示影响的记录个数，可以用一般数据类型\n数据库：要不要用MySQL方言？，可能会存在可移植性差\n后端：不能随意删除记录，需要查询有没有相关的引用\n数据库：写sql的时候需要注意状态字段(status)\n后端：分页查询的时候限制分页的start(1, +∞)，size(10, 50)\n数据库：灵活使用数据库中的json字段\n后端工作流中采用了QuartZ定时器引起、Activeti引擎\n业务：审批会议前需注意：1.结束时间必须大于开始时间 2.会议开始时间不能早于当前时间\n前端：可用day.js转换日期格式\n数据库：数据类型的数据范围、\n日期格式： datetime: 8字节\ntimestamp：4字节 表示范围有限：~2038年就满了\n甘特图：用于描述任务\n工作流：通过工作流来控制审批系统\nbug解决: 移除springdoc-openapi-spring-boot-2-webmvc依赖中的jackson-dataformat-xml，否则会使controller返回结果为xml格式\n重复新增用户的提示不友好\n会议室中，删除模块的bug\n","permalink":"https://rexhub.space/posts/proj/emos/emos%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","summary":"Emos项目学习记录 学习点： 加密算法\n这里采用的是IBM开发的AES算法。这种对称加密算法在加密和解密数据的时候，使用相同的密钥。也就是说密钥既可以用来加密数据，也可以解密数据。关于AES算法的优点我这里不展开说明了，大家可以自己百度查阅资料。MySQL数据库提供了内置的DES加密和解密的函数，我们只需要调用即可。加密的函数叫做AES_ENCRPT()，解密的函数叫做AES_DECRPT()\n​\t数据库：登录sql，若查询记录结果只有一条，可以加limit 1加快查询个数\n\u0026lt;select id=\u0026#34;login\u0026#34; parameterType=\u0026#34;com.example.emos.api.emos.model.form.LoginForm\u0026#34; resultType=\u0026#34;Integer\u0026#34;\u0026gt; SELECT id FROM tb_user WHERE username = #{username} AND password = HEX(AES_ENCRYPT(#{password}, #{username})) LIMIT 1; \u0026lt;/select\u0026gt; 数据库：数据库查询操作的返回值用封装类，防止结果为null值不能赋给一般数据类型；若是增删改返回结果肯定为数字且不为null，表示影响的记录个数，可以用一般数据类型\n数据库：要不要用MySQL方言？，可能会存在可移植性差\n后端：不能随意删除记录，需要查询有没有相关的引用\n数据库：写sql的时候需要注意状态字段(status)\n后端：分页查询的时候限制分页的start(1, +∞)，size(10, 50)\n数据库：灵活使用数据库中的json字段\n后端工作流中采用了QuartZ定时器引起、Activeti引擎\n业务：审批会议前需注意：1.结束时间必须大于开始时间 2.会议开始时间不能早于当前时间\n前端：可用day.js转换日期格式\n数据库：数据类型的数据范围、\n日期格式： datetime: 8字节\ntimestamp：4字节 表示范围有限：~2038年就满了\n甘特图：用于描述任务\n工作流：通过工作流来控制审批系统\nbug解决: 移除springdoc-openapi-spring-boot-2-webmvc依赖中的jackson-dataformat-xml，否则会使controller返回结果为xml格式\n重复新增用户的提示不友好\n会议室中，删除模块的bug","title":"Emos项目学习记录"},{"content":"emos项目准备 项目结构 已有项目： 工作流项目(emos-workflow) 小程序项目(emos-wx) 小程序后端项目(emos-wx-api) 待开发项目 Web办公系统前端项目(emos-vue) Web办公系统后端项目(emos-api) 数据表分类： 序号 类型 特征 备注 1 工作流数据表 以 act_ 开头 存储工作流的各项数据 2 定时器数据表 以 qrtz_ 开头 存储QuartZ定时器数据 3 业务表 以 tb_ 开头 保存业务数据 4 系统表 以 sys_ 开头 保存系统配置信息 后端： 依赖库： Lombok \u0026ndash; 生成对象的Get/Set方法\nSpring Web \u0026ndash; spring的web开发框架\nMyBatis Framework \u0026ndash; mybatis的开发框架\nMySQL Driver \u0026ndash; MySQL数据库驱动\nSpring Data Redis(Access + Driver) \u0026ndash; Redis连接+驱动工具\nSpring Data MongoDB \u0026ndash; MongoDB连接工具\nSpring for RabbitMQ \u0026ndash; RabbitMQ消息队列连接工具\nWebSocket \u0026ndash; 网络工具\nJava Mail Sender \u0026ndash; 发送邮件工具\nJettty \u0026ndash; 因为本项目中用到了WebSocket，而且Jetty本身的IO就是非阻塞式的，所以在高并发的WebSocket环境下，Jetty比Tomcat更加适合。\ndruid \u0026ndash; mysql数据库连接池\nspringdoc \u0026ndash; 接口文档生成工具\nSa-Token \u0026ndash; 轻量级权限认证框架\n\u0026lt;!--核心库--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--用Redis缓存授权信息--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-dao-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--注解式权限验证--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 项目配置 server: # jetty线程池配置 jetty: threads: acceptors: 4 selectors: 8 port: 8090 servlet: context-path: /emos-api # 文件上传大小配置 multipart: max-request-size: 10MB max-file-size: 2MB spring: # 数据库连接池 datasource: # 数据库池类型 type: com.alibaba.druid.pool.DruidDataSource druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/emos?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;nullCatelogMeansCurrent=true username: root password: root # 初始连接数量 initial-size: 2 # 最大活跃数 max-active: 4 # 最小空闲值 min-idle: 4 # 最大等待值 max-wait: 60000 # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 test-while-idle: true # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 test-on-borrow: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 test-on-return: false # Redis配置 redis: database: 0 host: localhost port: 6379 password: jedis: pool: # 连接池最大连接数（使用负值表示没有限制） max-active: 1000 # 连接池中的最大阻塞等待时间（使用负值表示没有限制） max-wait: -1ms # 连接池中的最大空闲连接 max-idle: 16 # 连接池中的最小空闲连接 min-idle: 8 # MongoDB配置 data: mongodb: host: localhost port: 27017 database: emos # 身份验证 # authentication-database: admin # username: # password: sa-token: # token名称 (同时也是cookie名称) token-name: token # token有效期，单位s 默认30天, -1代表永不过期 timeout: 2592000 # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒 activity-timeout: -1 # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) allow-concurrent-login: true # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) is-share: false # token风格 token-style: uuid # 配置MyBatis mybatis: # mapper文件地址映射 mapper-locations: classpath*:mapper/*.xml # 配置xml文件中resultType返回值的包位置 type-aliases-package: com.example.emos.wx.db.pojo configuration: # 开启日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 开启驼峰转换 map-underscore-to-camel-case: true # 日志配置 logging: # 日志级别 level: root: info com.example.emos.wx.db.dao: warn pattern: # 日志格式 console: \u0026#34;%d{yyyy/MM/dd HH:mm:ss} %-5level %msg%n\u0026#34; # 接口文档工具配置 springdoc: api-docs: # 启用接口文档工具 enabled: true # 配置接口文档url path: /doc-api.html # 用swagger来美化文档 swagger-ui: # 配置swagger接口文档url path: /swagger-ui.html disable-swagger-default-url: on 工具库 序号 工具库 备注 1 hutool 通用工具库 2 commons-io 文件IO通用工具库 3 zxing 生成二维码图片 4 httpcore HTTP状态码 基础配置 统一Web响应结果\npackage com.example.emos.api.common.dto; import lombok.Data; import org.apache.http.HttpStatus; import java.io.Serializable; import java.sql.ResultSet; /** * Description: 统一Web响应结果 * * @author Rex * @date 2021-09-09 10:27 */ @Data public class Result\u0026lt;T\u0026gt; implements Serializable { private static final long serialVersionUID = 1L; /** * 响应码 */ private Integer code; /** * 响应信息 */ private String msg; /** * 响应数据 */ private T data; public Result() { this.code = HttpStatus.SC_OK; this.msg = \u0026#34;success\u0026#34;; } public Result(String msg) { this(); this.msg = msg; } public Result(Integer code, String msg) { this.code = code; this.msg = msg; } public Result(Integer code, String msg, T data) { this(code, msg); this.data = data; } public static Result\u0026lt;Void\u0026gt; success(){ return new Result\u0026lt;\u0026gt;(); } public static Result\u0026lt;Void\u0026gt; success(String msg){ return new Result\u0026lt;\u0026gt;(msg); } public static \u0026lt;R\u0026gt;Result\u0026lt;R\u0026gt; success(R data){ Result\u0026lt;R\u0026gt; result = new Result\u0026lt;\u0026gt;(); result.setData(data); return result; } public static Result\u0026lt;Void\u0026gt; error(int code, String msg){ return new Result\u0026lt;\u0026gt;(code, msg); } public static Result\u0026lt;Void\u0026gt; error(String msg){ return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg); } public static Result error(){ return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, \u0026#34;未知异常，请联系管理员\u0026#34;); } } 整合SpringDoc\npackage com.example.emos.api.config; import io.swagger.v3.oas.annotations.OpenAPIDefinition; import io.swagger.v3.oas.annotations.enums.SecuritySchemeType; import io.swagger.v3.oas.annotations.info.Info; import io.swagger.v3.oas.annotations.security.SecurityScheme; import org.springframework.context.annotation.Configuration; /** * Description: 配置SpringDoc * * @author Rex * @date 2021-09-09 11:02 */ @Configuration @OpenAPIDefinition( info = @Info( title = \u0026#34;emos-api\u0026#34;, description = \u0026#34;Emos管理系统后端Java项目\u0026#34;, version = \u0026#34;1.0\u0026#34; ) ) @SecurityScheme( name = \u0026#34;token\u0026#34;, type = SecuritySchemeType.HTTP, bearerFormat = \u0026#34;JWT\u0026#34;, scheme = \u0026#34;bearer\u0026#34; ) public class SpringDocConfig { } 整合权限验证和授权\n在com.example.emos.api.config包中创建StpInterfaceImpl.java类，这个Java类就是Sa-Token框架拦截HTTP请求之后调用的类。在这个类中，我们一共要声明两个方法分别用来查询用户实际的权限和角色。然后Sa-Token框架的@SaCheckPermission或者@SaCheckRole注解会根据查询出来的权限和角色，跟注解要求的权限或者角色做匹配。\nTbUserDao.xml\n\u0026lt;select id=\u0026#34;searchUserPermissions\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;String\u0026#34;\u0026gt; SELECT DISTINCT p.permission_name FROM tb_user u JOIN tb_role r ON JSON_CONTAINS(u.role, CAST(r.id AS CHAR)) JOIN tb_permission p ON JSON_CONTAINS(r.permissions, CAST(p.id AS CHAR)) WHERE u.id=#{userId} AND u.status=1; \u0026lt;/select\u0026gt; TbUserDao.java\n@Mapper public interface TbUserDao { …… public Set\u0026lt;String\u0026gt; searchUserPermissions(int userId); } StpInterfaceImpl.java\npackage com.example.emos.api.config; import cn.dev33.satoken.stp.StpInterface; import com.example.emos.api.db.dao.TbUserDao; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.ArrayList; import java.util.List; import java.util.Set; @Component public class StpInterfaceImpl implements StpInterface { @Autowired private TbUserDao userDao; /** * 返回一个用户所拥有的权限集合 */ @Override public List\u0026lt;String\u0026gt; getPermissionList(Object loginId, String loginKey) { int userId = Integer.parseInt(loginId.toString()); Set\u0026lt;String\u0026gt; permissions = userDao.searchUserPermissions(userId); ArrayList list = new ArrayList(); list.addAll(permissions); return list; } /** * 返回一个用户所拥有的角色标识集合 */ @Override public List\u0026lt;String\u0026gt; getRoleList(Object loginId, String loginKey) { //因为本项目不需要用到角色判定，所以这里就返回一个空的ArrayList对象 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); return list; } } 跨域配置\npackage com.example.emos.api.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * Description: 跨域请求配置 * * @author Rex * @date 2021-09-09 12:55 */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowCredentials(true) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;PATCH\u0026#34;) .maxAge(3600); } } 异常\n自定义业务异常\npackage com.example.emos.api.common.dto.exception; import lombok.Data; import lombok.EqualsAndHashCode; /** * Description: 业务异常 * * @author Rex * @date 2021-09-09 14:22 */ @EqualsAndHashCode(callSuper = true) @Data public class EmosException extends RuntimeException{ private String msg; private Integer code = 500; public EmosException(String msg){ super(msg); this.msg = msg; } public EmosException(String msg, Integer code){ super(msg); this.msg = msg; this.code = code; } } 统一异常处理\npackage com.example.emos.api.config; import cn.dev33.satoken.exception.NotLoginException; import com.example.emos.api.common.dto.Result; import com.example.emos.api.common.exception.EmosException; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; import org.springframework.web.bind.annotation.RestControllerAdvice; /** * Description: 统一异常处理 * * @author Rex * @date 2021-09-09 14:26 */ @Slf4j @RestControllerAdvice public class GlobalExceptionHandler { /** * 处理全局异常信息 * @param e 全局异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public Result\u0026lt;Void\u0026gt; exceptionHandler(Exception e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(); } /** * 处理后端验证失败产生的异常 * @param e 校验异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(MethodArgumentNotValidException.class) public Result\u0026lt;Void\u0026gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(e.getBindingResult().getFieldError().getDefaultMessage()); } /** * 处理业务异常 * @param e 业务异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(EmosException.class) public Result\u0026lt;Void\u0026gt; emosExceptionHandler(EmosException e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(e.getMsg()); } /** * 处理未登录异常 * @param e 未登录异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(NotLoginException.class) public Result\u0026lt;Void\u0026gt; unLoginHandler(NotLoginException e){ return Result.error(e.getMessage()); } } 开启Java异步执行\n为什么要给Java语言增添异步执行？其实很简单，在一个业务流程中，有时候会有一些耗费时间的分支任务，如果把这些琐碎且不重要的任务用异步来执行，那么就可以减轻当前线程的执行压力。\n举个例子吧，例如有个电商网站为了吸引新用户注册，给出了赠送一年优酷会员的优惠。如果我们采用同步的执行方式，用户帐户开通之后，当前线程还要调用优酷系统的接口，开通会员帐户，并且充值一年会员。整个流程加起来还是挺耗费时间的，让新注册用户等待一两分钟才能收到注册成功的通知，用户心里肯定会怀疑：这是什么破电商网站，注册个会员就要好几分钟，我要是买东西不得卡成翔啊。\n如果我们采取异步执行的方式，电商帐户开通之后，我们把开通优酷会员的任务交给其他线程去做，当前线程就不用负责了，直接返回给用户注册成功即可。当其他线程开通优酷会员之后，给用户的手机发一个短信通知即可。你看，采用了异步执行以后，新用户注册的体验更好了。其实我这里说的异步执行就是由SpringBoot自动把任务交给线程池中某个线程去执行。你以前自己创建线程分配任务的方式，也属于异步执行。只不过有了SpringBoot之后，任务的分配更加自动了。\n关于电商网站新用户注册的例子，有的同学可能还有疑问：不用异步执行，我用消息队列来分配任务是不是也行？当然是可行的。刚才我说的异步执行陷于同一个系统中，把分支任务交给其他线程去执行。如果你用的是分布式架构，A系统想要把分支任务分配个B系统去执行，通过消息队列来分配任务完全是可行的，这也算是一种异步执行的方式。\n创建线程池：\npackage com.example.emos.api.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.task.AsyncTaskExecutor; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import java.util.concurrent.ThreadPoolExecutor; /** * Description: 线程池配置类 * * @author Rex * @date 2021-09-09 14:46 */ @Configuration public class ThreadPoolConfig { @Bean(\u0026#34;AsyncTaskExecutor\u0026#34;) public AsyncTaskExecutor taskExecutor(){ ThreadPoolTaskExecutor executorThread = new ThreadPoolTaskExecutor(); // 设置核心线程数 executorThread.setCorePoolSize(8); // 设置最大线程数 executorThread.setMaxPoolSize(16); // 设置队列容量 executorThread.setQueueCapacity(32); // 设置线程活跃时间(秒) executorThread.setKeepAliveSeconds(60); // 设置默认线程名称 executorThread.setThreadNamePrefix(\u0026#34;task-\u0026#34;); // 设置拒绝策略 executorThread.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executorThread.initialize(); return executorThread; } } 开启SpringBoot异步执行\n​\t我们在项目的主类EmosApiApplication.java声明上面加上@EnableAsync注解即可。等将来我们发送邮件的时候，再去编写任务类。\n预防XSS攻击\n防御XSS攻击的办法很简单，那就是对所有用户的数据先做转义处理，然后再保存到数据库里面。转义之后的信息，将来被加载到网页上面就丧失了作为脚本执行的能力。比如说上面文本框里面的脚本，经过转义之后就变成了\u0026lt;script\u0026gt;alert(\u0026quot;HelloWorld\u0026quot;)\u0026lt;/script\u0026gt;这个样子。就拿\u0026lt;script\u0026gt;来说吧，它会被渲染成\u0026lt;script\u0026gt;字符串，而不是当做脚本标签来执行。\n实现XSS内容转义\npackage com.example.emos.api.config.xss; import cn.hutool.core.util.StrUtil; import cn.hutool.http.HtmlUtil; import cn.hutool.json.JSONUtil; import javax.servlet.ReadListener; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.util.LinkedHashMap; import java.util.Map; /** * Description: httpServletRequest请求转义封装类 * 转义请求返回的结果 * @author Rex * @date 2021-09-09 15:36 */ public class XssHttpSevletRequestWrapper extends HttpServletRequestWrapper { public XssHttpSevletRequestWrapper(HttpServletRequest request) { super(request); } @Override public String getParameter(String name) { String value = super.getParameter(name); if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } return value; } @Override public String[] getParameterValues(String name) { String[] values = super.getParameterValues(name); if (values != null) { for (int i = 0; i \u0026lt; values.length; i++) { String value = values[i]; if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } values[i] = value; } } return values; } @Override public Map\u0026lt;String, String[]\u0026gt; getParameterMap() { Map\u0026lt;String, String[]\u0026gt; parameterMap = super.getParameterMap(); LinkedHashMap\u0026lt;String, String[]\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); if (parameterMap != null) { for (String key : parameterMap.keySet()) { String[] values = parameterMap.get(key); for (int i = 0; i \u0026lt; values.length; i++) { String value = values[i]; if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } values[i] = value; } map.put(key, values); } } return map; } @Override public String getHeader(String name) { String value = super.getHeader(name); if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } return value; } @Override public ServletInputStream getInputStream() throws IOException { ServletInputStream in = super.getInputStream(); InputStreamReader reader = new InputStreamReader(in, StandardCharsets.UTF_8); BufferedReader buffer = new BufferedReader(reader); StringBuilder body = new StringBuilder(); String line = buffer.readLine(); while (line != null){ body.append(line); line = buffer.readLine(); } buffer.close(); reader.close(); in.close(); Map\u0026lt;String, Object\u0026gt; map = JSONUtil.parseObj(body.toString()); Map\u0026lt;String, Object\u0026gt; result = new LinkedHashMap\u0026lt;\u0026gt;(); for (String key : map.keySet()) { Object value = map.get(key); if (value instanceof String){ if (!StrUtil.hasEmpty(value.toString())){ result.put(key, HtmlUtil.cleanHtmlTag(value.toString())); } }else { result.put(key, value); } } String json = JSONUtil.toJsonStr(result); ByteArrayInputStream bain = new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)); return new ServletInputStream() { @Override public boolean isFinished() { return false; } @Override public boolean isReady() { return false; } @Override public void setReadListener(ReadListener readListener) { } @Override public int read() throws IOException { return bain.read(); } }; } } 过滤请求\npackage com.example.emos.api.config.xss; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; /** * Description: xss过滤器 * 拦截所有的HTTP请求， * 然后调用上面创建的XssHttpServletRequestWrapper类 * * @author Rex * @date 2021-09-09 16:06 */ public class XssFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; XssHttpSevletRequestWrapper wrapper = new XssHttpSevletRequestWrapper(request); filterChain.doFilter(wrapper, servletResponse); } @Override public void destroy() { } } 自定义分页对象\npackage com.example.emos.api.common.dto; import java.io.Serializable; import java.util.List; /** * Description: 自定义分页 * * @author Rex * @date 2021-09-09 16:20 */ public class Pageination\u0026lt;T\u0026gt; implements Serializable { private static final long serialVersionUID = 1L; /** * 总记录数 */ private Long totalCount; /** * 每页记录数 */ private Integer pageSize; /** * 总页数 */ private Integer totalPage; /** * 当前页数 */ private Integer pageIndex; /** * 列表数据 */ private List\u0026lt;T\u0026gt; list; public Pageination(List\u0026lt;T\u0026gt; list, Long totalCount, Integer pageIndex, Integer pageSize){ this.list = list; this.totalCount = totalCount; this.pageSize = pageSize; this.pageIndex = pageIndex; this.totalPage = (int) Math.ceil((double) totalCount / pageSize); } } 用MybatixX插件自动生成pojo、dao、mapper\n自定义模板\n.meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;templates\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;domain\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;domain.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.java\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;${domain.basePackage}.domain\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;${domain.basePath}\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;mapperInterface\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;mapperInterface.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}Dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.java\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;${domain.basePackage}.dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;${domain.basePath}\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;mapperXml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;mapperXml.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}Dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;mapper\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;src/main/resources\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/templates\u0026gt; domain.ftl\npackage ${domain.packageName}; import lombok.Data; import javax.validation.constraints.NotBlank; import javax.validation.constraints.Size; import javax.validation.constraints.NotNull; import java.io.Serializable; \u0026lt;#list tableClass.importList as fieldType\u0026gt;${\u0026#34;\\n\u0026#34;}import ${fieldType};\u0026lt;/#list\u0026gt; /** * Description: ${tableClass.remark!} * * @TableName ${tableClass.tableName} * @author Rex */ @Data public class ${tableClass.shortClassName} implements Serializable { \u0026lt;#list tableClass.allFields as field\u0026gt; /** * ${field.remark!} */\u0026lt;#if !field.nullable || field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#if !field.nullable\u0026gt;\u0026lt;#if field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;@NotBlank(message=\u0026#34;[${field.remark!}]不能为空\u0026#34;)\u0026lt;#else\u0026gt;@NotNull(message=\u0026#34;[${field.remark!}]不能为空\u0026#34;)\u0026lt;/#if\u0026gt;\u0026lt;/#if\u0026gt;\u0026lt;#if field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;\u0026lt;#if !field.nullable\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;@Size(max= ${field.columnLength?c},message=\u0026#34;编码长度不能超过${field.columnLength?c}\u0026#34;)\u0026lt;/#if\u0026gt; private ${field.shortTypeName} ${field.fieldName}; \u0026lt;/#list\u0026gt; } mapperInterface.ftl\npackage ${mapperInterface.packageName}; import ${tableClass.fullClassName}; import org.apache.ibatis.annotations.Mapper; /** * Description: TODO * * @author Rex */ @Mapper public interface ${mapperInterface.fileName} { /** * 根据主键编号删除用户信息 * @param id 主键编号 * @return 影响记录数 */ int deleteByPrimaryKey(Long id); /** * 插入一条记录 * @param record 待插入的记录 * @return 影响记录数 */ int insert(${tableClass.shortClassName} record); /** * 插入指定字段，未指定的用默认值 * @param record 待插入的记录 * @return 影响记录数 */ int insertSelective(${tableClass.shortClassName} record); /** * 根据主键查询记录 * @param id 主键编号 * @return 记录对象 */ ${tableClass.shortClassName} selectByPrimaryKey(Long id); /** * 根据主键更新字段（不包括null） * @param record 待更新的记录 * @return 影响记录数 */ int updateByPrimaryKeySelective(${tableClass.shortClassName} record); /** * 根据主键更新字段（包括null） * @param record 待更新的记录 * @return 影响记录数 */ int updateByPrimaryKey(${tableClass.shortClassName} record); } mapperXml.ftl\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;${mapperInterface.packageName}.${baseInfo.fileName}\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; \u0026lt;#list tableClass.pkFields as field\u0026gt; \u0026lt;id property=\u0026#34;${field.fieldName}\u0026#34; column=\u0026#34;${field.columnName}\u0026#34; jdbcType=\u0026#34;${field.jdbcType}\u0026#34;/\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;#list tableClass.baseFields as field\u0026gt; \u0026lt;result property=\u0026#34;${field.fieldName}\u0026#34; column=\u0026#34;${field.columnName}\u0026#34; jdbcType=\u0026#34;${field.jdbcType}\u0026#34;/\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt;${field.columnName}\u0026lt;#sep\u0026gt;,\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;selectByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34; /\u0026gt; from ${tableClass.tableName} where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;delete id=\u0026#34;deleteByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34;\u0026gt; delete from ${tableClass.tableName} where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026lt;#if (tableClass.pkFields?size==1)\u0026gt; keyColumn=\u0026#34;${tableClass.pkFields[0].columnName}\u0026#34; keyProperty=\u0026#34;${tableClass.pkFields[0].fieldName}\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026lt;/#if\u0026gt;\u0026gt; insert into ${tableClass.tableName} ( \u0026lt;#list tableClass.allFields as field\u0026gt;${field.columnName}\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt;) values (\u0026lt;#list tableClass.allFields as field\u0026gt;${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt;) \u0026lt;/insert\u0026gt; \u0026lt;insert id=\u0026#34;insertSelective\u0026#34;\u0026lt;#if (tableClass.pkFields?size==1)\u0026gt; keyColumn=\u0026#34;${tableClass.pkFields[0].columnName}\u0026#34; keyProperty=\u0026#34;${tableClass.pkFields[0].fieldName}\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026lt;/#if\u0026gt;\u0026gt; insert into ${tableClass.tableName} \u0026lt;trim prefix=\u0026#34;(\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt;${field.fieldName},\u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026#34;values (\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt;${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}},\u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKeySelective\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; update ${tableClass.tableName} \u0026lt;set\u0026gt; \u0026lt;#list tableClass.baseBlobFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}, \u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/set\u0026gt; where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKey\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; update ${tableClass.tableName} set \u0026lt;#list tableClass.baseBlobFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt; where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 配置\n","permalink":"https://rexhub.space/posts/proj/emos/emos%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","summary":"emos项目准备 项目结构 已有项目： 工作流项目(emos-workflow) 小程序项目(emos-wx) 小程序后端项目(emos-wx-api) 待开发项目 Web办公系统前端项目(emos-vue) Web办公系统后端项目(emos-api) 数据表分类： 序号 类型 特征 备注 1 工作流数据表 以 act_ 开头 存储工作流的各项数据 2 定时器数据表 以 qrtz_ 开头 存储QuartZ定时器数据 3 业务表 以 tb_ 开头 保存业务数据 4 系统表 以 sys_ 开头 保存系统配置信息 后端： 依赖库： Lombok \u0026ndash; 生成对象的Get/Set方法\nSpring Web \u0026ndash; spring的web开发框架\nMyBatis Framework \u0026ndash; mybatis的开发框架\nMySQL Driver \u0026ndash; MySQL数据库驱动\nSpring Data Redis(Access + Driver) \u0026ndash; Redis连接+驱动工具\nSpring Data MongoDB \u0026ndash; MongoDB连接工具\nSpring for RabbitMQ \u0026ndash; RabbitMQ消息队列连接工具","title":"Emos项目搭建"}]