[{"content":"后台管理系统    baseUrl = \u0026ldquo;http://localhost:8090/fraud-prevention/api\u0026rdquo;\n  服务器Url=\u0026ldquo;http://1.117.91.88:52016/fraud-prevention/api\u0026rdquo;\n   通用模块 获取验证码   url: /admin/captcha\n  method: Get\n  request body: 空\n  response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { token: \u0026#34;xxxxxx\u0026#34;, //验证码token captchaImg: \u0026#34;data:image/jpeg;base64,xxxxxx\u0026#34;, //base64格式的验证码图片 } }   获取所有模块信息   url: /admin/modules\n  method: Get\n  request body: 空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;moduleCode\u0026#34;: \u0026#34;USER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;moduleCode\u0026#34;: \u0026#34;ROLE\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;moduleCode\u0026#34;: \u0026#34;PERM\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;权限管理\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;moduleCode\u0026#34;: \u0026#34;TEACHER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34; } ] }   需提前登录\n  获取所有行为(增删改查)信息   url: /admin/actions\n  method: Get\n  request body: 空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;actionCode\u0026#34;: \u0026#34;INSERT\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;actionCode\u0026#34;: \u0026#34;DELETE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;actionCode\u0026#34;: \u0026#34;UPDATE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;actionCode\u0026#34;: \u0026#34;SELETE\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; } ] }   需提前登录\n  上传图片（上传头像的时候需要）：   url: /admin/image\n  method: Post\n  request body :\n   参数 说明 示例     file 必填，图片       response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;https://cdn.rexweb.xyz/xxxx\u0026#34; }   删除图片（点击取消后需要）   url: /admin/image\n  method: Delete\n  request param:\n   参数 说明 示例     url 必填，图片的地址 https://cdn.rexweb.xyz/xxxx      response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   用户模块 登录   url: /admin/login\n  method: Post\n  request body\n   参数 说明 示例     username 用户名 admin   password 密码 admin   token 验证码的token    code 验证码 cwca1      response header\n   参数 说明 示例     Authorization 用户登录的token，其他的请求，请求头都要带上 xxxxx      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   获取当前登录用户信息   url:/admin/currentuser\n  method: Get\n  request body: 空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;password\u0026#34;: null, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexweb.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ], \u0026#34;perms\u0026#34;: [ \u0026#34;ROOT\u0026#34; ] } }   登出   url: /admin/logout\n  method: Get\n  request body：空\n  response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   新增用户（初始化密码88888888）：   url: /admin/user\n  method: Post\n  request body:\n   参数 说明 示例     username 必填，用户名 ceshi   name 必填，名字，2-10位英文、中文、数字 测试   avatarUrl 非必填，头像地址，若无，有默认头像地址 https://xxx/xx.jpg   sex 必填，性别，0-男，1-女 0   tel 必填，手机号，11位 17777777777   email 必填，邮箱 ceshi@163com   roles 必填，数组，角色id [0]      response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   删除用户：   url: /admin/users\n  method: Delete\n  request body:\n   参数 说明 示例     ids 必填，用户的id [0]      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   修改用户：   url: /admin/user\n  method: Put\n  request body:\n   参数 说明 示例     id 必填，待修改用户编号 xxxxx   name 非必填，名字 测试   avatarUrl 非必填，头像地址，若无，有默认头像地址 https://xxx/xx.jpg   sex 非必填，性别，0-男，1-女 0   tel 非必填，手机号，11位 17777777777   email 非必填，邮箱 ceshi@163com      response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   查询用户：   url: /admin/user/{userId}\n  method: Get\n  request body:空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexweb.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ] } }   分页查询：   url: /admin/users\n  method: Get\n  request params(url 路径传参)\n   参数 说明 示例     page 非必填，页数，默认5 5   size 非必填，每页数量，默认10，不能超过50 10   orderFiled 非必填，排序字段，默认id id   order 非必填，排序方式，可选值asc, desc，默认asc asc   username 非必填，用户名模糊查询 ce      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;http://cdn.rexweb.xyz/img/20210823181936.png\u0026#34;, \u0026#34;sex\u0026#34;: 1, \u0026#34;tel\u0026#34;: \u0026#34;1377777777\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;root@163.com\u0026#34;, \u0026#34;roles\u0026#34;: [ \u0026#34;admin\u0026#34; ] } ], \u0026#34;total\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } }   分配用户角色：   url:/admin/user/role\n  method: Put\n  request body:\n   参数 说明 示例     id 必填，用户id 0   roles 必填，角色id数组 [1, 2, 3]      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   重置密码（88888888）：   url: /admin/repass/{userId}\n  method: Put\n  request body：空\n  response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   tip：修改后，需重新登录，后端会使token失效；\n  修改密码：   url: /admin/user/updatepass\n  method: Put\n  request body：\n   参数 说明 示例     newPassword 必填，新密码 xxxxxx   oldPassword 必填，旧密码 xxxxx      response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   tip：修改后，需重新登录，后端会使token失效；\n  角色模块 查询所有角色（用于给用户分配权限）   url:/admin/role/all\n  method: Get\n  request body\n  resposne body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;createTime\u0026#34;: 1635994114000, \u0026#34;updateTime\u0026#34;: 1635994120000, \u0026#34;creator\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;updater\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;systemic\u0026#34;: 1 } ] }   分页查询角色   url: /admin/roles\n  method: Get\n  request param(注意这里用的url传参)\n   参数 说明 示例     name 非必填，1-10位中文、英文组成 root   page 非必填，不能小于1 1   size 非必填，必须在10~50之间 20   orderFiled 非必填，排序字段，默认id id   order 非必填，排序方式，可选值asc, desc，默认asc asc      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;records\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;roleName\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;users\u0026#34;: 1, \u0026#34;permissions\u0026#34;: 1, \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;systemic\u0026#34;: 1 } ], \u0026#34;total\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;orders\u0026#34;: [ { \u0026#34;column\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;asc\u0026#34;: true } ], \u0026#34;optimizeCountSql\u0026#34;: true, \u0026#34;hitCount\u0026#34;: false, \u0026#34;countId\u0026#34;: null, \u0026#34;maxLimit\u0026#34;: null, \u0026#34;searchCount\u0026#34;: true, \u0026#34;pages\u0026#34;: \u0026#34;1\u0026#34; } }   查询角色详情   url:/admin/role/{id}\n  method: Get\n  request body: 空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;0\u0026#34; ], \u0026#34;desc\u0026#34;: \u0026#34;超级管理员\u0026#34; } }   新增角色   url:/admin/role\n  method: Post\n  request body\n   参数 说明 示例     name 必填，角色名称，2-10位英文、中文、数字 test   permissions 必填非空，权限数组 [0]   desc 必填，角色描述，不能超过20个字符 test      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   删除角色   url: /admin/role\n  method: Delete\n  request body:\n   参数 说明 示例     ids 必填非空，但删除权限id数组 [1457736051796123650]      response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   修改角色   url: /admin/role\n  method: Put\n  request body\n   参数 说明 示例     id 必填，待修改的角色id    name 非必填，角色名称，2-10位英文、中文、数字 test   permissions 非必填，权限数组 [0]   desc 非必填，角色描述，不能超过20个字符 test      response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: null }   权限模块 查询所有权限（用于给角色分配权限）   url：/admin/perms\n  method: Get\n  request body: 空\n  response body：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;添加\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;删除\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;11\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;修改\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34;, \u0026#34;actionName\u0026#34;: \u0026#34;查询\u0026#34; } ] }   ","permalink":"https://rex0520.github.io/posts/proj/doc/fraudprevention%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","summary":"后台管理系统    baseUrl = \u0026ldquo;http://localhost:8090/fraud-prevention/api\u0026rdquo;\n  服务器Url=\u0026ldquo;http://1.117.91.88:52016/fraud-prevention/api\u0026rdquo;\n   通用模块 获取验证码   url: /admin/captcha\n  method: Get\n  request body: 空\n  response body\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { token: \u0026#34;xxxxxx\u0026#34;, //验证码token captchaImg: \u0026#34;data:image/jpeg;base64,xxxxxx\u0026#34;, //base64格式的验证码图片 } }   获取所有模块信息   url: /admin/modules\n  method: Get\n  request body: 空\n  response body:\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;moduleCode\u0026#34;: \u0026#34;USER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;用户管理\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;moduleCode\u0026#34;: \u0026#34;ROLE\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;角色管理\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;moduleCode\u0026#34;: \u0026#34;PERM\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;权限管理\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;moduleCode\u0026#34;: \u0026#34;TEACHER\u0026#34;, \u0026#34;moduleName\u0026#34;: \u0026#34;教师管理\u0026#34; } ] }   需提前登录","title":"FraudPrevention开发文档"},{"content":"微信支付  微信支付功能的实现需要调用微信官方的支付接口，而微信支付也有多种形式，如:JSAPI支付、APP支付、Native支付、小程序支付等等，接口也有V2、V3版本，这里主要说明Native的V3版本的使用。特别需要注意的是，使用微信支付功能的接口需要有商户号。\n  在支付的功能中，必不可少的是商品订单和支付订单，商品订单是本地后台系统生成的，而我这里使用的案例是用罚款单为例并非商品。支付订单是微信服务器生成的，只需要调用微信支付API\n微信支付官方文档\n 微信支付前期准备 开通微信支付功能 对于商家来说，想要开通微信支付，必须要去微信商户平台注册（https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F），然后把工商登记证明、企业银行账户开户证明、组织机构代码证提交上去，经过半天的审核，如果没有问题，你就开通了微信支付功能。\n如果想要在网站或者小程序上面使用微信支付，还要在微信公众平台上面关联你自己的微信商户账号。前提是你的微信开发者账号必须是企业身份，个人身份的开发者账号是无法调用微信支付API的。\n引入官方的SDK包  说明下这里的微信官方sdk主要对签名方面、加密解密方面做了较好的支持，其他方面还是要自己构造参数、发送请求。\n sdk官方文档\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.wechatpay-apiv3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;wechatpay-apache-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; WechatPay.java\n 这个是我对sdk做了个进一步的封装，这里是初始化\n package com.example.emos.api.common.util; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import com.example.emos.api.common.exception.EmosException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder; import com.wechat.pay.contrib.apache.httpclient.auth.AutoUpdateCertificatesVerifier; import com.wechat.pay.contrib.apache.httpclient.auth.PrivateKeySigner; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Credentials; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Validator; import com.wechat.pay.contrib.apache.httpclient.util.AesUtil; import com.wechat.pay.contrib.apache.httpclient.util.PemUtil; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpEntity; import org.apache.http.StatusLine; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.util.EntityUtils; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.*; import java.net.URISyntaxException; import java.nio.charset.StandardCharsets; import java.security.*; /** * Description: 微信支付工具类 * * @author Rex * @date 2021-10-18 12:54 */ @Component @Slf4j public class WechatPay { /** * 微信支付APPID */ @Value(\u0026#34;${wx.pay.app-id}\u0026#34;) public String appId; /** * 微信商户id */ @Value(\u0026#34;${wx.pay.mch-id}\u0026#34;) public String mchId; /** * 序列号 */ @Value(\u0026#34;${wx.pay.serial-no}\u0026#34;) public String serialNo; /** * 数字密钥地址 */ @Value(\u0026#34;${wx.pay.private_key_path}\u0026#34;) private String privateKeyPath; /** * 私钥 */ @Value(\u0026#34;${wx.pay.api_v3_key}\u0026#34;) private String apiV3Key; @Value(\u0026#34;${wx.pay.notify_url}\u0026#34;) private String notifyUrl; private CloseableHttpClient getClient(){ WechatPayHttpClientBuilder builder; try { //生成签名  PrivateKey privateKey = PemUtil.loadPrivateKey(new FileInputStream(privateKeyPath)); AutoUpdateCertificatesVerifier verifier = new AutoUpdateCertificatesVerifier( new WechatPay2Credentials(mchId, new PrivateKeySigner(serialNo, privateKey)), apiV3Key.getBytes(StandardCharsets.UTF_8)); builder = WechatPayHttpClientBuilder.create() .withMerchant(mchId, serialNo, privateKey) .withValidator(new WechatPay2Validator(verifier)); } catch (FileNotFoundException e) { throw new EmosException(\u0026#34;数字签名路径有误：\u0026#34; + e.getMessage()); } return builder.build(); } ...... } application.yml文件中配置参数  提前在配置文件中配置好必要的参数\n # 我的app-id:wx66f359799ea4bb7dapp-secret:a8a27ab43054b6d7b2b28fbd0cc14137# 老师的企业账户pay:app-id:\u0026#34;xxxxxxxxxxxxx\u0026#34;# appIdmch-id:\u0026#34;xxxxxxxx\u0026#34;# 商户idserial-no:\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;# 请求随机串notify_url:\u0026#34;https://公网地址(可用内网穿透的地址)/emos-api/amect/receiveMessage\u0026#34;private_key_path:\u0026#34;src/main/resources/apiclient_key.pem\u0026#34;# 数字证书的地址api_v3_key:\u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34;# apiV3key使用内网穿透技术 因为我们在支付订单结束之后需要让微信系统告诉我们后台系统支付结果，那要怎么告诉微信呢，让他访问localhost吗？肯定访问不到，访问我们主机的ip吗？可是我们本地电脑的IP没有固定的公网ip，局域网下的ip虽然是固定的，但是微信系统也访问不到，他们又不在我们的局域网下，广域网的ip虽然是访问的到，但是不是固定的。我们可以把系统部署到云服务器上，让微信系统访问我们云服务上的后台系统，不过在测试阶段，我们都是用自己的本地上的系统，我们可以用内网穿透的技术，将自己系统的端口号映射到外网，这样微信系统就可以访问的到了。\n目前常见的内网穿透技术\n 花生壳 Natapp 量子互联 ngrok(个人最常用)：免费 Frp：用自己的公网服务做代理，免费，但是需要一台云服务器  创建支付订单  这里需要着重说明创建支付订单的时候需要一个唯一ID，可以用UUID生成，若id重复了，微信服务器会提示商品ID已经用过一次了\n URL：https://api.mch.weixin.qq.com/v3/pay/transactions/native\n请求参数（必要）：\n   参数 含义 类型 例子     appid 公众号ID String wxd678efh567hg6787   mch_id 商户号ID String 1230000109   description 商品描述 string Image形象店-深圳腾大-QQ公仔   out_trade_no 商品订单号 String 20150806125346   notify_url 通知地址 String https://www.weixin.qq.com/wxpay/pay.php   amount 订单金额 Object {total: 100(单位分), currency: \u0026ldquo;CNY\u0026rdquo;}    响应：\n   参数 含义 类型 例子     code_url 二维码链接 String weixin://wxpay/bizpayurl/up?pr=NwY5Mz9\u0026amp;groupid=00    以下是WechatPay.java中创建支付的示例代码\n/** * 生成订单 * @param outTradeNo 订单编号，相当于amect中的uuid * @param amount 金额 * @return 支付二维码 */ public String generateOrder(String outTradeNo, Integer amount){ ByteArrayOutputStream bos = null; try { //获取HTTP客户端  CloseableHttpClient client = getClient(); //构造请求  /** * 下单URL */ String generateOrder = \u0026#34;https://api.mch.weixin.qq.com/v3/pay/transactions/native\u0026#34;; URIBuilder uriBuilder = new URIBuilder(generateOrder); HttpPost httpPost = new HttpPost(uriBuilder.build()); httpPost.addHeader(\u0026#34;Content-type\u0026#34;,\u0026#34;application/json; charset=utf-8\u0026#34;); httpPost.addHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); bos = new ByteArrayOutputStream(); ObjectMapper objectMapper = new ObjectMapper(); ObjectNode rootNode = objectMapper.createObjectNode(); rootNode.put(\u0026#34;appid\u0026#34;, appId); rootNode.put(\u0026#34;mchid\u0026#34;, mchId); rootNode.put(\u0026#34;description\u0026#34;, \u0026#34;...发起的测试\u0026#34;); rootNode.put(\u0026#34;notify_url\u0026#34;, notifyUrl); rootNode.put(\u0026#34;out_trade_no\u0026#34;, outTradeNo); rootNode.putObject(\u0026#34;amount\u0026#34;) .put(\u0026#34;total\u0026#34;, amount); rootNode.putObject(\u0026#34;scene_info\u0026#34;) .put(\u0026#34;payer_client_ip\u0026#34;, \u0026#34;localhost\u0026#34;); objectMapper.writeValue(bos, rootNode); httpPost.setEntity(new StringEntity(bos.toString(\u0026#34;UTF-8\u0026#34;), StandardCharsets.UTF_8)); //执行并获取放回结果  CloseableHttpResponse response = client.execute(httpPost); JSONObject res = JSONUtil.parseObj(EntityUtils.toString(response.getEntity())); String codeUrl = (String) res.get(\u0026#34;code_url\u0026#34;); if (codeUrl == null){ throw new EmosException(\u0026#34;支付失败：\u0026#34; + res.get(\u0026#34;message\u0026#34;).toString()); } return codeUrl; } catch (Exception e) { log.error(\u0026#34;支付失败\u0026#34;, e); throw new EmosException(\u0026#34;支付失败: \u0026#34;+e.getMessage()); } finally { if (bos != null){ try { bos.close(); } catch (IOException e) { throw new EmosException(\u0026#34;关闭流失败: \u0026#34; + e.getMessage()); } } } } 执行付款 执行付款的时候需要用户向微信平台（注意是微信平台而不是自己的系统）发起查询支付订单的请求，核实订单信息，确定后再执行扣款。因此这个步骤就交给微信平台了。\n确认付款结果 成功支付后，需要回馈商家支付结果，可以直接通过微信系统的回调函数告诉商家系统，但是万一出现网络问题商家系统没收到回调呢，可以让商家主动查询付款结果，比如这里就可以点击支付成功按钮，前端页面就会向商户系统发起Ajax请求，商户系统会主动向微信服务器发起查询请求，核对是否支付成功，若支付成功就修改商品订单的状态为已付款。\n推送付款结果给前端页面 不仅仅商户系统需要确定支付状态，用户也需要知道，所以前端也需要发聩用户订单支付结果。那咋知道呢？\n  一种方法就是通过轮询，前端弹出支付二维码以后，创建一个定时器，每隔几秒向商户系统发出请求，查询商品订单是否已付款。这个操作虽然简单，但是增大了网络开销，每次的http都需要创建连接和协议握手\n  另一种方式就是通过WebSocket让前端和后端建立长连接。传统的HTTP协议是短链接，请求结束之后，HTTP连接就断开了。而WebSocket的长连接可以让前端后端使用某个连接反复发送和接受数据，很常见的也很基础的应用就是可以通过长连接创建一个聊天室。WebSocket省去了反复连接和协议握手的时间。若担心长时间建立长连接耗费资源，可以给WebSocket连接设置一个超时时间。\n服务器把每个WebSocket连接都缓存起来，然后想要推送数据给前端的时候，就从缓存中找到与之对应的连接即可。\n  ","permalink":"https://rex0520.github.io/posts/api/pay/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/","summary":"微信支付  微信支付功能的实现需要调用微信官方的支付接口，而微信支付也有多种形式，如:JSAPI支付、APP支付、Native支付、小程序支付等等，接口也有V2、V3版本，这里主要说明Native的V3版本的使用。特别需要注意的是，使用微信支付功能的接口需要有商户号。\n  在支付的功能中，必不可少的是商品订单和支付订单，商品订单是本地后台系统生成的，而我这里使用的案例是用罚款单为例并非商品。支付订单是微信服务器生成的，只需要调用微信支付API\n微信支付官方文档\n 微信支付前期准备 开通微信支付功能 对于商家来说，想要开通微信支付，必须要去微信商户平台注册（https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F），然后把工商登记证明、企业银行账户开户证明、组织机构代码证提交上去，经过半天的审核，如果没有问题，你就开通了微信支付功能。\n如果想要在网站或者小程序上面使用微信支付，还要在微信公众平台上面关联你自己的微信商户账号。前提是你的微信开发者账号必须是企业身份，个人身份的开发者账号是无法调用微信支付API的。\n引入官方的SDK包  说明下这里的微信官方sdk主要对签名方面、加密解密方面做了较好的支持，其他方面还是要自己构造参数、发送请求。\n sdk官方文档\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.wechatpay-apiv3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;wechatpay-apache-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; WechatPay.java\n 这个是我对sdk做了个进一步的封装，这里是初始化\n package com.example.emos.api.common.util; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import com.example.emos.api.common.exception.EmosException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder; import com.wechat.pay.contrib.apache.httpclient.auth.AutoUpdateCertificatesVerifier; import com.wechat.pay.contrib.apache.httpclient.auth.PrivateKeySigner; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Credentials; import com.wechat.pay.contrib.apache.httpclient.auth.WechatPay2Validator; import com.wechat.pay.contrib.apache.httpclient.util.AesUtil; import com.wechat.pay.contrib.apache.httpclient.util.PemUtil; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpEntity; import org.apache.http.StatusLine; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.","title":"微信支付接口"},{"content":"腾讯视频会议的使用-TRTC技术 概述：  TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n 后端的准备  首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n 用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n//UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥  usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire))) 关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\npackage com.example.emos.api.config.tencet; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import org.bson.internal.Base64; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.zip.Deflater; /** * Description: 腾讯TRTC工具类 * * @author Rex * @date 2021-09-29 10:48 */ import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; @Component public class TRTCUtil { @Value(\u0026#34;${tencent.trtc.appId}\u0026#34;) private int appId; @Value(\u0026#34;${tencent.trtc.expire}\u0026#34;) private int expire; @Value(\u0026#34;${tencent.trtc.secretKey}\u0026#34;) private String secretKey; /** * 计算UserSig签名 * 函数内部使用HMAC-SHA256 非对称加密算法，对SdkAppId、userID和ExpireTime进行加密。 * @param userId 用户id * @return 用户签名 */ public String genUserSig(String userId) { return GenTLSSignature(appId, userId, expire, null, secretKey); } /** * 生成TLS票据 * @param sdkappid 应用的id * @param userId 用户id * @param expire 有效期，单位是秒 * @param userbuf 默认填写null * @param priKeyContent 生成tls票据使用的私钥内容 * @return 如果出错，会返回为空，或者有异常打印，成功返回有效的票据 */ private String GenTLSSignature(long sdkappid, String userId, long expire, byte[] userbuf, String priKeyContent) { if (StrUtil.isEmpty(priKeyContent)) { return \u0026#34;\u0026#34;; } long currTime = System.currentTimeMillis() / 1000; JSONObject sigDoc = new JSONObject(); sigDoc.set(\u0026#34;TLS.ver\u0026#34;, \u0026#34;2.0\u0026#34;); sigDoc.set(\u0026#34;TLS.identifier\u0026#34;, userId); sigDoc.set(\u0026#34;TLS.sdkappid\u0026#34;, sdkappid); sigDoc.set(\u0026#34;TLS.expire\u0026#34;, expire); sigDoc.set(\u0026#34;TLS.time\u0026#34;, currTime); String base64UserBuf = null; if (null != userbuf) { base64UserBuf = Base64.encode(userbuf); sigDoc.set(\u0026#34;TLS.userbuf\u0026#34;, base64UserBuf); } String sig = hmacsha256(sdkappid, userId, currTime, expire, priKeyContent, base64UserBuf); if (sig.length() == 0) { return \u0026#34;\u0026#34;; } sigDoc.set(\u0026#34;TLS.sig\u0026#34;, sig); Deflater compressor = new Deflater(); compressor.setInput(sigDoc.toString().getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;))); compressor.finish(); byte[] compressedBytes = new byte[2048]; int compressedBytesLength = compressor.deflate(compressedBytes); compressor.end(); return new String(base64EncodeUrl(Arrays.copyOfRange(compressedBytes, 0, compressedBytesLength))); } /** * 用HmacSHA256算法进行加密 * @param sdkappid 应用id * @param userId 用户id * @param currTime 当前时间戳 * @param expire 有效期，单位秒 * @param priKeyContent 密钥内容 * @param base64Userbuf 默认填写null * @return 加密结果 */ private static String hmacsha256(long sdkappid, String userId, long currTime, long expire, String priKeyContent, String base64Userbuf) { String contentToBeSigned = \u0026#34;TLS.identifier:\u0026#34; + userId + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.sdkappid:\u0026#34; + sdkappid + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.time:\u0026#34; + currTime + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.expire:\u0026#34; + expire + \u0026#34;\\n\u0026#34;; if (null != base64Userbuf) { contentToBeSigned += \u0026#34;TLS.userbuf:\u0026#34; + base64Userbuf + \u0026#34;\\n\u0026#34;; } try { byte[] byteKey = priKeyContent.getBytes(\u0026#34;UTF-8\u0026#34;); Mac hmac = Mac.getInstance(\u0026#34;HmacSHA256\u0026#34;); SecretKeySpec keySpec = new SecretKeySpec(byteKey, \u0026#34;HmacSHA256\u0026#34;); hmac.init(keySpec); byte[] byteSig = hmac.doFinal(contentToBeSigned.getBytes(\u0026#34;UTF-8\u0026#34;)); return Base64.encode(byteSig); } catch (UnsupportedEncodingException e) { return \u0026#34;\u0026#34;; } catch (NoSuchAlgorithmException e) { return \u0026#34;\u0026#34;; } catch (InvalidKeyException e) { return \u0026#34;\u0026#34;; } } /** * 将base64字符串转换成URL格式的字符串 * @param input base64数据 * @return url可接受的base64数据 */ private static byte[] base64EncodeUrl(byte[] input) { byte[] base64 = Base64.encode(input).getBytes(); for (int i = 0; i \u0026lt; base64.length; ++i) switch (base64[i]) { case \u0026#39;+\u0026#39;: base64[i] = \u0026#39;*\u0026#39;; break; case \u0026#39;/\u0026#39;: base64[i] = \u0026#39;-\u0026#39;; break; case \u0026#39;=\u0026#39;: base64[i] = \u0026#39;_\u0026#39;; break; default: break; } return base64; } } 将UserSig返回给前端 接下的工作就非常简单了，将userId、appId、userSig生成返回给前端，接下来的写法就不多做说明，下面贴上返回的json格式\n{ \u0026#34;code\u0026#34;:200, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;userSig\u0026#34;:\u0026#34;eJyrVgrxCdZLrSjILEpVsrIwMzEw0AELlaUWKVkpGekZKEH4xSnZiQUFmSlKVoZANaZmlgZGUJWZKal5JZlpmRANJjD1melArmdhWUV6bnGZa3pVWZV5uXaqRZFbZlBJSopjuWNEYpZ-hllZqltiQEaUV7ktVGNJZi7QJYZmxiYGhuYmZqa1AFiAMM0_\u0026#34;, \u0026#34;userId\u0026#34;:24, \u0026#34;appId\u0026#34;:\u0026#34;1400569020\u0026#34; } } 前端 检查环境  Trtc.checkSystemRequirements() ，这个函数用于判断当前浏览器系统是否可以满足trtc的使用环境，在创建trtc之前要用这个方法检查一下，这个函数是异步的，要使用同步可以用\ntrtc.checkSystemRequirements().then(()=\u0026gt;{ // 同步的函数 })  日志  Trtc.Logger.setLogLevel(Trtc.Logger.LogLevel.ERROR)，设置trtc的日志输出级别\n 创建TrtcClient  Trtc.createClient()，需要传入mode、sdkAppId、userId、userSig\n 使用示例:\nlet client = TRTC.createClient({ mode: \u0026#39;rtc\u0026#39;, sdkAppId: that.appId, userId: that.userId + \u0026#39;\u0026#39;, userSig: that.userSig }); 监听新增远端流  client.on(\u0026ldquo;stream-add\u0026rdquo;, event=\u0026gt;{})，当远端用户发布流后触发，一般在这个回调函数里要订阅远端流。通过远端流来获取新增的用户id，再更新到用户列表里；订阅远端流需要调用client.subscribe(remoteStream)，这里的remote可以由remote.stream调用获取。订阅好了remoteStream，就可以通过remoteStream.getUserId()获取用户信息。以下是代码示例：\n client.on(\u0026#39;stream-added\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //订阅远端流  client.subscribe(remoteStream); //从远端流获得远程用户userId(创建TrtcClient对象时候的参数)  let userId = remoteStream.getUserId(); that.stream[userId] = remoteStream; }); 监听远端流订阅成功  client.on(\u0026ldquo;stream-subscribed\u0026rdquo;, event=\u0026gt;{}), 若检测到客户端也调用了subscribe()，订阅了远端流，则触发该回调函数。下面是使用示例，remoteStream.play(userId + \u0026ldquo;\u0026quot;)会播放该用户id的音视频讯号\n client.on(\u0026#39;stream-subscribed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; let userId = remoteStream.getUserId(); //找到视频墙中某个远端用户的格子，把其中用于显示视频的DIV，置顶覆盖用户信息  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: 1 }); //在这个置顶的DIV中播放远端音视频讯号  remoteStream.play(userId + \u0026#39;\u0026#39;); }); 监听远端删除流  client.on(\u0026ldquo;stream-remove\u0026rdquo;, event=\u0026gt;{}),当远端用户退出的时候调用该回调函数。一般的，再这个函数里会关闭和该用户有关的信息，以下是代码示例\n //订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //取消订阅该远端流  client.unsubscribe(remoteStream); let userId = remoteStream.getUserId(); //TODO 在页面右侧的用户列表中删除该用户  //停止播放远端流视频，并且关闭远端流  remoteStream.stop(); remoteStream.close(); //删除模型层JSON中保存的远端流对象  delete that.stream[userId]; //把视频墙中该用户格子的视频DIV控件置底，显示用户基本信息  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); }); 加入会议室  client.join({ roomId: that.roomId})，加入会议，这个roomId一般由后端生成获得。因为这个函数也是异步函数，所以要进入会议室后创建本地流、播放本地音视频、配置信息之类的要在client.join({ roomId: that.roomId}).then()的then里面调用，以下是代码示例\n client .join({ roomId: that.roomId }) .then(() =\u0026gt; { //成功进入会议室，然后创建本地流  let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: true, video: true }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); //设置分辨率  //初始化本地音视频流  localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }).then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //视频墙中第一个格子中的视频DIV置顶  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); //播放本地音视频流  localStream.play(\u0026#39;localStream\u0026#39;); //向远端用户推送本地流  client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }).catch(error =\u0026gt; { console.error(\u0026#39;进入房间失败: \u0026#39; + error); }); 订阅语音音量事件  client.on(\u0026ldquo;audio-volumn\u0026rdquo;, event=\u0026gt;{})，可以监听本地和远端的麦克风音量变化，一般会配合client.enableAudioVolumeEvaluation(30)使用，他会指定每隔一段事件调用这个事件，这里是30ms。下面是使用示例\n //订阅语音事件（无论本地还是远端说话，都会触发这个事件） client.on(\u0026#39;audio-volume\u0026#39;, event =\u0026gt; { event.result.forEach(({ userId, audioVolume, stream }) =\u0026gt; { //说话声音超过5，就设置话筒音量动画  if (audioVolume \u0026gt; 5) { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `${100 - audioVolume * 3}%`); } else { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `100%`); } }); }); // 开启音量回调函数，并设置每 30ms 触发一次事件 client.enableAudioVolumeEvaluation(30); 监听远断流删除流  client.on(\u0026lsquo;stream-removed\u0026rsquo;, event-\u0026gt;{})，这个是监听到远端退出会议的时候调用的方法，以下是使用示例\n //订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; client.unsubscribe(remoteStream); //取消订阅该远端流的所有事件  let userId = remoteStream.getUserId(); //上线用户列表中删除该用户  let i = that.userList.findIndex(function(one) { return one.userId == userId; }); that.userList.splice(i, 1); //停止播放远端流视频，并且关闭远端流  remoteStream.stop(); remoteStream.close(); //把远端流从stream中删除  delete that.stream[userId]; //把远端视频播放界面设置为-1层  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); }); 退出视频会议室  client.unpublish()，这也是一个异步函数，要在退出后清除一些信息也要在then方法里。下面是使用示例,里面的client.leave是离开里面的会议室\n//获取当前本地使用的流，有可能是本地流或者共享流 let stream = that.getStream(); that.client.unpublish(stream).then(() =\u0026gt; { // 取消发布本地流成功  that.client .leave() .then(() =\u0026gt; { console.log(\u0026#39;成功退出会议室\u0026#39;); //关闭本地流或者共享流  stream.stop(); stream.close(); //清空模型层的本地流  that.localStream = null; that.shareStream = null; //清空模型层的远端流  that.stream = {}; //销毁TrtcClient对象  that.client = null; that.userList = []; //清空用户列表  that.videoStatus = true; that.micStatus = true; that.shareStatus = false; //视频墙上本地流DIV区域置底  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#localStream\u0026#39;).html(\u0026#39;\u0026#39;); //TODO 如果是播放大屏视频的时候退出会议，退出会议后需要隐藏大屏  }) .catch(error =\u0026gt; { console.error(\u0026#39;成功退出会议室失败\u0026#39; + error); }); });  打开/关闭摄像头：  localStream.unmuteVideo()/localStream.muteVideo()，localStream是本地流,在创建会议的时候生成\n 打开/关闭麦克风  stream.unmuteAudio()/stream.muteAudio()，stream是本地流或共享流\n 检测是否满足屏幕共享环境  TRTC.isScreenShareSupported()，与checkSystemRequirements类似\n 创建屏幕共享  同样的也是调用TRTC.createStream创建共享流，需要传入screen:true参数，下面是使用示例\n let shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId }); 设置屏幕的分辨率  shareStream.setScreenProfile(\u0026lsquo;1080p\u0026rsquo;);\n 下面是屏幕共享的使用示例\nshareHandle: function() { let that = this; //判断用户是否进入视频会议室  if (!that.meetingStatus) { that.$alert(\u0026#39;请先进入视频会议才能共享屏幕\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } //检查浏览器是否支持屏幕共享  if (!TRTC.isScreenShareSupported()) { //提示当前浏览器不支持在线视频会议  this.$alert(\u0026#39;当前浏览器不支持屏幕共享\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } that.shareStatus = !that.shareStatus; //开启屏幕共享  if (that.shareStatus) { //创建共享流  let shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId }); shareStream.setScreenProfile(\u0026#39;1080p\u0026#39;); that.shareStream = shareStream; shareStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始共享流失败 \u0026#39; + error); }) .then(() =\u0026gt; { //取消推送本地视频流  that.client.unpublish(that.localStream).then(() =\u0026gt; { that.localStream.close(); //关闭本地流  that.localStream = null; //本地流设置为空  //隐藏本地视频窗口  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: -1 }); that.client.publish(shareStream); //向远端推送共享流  }); }); } //关闭屏幕共享  else { //重建本地视频流  let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: that.micStatus, video: that.videoStatus }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //取消共享流的推流  that.client.unpublish(that.shareStream).then(() =\u0026gt; { that.shareStream.close(); //关闭共享流  that.shareStream = null; //共享流设置为空  //显示本地视频窗口  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); localStream.play(\u0026#39;localStream\u0026#39;); //播放本地流  //向远端推送本地视频流  that.client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }); } }, ","permalink":"https://rex0520.github.io/posts/api/%E8%85%BE%E8%AE%AFtrtc/","summary":"腾讯视频会议的使用-TRTC技术 概述：  TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n 后端的准备  首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n 用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n//UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥  usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire))) 关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\npackage com.example.emos.api.config.tencet; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import org.bson.internal.Base64; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.zip.Deflater; /** * Description: 腾讯TRTC工具类 * * @author Rex * @date 2021-09-29 10:48 */ import java.","title":"腾讯TRTC"},{"content":"前端常用轮子 简介  这篇文章主要是记录下一些常见的组件库，以后开发的时候方便点。（持续更新中……）\n React UI组件库  Ant Design  文档齐全、社区生态好 支持PC端和手机端   详情见官网\n  React Bootstrap  可用于快速搭建个人项目   详情见官网\n  MATERIAL-UI(Mui)  实现了谷歌的Material Design github有超过50k的关注量，是目前最受欢迎的React组件库之一   详情见官网\n   Vue UI组件库  Element  饿了么旗下的组件库，国内最流行的Vue组件库 文档齐全 支持Vue3 同时有React版本和Angular版本   详情见官网\n  Vant  有赞公司旗下的开源组件库 适用于移动端开发 组件齐全，使用简单，UI美观   详情见官网\n  View UI  UI精美 含免费版和收费版   详情见官网\n   Vue工具类  vue-draggable：vue拖拽组件  详情见官网\n  vue-qr：生成二维码组件  详情见官网\n  vue-cropper：vue图片裁切工具  详情见官网\n  vue-lazyload：图片懒加载  不会和vue其他组件库冲突   详情见官网\n  vue-simple-upload：vue上传组件  详情见官网\n   动画库  Animate.css：动画库  纯css的动画库，适用于各种框架 功能齐全   详情见官网\n  swiper：轮播图组件  提供的轮播图效果多 文档齐全，社区强大 支持原生、React、Vue、Angular等任何前端开发场景 有PC端、移动端之分 缺点：官网广告较多……   详情见官网\n  mescroll.js：滚动插件  解决移动端滚动不流畅、延迟等问题 基于H5，侵入性很小，实用性很强，不依赖于其他前端框架   详情见官网\n   工具类轮子  lodash.js：前端函数库  支持原生、React、Vue、Angular等任何前端开发场景 封装了常用的函数开发库   详情见官网\n  Day.js：日期库  极简的JavaScript库 便于验证、操作、显示日期时间   详情见官网\n  timeago.js  显示几小时之前，网站和应用的更新 时效性强 如：显示15分钟之前创建了xxx文档   详情见官网\n  echarts：数据可视化插件  可以满足企业级的开发需求   详情见官网\n  Meditor.md：Markdown编辑器插件  详情见官网\n  validator.js：表单验证工具  详情见官网\n   ","permalink":"https://rex0520.github.io/posts/front/tools/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%BD%AE%E5%AD%90/","summary":"前端常用轮子 简介  这篇文章主要是记录下一些常见的组件库，以后开发的时候方便点。（持续更新中……）\n React UI组件库  Ant Design  文档齐全、社区生态好 支持PC端和手机端   详情见官网\n  React Bootstrap  可用于快速搭建个人项目   详情见官网\n  MATERIAL-UI(Mui)  实现了谷歌的Material Design github有超过50k的关注量，是目前最受欢迎的React组件库之一   详情见官网\n   Vue UI组件库  Element  饿了么旗下的组件库，国内最流行的Vue组件库 文档齐全 支持Vue3 同时有React版本和Angular版本   详情见官网\n  Vant  有赞公司旗下的开源组件库 适用于移动端开发 组件齐全，使用简单，UI美观   详情见官网\n  View UI  UI精美 含免费版和收费版   详情见官网","title":"前端常用轮子"},{"content":"Zookeeper 定义：  Zookeeper：A Distributed Coordination Service for Distributed Applications(\nZookeeper是开源的高性能的分布式应用协调系统，一个高性能的分布式数据一致性解决方案\n 5大特点  顺序一致性：发出去的顺序==执行的顺序 原子性：请求同步到各个节点要么都成果要么都失败 单一视图：多个节点无论连哪个看的东西都是一致的 可靠性：给节点写了数据，这个数据会一直保留，直到有另外的操作把数据写掉，才会发生变化 及时性：在一定的时间段（可接受的时间段）内能从服务器上读到最新的数据状态  架构图、集群、工作过程 Zookeeper和CAP的关系  CP：一致性+分区容错性 能得到一致的数据结果，同时系统对网络具备容错性 但是它不能保证每次服务请求的可用性  作用  分布式服务注册与订阅 统一配置文件 生成分布式唯一ID Master节点选举 分布式锁  节点znode 模型-树结构 节点性质  树形结构，也可以理解为linux的文件目录 每一个节点都是znode，里面可以包含数据，也可以有子节点 点分为永久节点和临时节点(session失效，也就是客户端段凯后，临时节点消失) 每个znode都有版本号，每当数据变化，版本号会累加（乐观锁） 删除或修改节点，版本号不匹配的话（版本号已过时），会报错 每个节点存储的数据不宜过大，几k即可 节点可以设置权限，来限制用户的访问 Zookeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入  节点类型  持久节点 临时节点 顺序节点  节点属性  dataVersion 数据版本号，每次对内容修改dataVersion+1 cversion 子节点版本号，如果子节点内容发送变化cversion+1 aclVersion acl-权限控制列表，权限发生变化的时候aclVersion+1  常用命令  查看节点ls 查看节点的数据和状态get 创建(create [-s 顺序节点] [-e 临时节点])、修改(set)、删除(delete)节点  Watcher机制   触发器、监督者\n  事件类型\n   EventType 触发条件     NodeCreated（节点创建） Watcher监听的对应数据节点被创建   NodeDeleted（节点删除） Watcher监听的对应数据节点被删除   NodeDataChanged（节点数据修改） Watcher监听的对应数据节点的数据内容发送变更   NodeChildrenChanged（子节点变更） Watcher监听的对应数据节点的子节点列表发送变更      ACL  access control list 权限控制 它使用权限位来允许/禁止对节点极其所用域的各种操作 ACL仅与特点的znode有关，与子节点无关  Schema  ACL:[schema采用的权限机制: id用户:permissions权限组合字符串] world  id: anyone   auth 需要设定对应的用户和密码（明文） digest 同auth，不同的是加密使用密文 ip 指定ip super 超级权限  权限字符串crdwa  Created 创建子节点的权限 Read 读 Delete 删除子节点的权限 Write 写 Admin 最高权限  使用权限  区分开发/测试/运维环境，防止误操作 可以针对不同IP而产生具体的配置，更安全  代码 java原生   导入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写log4j.properties\nlog4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{HH:mm:ss} %p %c{2}: %m%n   ZKConnect.java\npackage com.imooc.zkjavaapi; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import org.apache.zookeeper.ZooKeeper; import java.io.IOException; /** * Description: 连接到ZK服务端，打印连接状态 * Date 2021-07-22 16:00 * * @author Rex */ public class ZKConnect implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; public static void main(String[] args) throws IOException, InterruptedException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKConnect()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); System.out.println(zk.getState()); } @Override public void process(WatchedEvent event) { System.out.println(\u0026#34;收到了通知：\u0026#34; + event); } }   演示对节点的操作\nZKOperator.java\npackage com.imooc.zkjavaapi; import com.imooc.zkjavaapi.callback.DeleteCallBack; import org.apache.zookeeper.*; import java.io.IOException; import java.nio.charset.StandardCharsets; /** * Description: 演示对节点的操作 * Date 2021-07-22 16:24 * * @author Rex */ public class ZKOperator implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; public static void main(String[] args) throws IOException, InterruptedException, KeeperException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKConnect()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); /* * path: 创建的路径 * data: 存储的数据 * acl: 权限控制，开放 * createMode: 永久、临时、顺序 */ zk.create(\u0026#34;/imago-create-node\u0026#34;, \u0026#34;imooc\u0026#34;.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // zk.setData(\u0026#34;/imooc-create-node\u0026#34;, \u0026#34;imooc3\u0026#34;.getBytes(StandardCharsets.UTF_8), 1);  String ctx = \u0026#34;删除成功\u0026#34;; zk.delete(\u0026#34;/imooc-create-node\u0026#34;, 0, new DeleteCallBack(), ctx); Thread.sleep(2000); // System.out.println(new String(zk.getData(\u0026#34;/imooc-create-node\u0026#34;, null, null)));  } @Override public void process(WatchedEvent event) { } } DeleteCallBack.java\npackage com.imooc.zkjavaapi.callback; import org.apache.zookeeper.AsyncCallback; /** * Description: 删除后会运行的内容 * Date 2021-07-22 16:42 * * @author Rex */ public class DeleteCallBack implements AsyncCallback.VoidCallback { @Override public void processResult(int rc, String path, Object ctx) { System.out.println(\u0026#34;删除节点\u0026#34; + rc); System.out.println((String) ctx); } }   Watcher\npackage com.imooc.zkjavaapi; import org.apache.zookeeper.KeeperException; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import org.apache.zookeeper.ZooKeeper; import java.io.IOException; import java.util.concurrent.CountDownLatch; /** * Description: 和节点相关：是否存在，获取数据，加上watche * Date 2021-07-22 16:53 * * @author Rex */ public class ZKGetNode implements Watcher { /** * Zookeeper服务端地址 */ private static final String SERVER_PATH = \u0026#34;127.0.0.1:2181\u0026#34;; /** * 超时时间 */ private static final Integer TIME_OUT = 5000; private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) throws IOException, InterruptedException, KeeperException { /* * 客户端和服务端他们是异步连接，连接成功后，客户端会收到watcher通知 * connectString：服务器的IP+端口号，比如：127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件 */ ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIME_OUT, new ZKGetNode()); System.out.println(\u0026#34;客户端开始连接zk服务器了\u0026#34;); System.out.println(zk.getState()); Thread.sleep(2000); System.out.println(zk.getState()); // Stat exists = zk.exists(\u0026#34;/imooc\u0026#34;, false); // if (exists != null) { // System.out.println(\u0026#34;节点的版本为：\u0026#34; + exists.getVersion()); // }else{ // System.out.println(\u0026#34;该节点不存在\u0026#34;); // }  zk.getData(\u0026#34;/imooc\u0026#34;, true, null); countDownLatch.await(); } @Override public void process(WatchedEvent event) { if (event.getType() == Event.EventType.NodeDataChanged){ System.out.println(\u0026#34;数据被改变\u0026#34;); countDownLatch.countDown(); } System.out.println(\u0026#34;收到了通知：\u0026#34;+event); } }   缺点  不支持连接超时后的自动重连 Watcher注册一次后会失效 不支持递归创建节点  Apache Curator   解决了Watcher注册一次后会失效的问题\n  API更加简单易用，提供了工具类\n  使用\n  引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-framework\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-recipes\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   package com.imooc.curator; import org.apache.curator.RetryPolicy; import org.apache.curator.framework.CuratorFramework; import org.apache.curator.framework.CuratorFrameworkFactory; import org.apache.curator.framework.api.CuratorEvent; import org.apache.curator.retry.ExponentialBackoffRetry; import org.apache.zookeeper.CreateMode; import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import java.nio.charset.StandardCharsets; /** * Description: 用Curator来操作ZK * Date 2021-07-22 17:13 * * @author Rex */ public class CuratorTests { public static void main(String[] args) throws Exception { String connectString = \u0026#34;127.0.0.1:2181\u0026#34;; String path = \u0026#34;/curator2\u0026#34;; String data = \u0026#34;test\u0026#34;; RetryPolicy retry = new ExponentialBackoffRetry(1000, 3); CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry); client.start(); client.getCuratorListenable().addListener((CuratorFramework c , CuratorEvent event) -\u0026gt; { switch (event.getType()){ case WATCHED: WatchedEvent watchedEvent = event.getWatchedEvent(); if (watchedEvent.getType() == Watcher.Event.EventType.NodeDataChanged) { System.out.println(new String(c.getData().forPath(path))); break; } default: break; } }); client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes(StandardCharsets.UTF_8)); byte[] bytes = client.getData().watched().forPath(path); System.out.println(new String(bytes)); client.setData().forPath(path, \u0026#34;test2\u0026#34;.getBytes(StandardCharsets.UTF_8)); client.delete().forPath(path); } }     ","permalink":"https://rex0520.github.io/posts/back/microservices/zookeeper/","summary":"Zookeeper 定义：  Zookeeper：A Distributed Coordination Service for Distributed Applications(\nZookeeper是开源的高性能的分布式应用协调系统，一个高性能的分布式数据一致性解决方案\n 5大特点  顺序一致性：发出去的顺序==执行的顺序 原子性：请求同步到各个节点要么都成果要么都失败 单一视图：多个节点无论连哪个看的东西都是一致的 可靠性：给节点写了数据，这个数据会一直保留，直到有另外的操作把数据写掉，才会发生变化 及时性：在一定的时间段（可接受的时间段）内能从服务器上读到最新的数据状态  架构图、集群、工作过程 Zookeeper和CAP的关系  CP：一致性+分区容错性 能得到一致的数据结果，同时系统对网络具备容错性 但是它不能保证每次服务请求的可用性  作用  分布式服务注册与订阅 统一配置文件 生成分布式唯一ID Master节点选举 分布式锁  节点znode 模型-树结构 节点性质  树形结构，也可以理解为linux的文件目录 每一个节点都是znode，里面可以包含数据，也可以有子节点 点分为永久节点和临时节点(session失效，也就是客户端段凯后，临时节点消失) 每个znode都有版本号，每当数据变化，版本号会累加（乐观锁） 删除或修改节点，版本号不匹配的话（版本号已过时），会报错 每个节点存储的数据不宜过大，几k即可 节点可以设置权限，来限制用户的访问 Zookeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入  节点类型  持久节点 临时节点 顺序节点  节点属性  dataVersion 数据版本号，每次对内容修改dataVersion+1 cversion 子节点版本号，如果子节点内容发送变化cversion+1 aclVersion acl-权限控制列表，权限发生变化的时候aclVersion+1  常用命令  查看节点ls 查看节点的数据和状态get 创建(create [-s 顺序节点] [-e 临时节点])、修改(set)、删除(delete)节点  Watcher机制   触发器、监督者","title":"Zookeeper"},{"content":"Dubbo 关于Dubbo  轻量级，高性能的RPC框架 并不是要成为一个微服务的全面解决发难 以Java语言而出名  Dubbo现状  全称是Apache Dubbo 微店，网易云音乐，考拉，滴滴，中国电信，人寿 star有30k+个，fork有20k+个  RPC   RPC\u0026mdash;\u0026ndash;远程过程调用\n  早期单机时代：IPC（Inter-Process Communication）\n单个电脑运行的各个进程之间相互通信\n  网络时代：把IPC扩展到网络上，这就是RPC\n    实现RPC很头疼，于是就有了RPC框架\n  调用其他机器上的程序和调用本地的程序一样方便\n  常见的RPC框架  阿里的Dubbo（性能好） 新浪的Montan（轻量级，项目架构复杂度低，适合RPC源码学习） Facebook的Thrift （可伸缩的跨语言框架，有很强的代码生成语言）  HTTP和RPC对比  普通话（HTTP，规范\u0026ndash;效率低）和方言（RPC，传输效率和运行速度更高），普通话本质上也是一种方言，只不过它是官方的方言 传输效率：RPC可以自己定制，通过定制自己的请求，让整体传输的内容更少，这样的效率更高，而HTTP会传输一些无用的内容 性能消耗，主要在于序列化和反序列化的耗时：RPC可以实现高效的二进制传输，HTTP大部分要通过JSON格式来传输 负载均衡：RPC自带负载均衡策略，HTTP需要借助其他的组件，如Nginx  Dubbo工作原理    模块 说明     Provider 暴露服务的服务提供方   Consumer 调用远程服务的服务消费方   Registry 服务注册与发现的注册中心   Monitor 统计服务的调用次数和调用时间的监控中心   Container 服务运行容器     服务容器负责启动，加载，运行服务提供者 服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅自己所需的服务 注册中心返回服务提供者地址列表给消费者 从提供者地址列表中，选一台提供者进行调用 定期发送一次统计数据到监控中心  ","permalink":"https://rex0520.github.io/posts/back/microservices/dubbo%E5%9F%BA%E7%A1%80/","summary":"Dubbo 关于Dubbo  轻量级，高性能的RPC框架 并不是要成为一个微服务的全面解决发难 以Java语言而出名  Dubbo现状  全称是Apache Dubbo 微店，网易云音乐，考拉，滴滴，中国电信，人寿 star有30k+个，fork有20k+个  RPC   RPC\u0026mdash;\u0026ndash;远程过程调用\n  早期单机时代：IPC（Inter-Process Communication）\n单个电脑运行的各个进程之间相互通信\n  网络时代：把IPC扩展到网络上，这就是RPC\n    实现RPC很头疼，于是就有了RPC框架\n  调用其他机器上的程序和调用本地的程序一样方便\n  常见的RPC框架  阿里的Dubbo（性能好） 新浪的Montan（轻量级，项目架构复杂度低，适合RPC源码学习） Facebook的Thrift （可伸缩的跨语言框架，有很强的代码生成语言）  HTTP和RPC对比  普通话（HTTP，规范\u0026ndash;效率低）和方言（RPC，传输效率和运行速度更高），普通话本质上也是一种方言，只不过它是官方的方言 传输效率：RPC可以自己定制，通过定制自己的请求，让整体传输的内容更少，这样的效率更高，而HTTP会传输一些无用的内容 性能消耗，主要在于序列化和反序列化的耗时：RPC可以实现高效的二进制传输，HTTP大部分要通过JSON格式来传输 负载均衡：RPC自带负载均衡策略，HTTP需要借助其他的组件，如Nginx  Dubbo工作原理    模块 说明     Provider 暴露服务的服务提供方   Consumer 调用远程服务的服务消费方   Registry 服务注册与发现的注册中心   Monitor 统计服务的调用次数和调用时间的监控中心   Container 服务运行容器     服务容器负责启动，加载，运行服务提供者 服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅自己所需的服务 注册中心返回服务提供者地址列表给消费者 从提供者地址列表中，选一台提供者进行调用 定期发送一次统计数据到监控中心  ","title":"Dubbo基础"},{"content":"MongoDB 简介：   MongoDB是为快速开发互联网Web应用而设计的数据库系统。 MongoDB的设许目标是极简、灵活、作为Web应用栈的一部分。 MongoDB的数据模型是面向文档的,所谓文档是- - -种类似于JSON的结构,简单理解MongoDB这个数据库中存的是各种各样的JSON。 ( BSON )   三个概念   数据库( database )\n 数据库是-个仓库,在仓库中可以存放集合。\n   集合( collection )\n 集合类似于数组,在集合中可以存放文档。\n   文档( dotument )\n 文档数据库中的最小单位,我们存储和操作的 内容都是文档。\n   基本指令   show dbs\n 显示当前的所有数据库\n   use 数据库名\n 进入指定的数据库中\n   db\n 显示当前所处的数据库\n   show collections\n 显示数据库中所有的集合\n   db.\u0026lt;collection\u0026gt;.insert(doc)\n 向集合中插入一个文档\n   db.\u0026lt;collections\u0026gt;.find()\n 查看数据库字段\n   插入文档 /* 向数据库插入文档\tdb.\u0026lt;collection\u0026gt;.insert( \u0026lt;document or array of documents\u0026gt;， { wirteConcern: \u0026lt;document\u0026gt;, ordered: \u0026lt;boolean\u0026gt; } ) documents: 必填，表示需要插入的文档，可以是多个文档 writeConcern：可选项，写策略 ordered：可选，表示多个文档是否按照文档顺序写入 -- 向集合中插入一个或多个文档 -- 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id， 该属性用来作为文档的唯一标识 -- _id可以自己指定，如果指定了数据库就不会再添加了，如果自己指定_id，也必须确保他的唯一性 db.collection.insertOne() -- 插入一个文档对象 db.collection.insertMany() -- 插入多个文档对象 */db.stus.insert({name:\u0026#34;zhubajie\u0026#34;,age:28,gender:\u0026#34;男\u0026#34;})db.stus.insert([{name:\u0026#34;shasen\u0026#34;,age:38,gender:\u0026#34;男\u0026#34;},{name:\u0026#34;baigujing\u0026#34;,age:16,gender:\u0026#34;女\u0026#34;},{name:\u0026#34;zhizhujing\u0026#34;,age:14,gender:\u0026#34;女\u0026#34;}])查询文档 查询选择器    运算符类型 运算符 运算符含义     \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $eq 等于    $lt 小于   比 $lte 小于等于    $gt 大于    $gte 大于等于   较 $in 判断元素是否在指定的集合范围里    $all 判断元素是否不在指定的集合范围里    $nin 判断元素是否不在指定的范围里   \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $ne 不等于   \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $not 不匹配结果   逻辑 $or 有一个条件成立则匹配    $nor 所有条件都必须匹配   运算 $and 所有条件都必须匹配   \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; $exists 判断元素是否存在   其 . 子文档匹配   他 $regex 正则表达式    一般查询 /* 查询 db.collection.find() -- find()用来查询所有符合条件的文档 -- find()可以接受一个对象作为条件参数 {} 表示查询集合中所有的文档 {属性：值} 查询属性是指定的文档 -- find() 返回的是一个数组 db.collection.findOne() -- 用来查询集合中符合条件的第一个文档 -- findOne() 返回的是一个文档对象 db.collection.find({}).count() -- 查询所有结果的数量 */db.stus.insert({_id:\u0026#34;hello\u0026#34;,name:\u0026#34;zhubajie\u0026#34;,age:28,gender:\u0026#34;男\u0026#34;})db.stus.find({age:28})db.stus.findOne({age:28}).namedb.stus.find({}).count()查询其他条件 映射  字段选择：db.inventory.find({}, {\u0026lsquo;item\u0026rsquo;: 1}) 字段排除：db.inventory.find({}, {\u0026lsquo;item\u0026rsquo;: 0})  数组子元素选择：  db.inventory.find({}, {\u0026lsquo;favorites.movies\u0026rsquo;: {'$slice': [1, 2]}, \u0026lsquo;favorites.cites\u0026rsquo;: 1}), $slice可以取俩个元素数组，分别表示跳过和限制的条数  排序  sort(): db.orders.find().sort({\u0026lsquo;orderTime\u0026rsquo;: 1, \u0026lsquo;price\u0026rsquo;: 1}) 1: 升序 2: 降序  跳过和限制   skip(n):跳过n条数据\n  limit(n):限制n条数据\ne.g：orders.find().sort({\u0026lsquo;orderTime\u0026rsquo;: -1}).limit(5).skip(5)\n  查询唯一值   distinct()：查询指定字段的唯一值\ne.g：db.users.distinct(\u0026ldquo;age\u0026rdquo;)\n  聚合查询  我们在查询时肯定回用到聚合，在MongoDB中聚合为aggregate，聚合函数主要用到$match，$group，$avg，$project，$concat，可以加\u0026quot;$match\u0026quot;也可以不加$match\n    表达式 描述     $sum 计算总和   $avg 计算平均值   $min 获取集合中所有文档对应值的最小值   $max 获取集合中所有文档对应值的最大值   $push 在结果文档中插入值到一个数组中。   $addToSet 在文档中插入值到一个数组中，但不创建副本。   $first 根据资源文档的排序获取第一个文档数据。   $last 根据资源文档的排序获取最后一个文档数据。    Aggregate语法  基本格式： db.collection.aggregate(pipeline, options)\n参数说明：\n   参数 类型 描述     pipeline array 一系列数据聚合操作或阶段。在版本2.6中更改：该方法仍然可以将流水线阶段作为单独的参数接受，而不是作为数组中的元素；但是如果不将管道指定为数组，则不能指定options参数。   options document 可选。aggregate()传递给聚合命令的其他选项。2.6版中的新增功能：仅当将管道指定为数组时才可用     $match和$group  相当于sql中的where和group by\n{\u0026quot;$match\u0026quot;: {\u0026ldquo;字段\u0026rdquo;: \u0026ldquo;条件\u0026rdquo;}}，可以使用任何常用查询操作符$gt，$lt，$in等\n{\u0026quot;$group\u0026quot;：{\u0026quot;_id\u0026quot;: 分组字段, \u0026ldquo;新的字段名\u0026rdquo;: \u0026ldquo;聚合操作符\u0026rdquo;}}\n 将分组字段传给$group函数的_id字段即可 分组后聚合得到结果，类似于sql中聚合函数的聚合操作符：$sum、$avg、$max、$min、$first、$last   #{\u0026#34;$match\u0026#34;:{\u0026#34;字段\u0026#34;:\u0026#34;条件\u0026#34;}}，可以使用任何常用查询操作符$gt,$lt,$in等#select_idjob,avg(sal)avg_salaryfromdb.empwheredepno=30groupbyjob;db.emp.aggregate([{\u0026#34;$match\u0026#34;:{\u0026#34;depno\u0026#34;:{\u0026#34;$eq\u0026#34;:30}}},{\u0026#34;$group\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;$job\u0026#34;,\u0026#34;avg_salary\u0026#34;:{\u0026#34;$avg\u0026#34;:\u0026#34;$sal\u0026#34;}}}])#select_idjob,avg(sal)avg_salaryfromdb.empwheredepno=30groupbyjobhavingavg_salary\u0026gt;2000;db.emp.aggregate([{\u0026#34;$match\u0026#34;:{\u0026#34;depno\u0026#34;:{\u0026#34;$eq\u0026#34;:30}}},{\u0026#34;$group\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;$job\u0026#34;,\u0026#34;avg_salary\u0026#34;:{\u0026#34;$avg\u0026#34;:\u0026#34;$sal\u0026#34;}}},{\u0026#34;$match\u0026#34;:{\u0026#34;avg_salary\u0026#34;:{\u0026#34;$gt\u0026#34;:2000}}}])$project  用于投射，即设定该键值对是否保留。1为保留，0为不保留，可对原有键值对做操作后增加自定义表达式(查询哪些要显示的列)\n {\u0026#34;$project\u0026#34;:{\u0026#34;要保留的字段名\u0026#34;:1,\u0026#34;要去掉的字段名\u0026#34;:1,\u0026#34;新增的字段名\u0026#34;:\u0026#34;表达式\u0026#34;}}db.emp.aggregate()#selectename,job,(sal+400)asnew_salfromdb.emp;db.emp.aggregate([{$project:{\u0026#34;ename\u0026#34;:1,\u0026#34;job\u0026#34;:1,\u0026#34;new_sal\u0026#34;:{\u0026#34;$add\u0026#34;:[\u0026#34;$sal\u0026#34;,400]}}}])$sort和$limit和$skip  排序：{\u0026quot;$sort\u0026quot;: {\u0026ldquo;字段名\u0026rdquo;: 1, “字段名”: -1}} #1升序，-1降序\n限制：{\u0026quot;$limit\u0026quot;: n}\n跳过：{\u0026quot;$skip\u0026quot;: n} #跳过多少个文档\n #例1、取平均工资最高的前两个工作db.emp.aggregate([{\u0026#34;$group\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;$job\u0026#34;,\u0026#34;avg_sal\u0026#34;:{\u0026#34;$avg\u0026#34;:\u0026#34;$sal\u0026#34;}}},{\u0026#34;$sort\u0026#34;:{\u0026#34;avg_sal\u0026#34;:-1}},{\u0026#34;$limit\u0026#34;:2}])#例2、取平均工资最高的第二个部门db.emp.aggregate([{\u0026#34;$group\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;$job\u0026#34;,\u0026#34;avg_sal\u0026#34;:{\u0026#34;$avg\u0026#34;:\u0026#34;$sal\u0026#34;}}},{\u0026#34;$sort\u0026#34;:{\u0026#34;avg_sal\u0026#34;:-1}},{\u0026#34;$skip\u0026#34;:1},{\u0026#34;$limit\u0026#34;:1}])$sample  随机选取n个：$sample\n db.emp.aggregate([{\u0026#34;$sample\u0026#34;:{size:3}}])修改文档 /* 修改 db.collection.update(查询条件，新对象) - update()默认情况下会使用新对象来替换旧对象(旧版本) - update()旧版本新对象不写全或是不用$set，默认情况下会报错 (Invalid key \u0026#39;age\u0026#39;: update only works with $ operators and pipelines) - 如果需要修改指定的属性，而不是替换需要使用\u0026#34;修改操作符\u0026#34;来完成修改 $set 可以用来修改文档中的指定属性 $unset 可以用来删除文档中的指定属性 - update()默认只修改一个 db.collection.updateMany() - 同时修改多个符合条件的文档 db.collection.updateOne() - 修改一个符合条件的文档 */db.stus.find()//替换db.stus.update({name:\u0026#34;shasen\u0026#34;},{age:28})db.stus.update({name:\u0026#34;shasen\u0026#34;},{$set:{age:28}})db.stus.update({_id:ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{$set:{name:\u0026#34;shaheshang\u0026#34;}})db.stus.find({_id:ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)})db.stus.update({_id:ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{$set:{gender:\u0026#34;男\u0026#34;,address:\u0026#34;流沙河\u0026#34;}})db.stus.update({_id:ObjectId(\u0026#34;60da92e09e15000095005504\u0026#34;)},{$unset:{address:1}})db.stus.updateMany({name:\u0026#34;zhubajie\u0026#34;},{$set:{address:\u0026#34;zhulaozhuang\u0026#34;}})db.stus.update({name:\u0026#34;zhubajie\u0026#34;},{$set:{address:\u0026#34;zhulaozhuang\u0026#34;}})db.stus.update({name:\u0026#34;zhubajie\u0026#34;},{$set:{address:\u0026#34;hehehe\u0026#34;}},{multi:true})db.stus.find()删除文档 /* 删除 db.collection.remove() -- 删除符合条件的所有文档(默认情况下会删除多个) 如果remove()第二个参数传递一个true，则只会删除一个 -- 如果值传递一个空对象作为参数，则会删除结合中的所有文档\tdb.collection.deleteOne() db.collection.deleteMany() -- remove()可以根据条件来删除文档，传递的条件方式和find()一样 db.collection.drop(); -- 删除集合 db.dropDatabase() 删除数据库 -- 数据库中的数据都并不会删除，所以删除的方法很少调用 一般会在数据中添加一个字段，来表示数据是否被删除 */db.stus.remove({_id:\u0026#34;hello\u0026#34;})db.stus.find()db.stus.insert([{age:28},{age:28}])db.stus.remove({age:28},true)//清空集合(性能略差)db.stus.remove({})showcollections;db.stus.drop()showdbs;db.dropDatabase();文档关系 /* 文档之间的关系 一对一(one to one) -- 夫妻(一个丈夫 对应 一个妻子) -- 在MongoDB，可以通过内嵌文档的形式来体现出一对一的关系 一对多(one to many) / 多对一(many to one) -- 父母 - 孩子 用户 - 订单 文章 - 评论 - 也可以通过内嵌文档来映射一对多的关系 多对多(many to many) -- 分类 - 商品 老师 - 学生 */ db.wifeAndHusband.insert([ { name: \u0026#34;黄蓉\u0026#34;, husband: { name: \u0026#34;郭靖\u0026#34; } },{ name: \u0026#34;潘金莲\u0026#34;, husband: { name: \u0026#34;武大郎\u0026#34; } } ]); db.wifeAndHusband.find() // 一对多 用户(users) 和 订单() db.users.insert([ { username: \u0026#34;swk\u0026#34; },{ username: \u0026#34;zbj\u0026#34; } ]) db.users.find() db.order.insert({ list: [\u0026#34;牛肉\u0026#34;, \u0026#34;漫画\u0026#34;], user_id: ObjectId(\u0026#34;60dbc477c673000085000595\u0026#34;) }) db.order.find() // 查找用户swk的订单 var user_id = db.users.findOne({username: \u0026#34;zbj\u0026#34;})._id db.order.find({user_id: user_id}) // 多对多 db.teachers.insert([ {name: \u0026#34;洪七公\u0026#34;}, {name: \u0026#34;黄药师\u0026#34;}, {name: \u0026#34;龟仙人\u0026#34;} ]) db.stus.insert([{ name: \u0026#34;郭靖\u0026#34;, tech_ids: [ ObjectId(\u0026#34;60dbc694c67300008500059a\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059b\u0026#34;) ] },{ name: \u0026#34;孙悟空\u0026#34;, tech_ids: [ ObjectId(\u0026#34;60dbc694c67300008500059a\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059b\u0026#34;), ObjectId(\u0026#34;60dbc694c67300008500059c\u0026#34;) ] } ]) db.teachers.find() db.stus.find() Test //17.向numbers中插入20000条数据 var arr = []; for(var i = 1; i \u0026lt;= 20000; i++){ arr.push({num: i}); } db.numbers.insert(arr) //18.查询numbers中num为500的文档 db.numbers.find({num: 500}) //19.查询numbers中num大于5000的文档 db.numbers.find({num: {$gt: 5000}}) //20.查询numbers中num小于30的文档 db.numbers.find({num: {$lt: 30}}) //21.查询numbers中num大于40小于50的文档 db.numbers.find({num: {$gt: 40, $lt: 50}}) //22.查询numbers中num大于19996的文档 db.numbers.find({num: {$gt: 19996}}) //23.查看numbers集合中的前10条数据 //limit()设置显示数据的上限 db.numbers.find({}).limit(10) //在开发时，我们绝对不会执行不带条件的查询 db.numbers.find({}) //24.查看numbers集合中的第11条到20条数据 //skip()用于跳过指定数量的数据 db.numbers.find({}).limit(10).skip(10) //25.查看numbers集合中的第21条到30条数据 db.numbers.find({}).limit(10).skip(20) //26.将dept和emp集合导入到数据库中  //27.查询工资小于2000的员工 db.emp.find({sal: {$lt: 2000}}) //28.查询工资在1000-2000之间的员工 db.emp.find({sal: {$gt: 1000, $lt: 2000}}) //29.查询工资小于1000或大于2500的员工 db.emp.find({ $or: [ {sal: {$lt: 1000}}, {sal: {$gt: 2500}} ] }); //30.查询财务部的所有员工 var deptno = db.dep.findOne({dname: \u0026#34;财务部\u0026#34;}).deptno db.emp.find({depno: deptno}) //31.查询销售部的所有员工 var deptno = db.dep.findOne({dname: \u0026#34;销售部\u0026#34;}).deptno db.emp.find({depno: deptno}) //32.查询所有mgr为7698的所有员工 db.emp.find({mgr: 7698}) //33.为所有薪资低于1000的员工增加工资400元 db.emp.updateMany({sal: {$lte: 1000}}, { $inc: { sal: 400 } } ) db.emp.find() emp:\n{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ac\u0026#34;), \u0026#34;empno\u0026#34; : 7369.0, \u0026#34;ename\u0026#34; : \u0026#34;林冲\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7902.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1980-12-16T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 800.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ad\u0026#34;), \u0026#34;empno\u0026#34; : 7499.0, \u0026#34;ename\u0026#34; : \u0026#34;孙二娘\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-02-19T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1600.0, \u0026#34;comm\u0026#34; : 300.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4ae\u0026#34;), \u0026#34;empno\u0026#34; : 7521.0, \u0026#34;ename\u0026#34; : \u0026#34;扈三娘\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-02-21T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1250.0, \u0026#34;comm\u0026#34; : 500.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4af\u0026#34;), \u0026#34;empno\u0026#34; : 7566.0, \u0026#34;ename\u0026#34; : \u0026#34;卢俊义\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-04-01T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2975.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b0\u0026#34;), \u0026#34;empno\u0026#34; : 7654.0, \u0026#34;ename\u0026#34; : \u0026#34;潘金莲\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-09-27T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1250.0, \u0026#34;comm\u0026#34; : 1400.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b1\u0026#34;), \u0026#34;empno\u0026#34; : 7698.0, \u0026#34;ename\u0026#34; : \u0026#34;西门庆\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-04-30T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2850.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b2\u0026#34;), \u0026#34;empno\u0026#34; : 7782.0, \u0026#34;ename\u0026#34; : \u0026#34;柴进\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;经理\u0026#34;, \u0026#34;mgr\u0026#34; : 7839.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-06-08T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 2450.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b3\u0026#34;), \u0026#34;empno\u0026#34; : 7788.0, \u0026#34;ename\u0026#34; : \u0026#34;公孙胜\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;分析师\u0026#34;, \u0026#34;mgr\u0026#34; : 7566.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1987-07-12T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 3000.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b4\u0026#34;), \u0026#34;empno\u0026#34; : 7839.0, \u0026#34;ename\u0026#34; : \u0026#34;宋江\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;董事长\u0026#34;, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-11-16T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 5000.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b5\u0026#34;), \u0026#34;empno\u0026#34; : 7844.0, \u0026#34;ename\u0026#34; : \u0026#34;阎婆惜\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;销售\u0026#34;, \u0026#34;mgr\u0026#34; : 7698.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-09-07T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1500.0, \u0026#34;comm\u0026#34; : 0.0, \u0026#34;depno\u0026#34; : 30.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b6\u0026#34;), \u0026#34;empno\u0026#34; : 7876.0, \u0026#34;ename\u0026#34; : \u0026#34;李逵\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7902.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1987-07-12T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1100.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b7\u0026#34;), \u0026#34;empno\u0026#34; : 7900.0, \u0026#34;ename\u0026#34; : \u0026#34;武松\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7782.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-12-02T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 950.0, \u0026#34;depno\u0026#34; : 10.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b8\u0026#34;), \u0026#34;empno\u0026#34; : 7902.0, \u0026#34;ename\u0026#34; : \u0026#34;吴用\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;分析师\u0026#34;, \u0026#34;mgr\u0026#34; : 7566.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1981-12-02T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 3000.0, \u0026#34;depno\u0026#34; : 20.0 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f5bfc1bc86928f4de4b9\u0026#34;), \u0026#34;empno\u0026#34; : 7934.0, \u0026#34;ename\u0026#34; : \u0026#34;鲁智深\u0026#34;, \u0026#34;job\u0026#34; : \u0026#34;职员\u0026#34;, \u0026#34;mgr\u0026#34; : 7782.0, \u0026#34;hiredate\u0026#34; : ISODate(\u0026#34;1982-01-22T16:00:00Z\u0026#34;), \u0026#34;sal\u0026#34; : 1300.0, \u0026#34;depno\u0026#34; : 10.0 } dept\n{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49a\u0026#34;), \u0026#34;deptno\u0026#34; : 10.0, \u0026#34;dname\u0026#34; : \u0026#34;财务部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;北京\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49b\u0026#34;), \u0026#34;deptno\u0026#34; : 20.0, \u0026#34;dname\u0026#34; : \u0026#34;办公室\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;上海\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49c\u0026#34;), \u0026#34;deptno\u0026#34; : 30.0, \u0026#34;dname\u0026#34; : \u0026#34;销售部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;广州\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5941f2bac1bc86928f4de49d\u0026#34;), \u0026#34;deptno\u0026#34; : 40.0, \u0026#34;dname\u0026#34; : \u0026#34;运营部\u0026#34;, \u0026#34;loc\u0026#34; : \u0026#34;深圳\u0026#34; } 排序和投影 // 查询文档时，默认情况下是按照_id的值进行排列(升序) //sort()可以用来指定文档的排序的规则，sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序 //limit skip sort 可以任意的顺序进行调用 db.emp.find({}).sort({sal: -1}) //在查询时，可以在第二个参数的位置来设置查询结果的 投影 db.emp.find({}, {ename: 1, _id: 0, sal: 1}); node整合mongodb- Mongoose http://mongoosejs.com/\n连接数据库 /* 1. 下载安装Mongoose npm i mongoose --save 2. 在项目中引入mongoose var mongoose = require(\u0026#34;mongoose\u0026#34;) 3. 连接MongoDB数据库 mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, {useMongoClient: true}); - 如果端口号是默认端口号(27017) 则可以省略不写 4. 断开数据库连接(一般不需要调用) - MongoDB数据库，一般情况下，只需要连接一次，连接一次以后，除非项目停止，服务器关闭，否则连接一般不会断开 mongoose.disconnect() - 监听MongoDB数据库的连接状态 - 在Mongoose对象中，有一个属性叫做Connection，该对象表示的就是数据库连接 通过监视该对象的状态，可以来监听数据库的连接与断开 数据库连接成功的事件 mongoose.connection.once(\u0026#34;open\u0026#34;, function()); 数据库断开的事件 mongoose.connection.once(\u0026#34;close\u0026#34;, function()); Schema Model Document */ // 引入 var mongoose = require(\u0026#34;mongoose\u0026#34;); // 连接数据库 // mongoose.connect(\u0026#34;mongodb://127.0.0.1/mongoose_test\u0026#34;, { useNewUrlParser: true } ); mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, { useNewUrlParser: true, useUnifiedTopology: true }); mongoose.connection.once(\u0026#34;open\u0026#34;, () =\u0026gt; { console.log(\u0026#34;数据库连接成功~~~~~\u0026#34;); }); mongoose.connection.once(\u0026#34;close\u0026#34;, () =\u0026gt; { console.log(\u0026#34;数据库已经断开~~~~~\u0026#34;); }); //断开数据库连接 mongoose.disconnect() 使用示例 var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) // 向数据库中插入一个文档 // StuModel.create(doc, function)); StuModel.create({ name: \u0026#34;白骨精\u0026#34;, age: 18, address: \u0026#34;白骨洞\u0026#34; }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;插入成功\u0026#34;); } }); Model使用 var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) /* - 有了Model，我们就可以用来对数据库进行增删改查的操作了 Model.create(doc(s), [callback]) - 用来创建一个或多个文档并添加到数据库中 - 参数： doc(s) 可以是一个文档对象，也可以是一个文档对象的数组 callback 当操作完成以后调用的回调函数 查询的: Model.find(conditions, [projection], [options], [callback]) - 查询所有符合条件的文档 Model.findById(id, [projection], [options], [callback]) - 根据文档的id属性查询文档 Model.findOne([conditions], [projection], [options], [callback]) - 查询符合条件的第一个文档，总会返回一个具体的文档 conditions 查询的条件 projection 投影 需要的字段 - 两种方式 {name: 1, _id: 0} \u0026#34;name -_id\u0026#34; options 查询选项(skip, limit) callback 回调函数，查询结果会通过回调函数返回 回调函数必须传，如果不传回调函数，不会查询 */ // StuModel.find({}, \u0026#34;name age\u0026#34;, { // skip: 3, // limit: 1 // }, (err, docs) =\u0026gt; { // if (!err) { // console.log(docs); // } // }) // StuModel.findOne({}, (err, docs) =\u0026gt; { // if (!err) { // console.log(docs); // } // }) // StuModel.findById(\u0026#34;60dbdbb2ecd64b4db4605b27\u0026#34;, (err, docs) =\u0026gt; { // if (!err) { // // console.log(docs); // // 通过find()查询的结果，返回的对象，就是Document，文档对象 // // Document对象是Model的实例 // console.log(docs instanceof StuModel); // } // })  // StuModel.create([{ // name: \u0026#34;沙和尚\u0026#34;, // age: 28, // gender: \u0026#34;male\u0026#34;, // address: \u0026#34;流沙河\u0026#34; // }], (error) =\u0026gt; { // if (!error) { // console.log(arguments); // } // })  /* 修改 Model.update(conditions, doc, [options], [callback]) Model.updateMany(conditions, doc, [options], [callback]) Model.updateOne(conditions, doc, [options], [callback]) Model.replaceOne(conditions, doc, [options], [callback]) - 用来修改一个或多个文档 - 参数： conditions 查询条件 doc 修改后的对象 options 配置参数 callback 回调函数 */ // 修改唐僧的年龄为20 // StuModel.updateOne({ // name: \u0026#34;唐僧\u0026#34; // }, { // $set: { // age: 20 // } // }, (err) =\u0026gt; { // if (!err) { // console.log(\u0026#34;修改成功\u0026#34;); // } // })  /* 删除 Model.remove(conditions, [callback]) Model.deleteOne(conditions, [callback]) Model.deleteMany(conditions, [callback]) */ // StuModel.deleteOne({ // name: \u0026#34;沙和尚\u0026#34; // }, // err =\u0026gt; { // if (!err) { // console.log(\u0026#34;删除成功\u0026#34;); // } // })  /* Model.count(conditions, [callback]) - 统计文档的数量的 */ StuModel.count({}, function (err, count) { if (!err) { console.log(count); } }); Document使用 /* Document 和 集合中的文档一一对应，Document是Model实例 通过Model查询到结果都是Document */ // 创建一个Document var mongoose = require(\u0026#34;mongoose\u0026#34;); mongoose.connect(\u0026#34;mongodb://localhost/mongoose_test\u0026#34;, { useNewUrlParser: true, useUnifiedTopology: true, }); // 创建Schema(模式对象) var { Schema } = mongoose var stuSchema = new Schema({ name: String, age: Number, gender: { type: String, default: \u0026#34;female\u0026#34; }, address: String }) // 通过Schema来创建Model // Model代表的是数据库中的集合，通过Model才能对数据库进行操作 // mongoose.model(modelName, schema); // modelName 就是要映射的集合名 mongoose会自动转换成复数 var StuModel = mongoose.model(\u0026#34;student\u0026#34;, stuSchema) var stu = new StuModel({ name: \u0026#34;奔波霸\u0026#34;, age: 48, gender: \u0026#34;male\u0026#34;, address: \u0026#34;碧波潭\u0026#34; }); /* document的方法 Model#save([options], [fn]) */ // stu.save(err =\u0026gt; { // if (!err) { // console.log(\u0026#34;保存成功\u0026#34;); // } // }) StuModel.findOne({}, (err, doc) =\u0026gt; { if (!err) { /* update(update,[options],[callback]) -- 修改对象 remove([callback]) -- 删除对象 */ // console.log(doc);  // doc.update({  // $set: {  // age: 28  // }  // }, err =\u0026gt; {  // if (!err) {  // console.log(\u0026#34;修改成功\u0026#34;);  // }  // })  // doc.remove(err =\u0026gt; {  // if (!err) {  // console.log(\u0026#34;大师兄再见\u0026#34;);  // }  // })  /* get(name) -获取文档中的指定属性值 set() id - 获取文档的_id属性值 toJSON() - 转换为一个JSON字符串 toObject() - 将Document转换成普通的JSON对象 */ // console.log(doc.get(\u0026#34;age\u0026#34;));  // console.log(doc.age);  // doc.set(\u0026#34;name\u0026#34;, \u0026#34;猪🐖\u0026#34;)  // doc.name = \u0026#34;哈哈哈\u0026#34;  doc = doc.toObject(); delete doc.address; console.log(doc); } }) ","permalink":"https://rex0520.github.io/posts/nosql/mongodb/","summary":"MongoDB 简介：   MongoDB是为快速开发互联网Web应用而设计的数据库系统。 MongoDB的设许目标是极简、灵活、作为Web应用栈的一部分。 MongoDB的数据模型是面向文档的,所谓文档是- - -种类似于JSON的结构,简单理解MongoDB这个数据库中存的是各种各样的JSON。 ( BSON )   三个概念   数据库( database )\n 数据库是-个仓库,在仓库中可以存放集合。\n   集合( collection )\n 集合类似于数组,在集合中可以存放文档。\n   文档( dotument )\n 文档数据库中的最小单位,我们存储和操作的 内容都是文档。\n   基本指令   show dbs\n 显示当前的所有数据库\n   use 数据库名\n 进入指定的数据库中\n   db\n 显示当前所处的数据库\n   show collections\n 显示数据库中所有的集合\n   db.","title":"Mongodb基础"},{"content":"Docker 概念  Docker是一个用来装程序及其环境的容器,属于Linux容器的 一种封装,提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。\n 痛点  环境配置 虚拟机  资源占用多 冗余步骤多 启动时间慢   Docker的基础 \u0026mdash; Linux容器  启动快 占用资源少 体积小    用途  提供统一的环境 提供快速拓展、弹性伸缩的云服务 防止其他用户的进程把服务器资源占用过多  特点   标准化\n 运输方式（把程序和环境从一个机器运到另一个机器） 存储方式（程序和环境的存储） API接口（不需要Tomcat等应用的命令了，都标准化了）    灵活：即使是最复杂的应用也可以集装箱化\n  轻量级：容器利用并共享主机内核\n  便携式：可以在本地构建\n  Docker的组成、架构、重要概念 images（镜像）:  存储：联合文件系统，UnionFS    Container（容器）：  镜像类似于Java中的类，而容器就是实例 容器的这一层是可以修改的，而镜像是不可以修改的 同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰  Repository（仓库）：   官方仓库\n  阿里云仓库\n  网易云仓库\n  时速云\n  DaoCloud\n  共有 vs 私有\n  client和daemon  client提供给用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务 daemon：服务端守护进程，接受client发送的命令并执行相应的操作  Docker的网络模式  Bridge 桥接：独立（网卡独立、路由独立、iptable规则独立）的网络，与主机桥接 Host 主机：不是独立的网络，与主机使用同一个网络 None 没有网络 端口映射技术  制作自己的Docker容器，dockerfile实战   dockerfile作用：文本文件，用来配置镜像，docker根据这个来生成对应的镜像文件\n  dockerfile的好处：\n 便于版本控制 便于维护环境 便于新人初步了解程序    写自己的dockerfile\n  FROMalpine:latest # alpine--极小型的Linux环境，表示这个镜像基于这个系统MAINTAINERimooc # 描述这个镜像由谁来维护CMD echo \u0026#39;hello my dockerfile\u0026#39; # 根据自己的业务需求来写    常用命令 docker images # 查询当前镜像列表 docker pull image # 拉取镜像到本地 docker run images image # 前台运行 docker run -d image # 后台运行 d表示detech docker ps # 查看当前后台运行的容器 docker exec -it status bash # -i代表容器输入有效 -t分配一个终端 docker stop status # 关闭容器 docker run -p 8080:80 # 本机8080端口映射到容器的80端口 -p自己定义 -P随机分配主机端口 netstat -na|grep 8080 # 查询端口状态 docker build -t hello_docker . #编译当前的Dockerfile文件，-t指定镜像名字 systemctl stop docker # 停止docker服务 ","permalink":"https://rex0520.github.io/posts/back/microservices/docker%E5%9F%BA%E7%A1%80/","summary":"Docker 概念  Docker是一个用来装程序及其环境的容器,属于Linux容器的 一种封装,提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。\n 痛点  环境配置 虚拟机  资源占用多 冗余步骤多 启动时间慢   Docker的基础 \u0026mdash; Linux容器  启动快 占用资源少 体积小    用途  提供统一的环境 提供快速拓展、弹性伸缩的云服务 防止其他用户的进程把服务器资源占用过多  特点   标准化\n 运输方式（把程序和环境从一个机器运到另一个机器） 存储方式（程序和环境的存储） API接口（不需要Tomcat等应用的命令了，都标准化了）    灵活：即使是最复杂的应用也可以集装箱化\n  轻量级：容器利用并共享主机内核\n  便携式：可以在本地构建\n  Docker的组成、架构、重要概念 images（镜像）:  存储：联合文件系统，UnionFS    Container（容器）：  镜像类似于Java中的类，而容器就是实例 容器的这一层是可以修改的，而镜像是不可以修改的 同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰  Repository（仓库）：   官方仓库","title":"Docker基础"},{"content":"Nginx Nginx介绍 使用场景  HTTP的反向代理服务器  负载均衡 缓存   动态静态资源分离  优点  高并发、高性能 可扩展性好，体现在模块化设计 高可靠性，可以持续不断数十年运行 热部署，不停止服务来升级nginx 开源、可商用  Nginx常用命令 ./nginx # 启动nginx ps -aux|grep nginx # 查看nginx相关进程，也可以查到nginx运行的路径 nginx -h # 帮助 nginx -c # 读取指定配置文件 nginx -s stop # 关闭nginx nginx -t # 检查当前配置文件是否有问题，查看当前配置文件路径 nginx -v # 简要版本信息 -V详细信息 nginx -s stop|quit| # -s信号 stop立即停止，quit优雅停止，reload重启，reopen更换日志文件 Nginx配置文件   语法\n ;结尾 {}组织多条指令 include 引入 #注释 $ 变量    默认配置文件分析\n  nginx.conf\n# 运行用户，默认是nginx user nginx; # nginx进程数,一般设置为和cpu核数一样 worker_processes 1; # 全局错误日志路径 error_log /var/log/nginx/error.log warn; # 进程pid路径 pid /var/run/nginx.pid; events { # 最大连接数  worker_connections 1024; } # 设置http服务器 http { include /etc/nginx/mime.types; default_type application/octet-stream; # 设置日志的格式  log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; # 访问日志的路径  access_log /var/log/nginx/access.log main; # 开启高效传输模式  sendfile on; #tcp_nopush on; # 长连接超时时间，单位是秒  keepalive_timeout 65; #传输时是否压缩，压缩的话需要解压，但是传的大小就小了  #gzip on; #加载其他的配置文件，一带多  include /etc/nginx/conf.d/*.conf; }   server { listen 80; //监听端口为80，可以自定义其他端口，也可以加上IP地址，如，listen 127.0.0.1:8080; server_name localhost; //定义网站域名，可以写多个，用空格分隔。 #charset koi8-r; //定义网站的字符集，一般不设置，而是在网页代码中设置。  #access_log logs/host.access.log main; //定义访问日志，可以针对每一个server（即每一个站点）设置它们自己的访问日志。  ##在server{}里有很多location配置段  location / { root html; //定义网站根目录，目录可以是相对路径也可以是绝对路径。 index index.html index.htm; //定义站点的默认页。 } #error_page 404 /404.html; //定义404页面  # redirect server error pages to the static page /50x.html  #  error_page 500 502 503 504 /50x.html; //当状态码为500、502、503、504时，则访问50x.html location = /50x.html { root html; //定义50x.html所在路径 } # proxy the PHP scripts to Apache listening on 127.0.0.1:80  #  #定义访问php脚本时，将会执行本location{}部分指令  #location ~ \\.php$ {  # proxy_pass http://127.0.0.1; //proxy_pass后面指定要访问的url链接，用proxy_pass实现代理。  #}  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000  #  #location ~ \\.php$ {  # root html;  # fastcgi_pass 127.0.0.1:9000; //定义FastCGI服务器监听端口与地址，支持两种形式，1 IP:Port， 2 unix:/path/to/sockt  # fastcgi_index index.php;  # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; //定义SCRIPT_FILENAME变量，后面的路径/scripts为上面的root指定的目录  # include fastcgi_params; //引用prefix/conf/fastcgi_params文件，该文件定义了fastcgi相关的变量  #}  # deny access to .htaccess files, if Apache\u0026#39;s document root  # concurs with nginx\u0026#39;s one  #  #location ~ /\\.ht { //访问的url中，以/.ht开头的，如，www.example.com/.htaccess，会被拒绝，返回403状态码。  # deny all; //这里的all指的是所有的请求。  #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; //监听8000端口 # listen somename:8080; //指定ip:port # server_name somename alias another.alias; //指定多个server_name # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; //监听443端口，即ssl # server_name localhost; ### 以下为ssl相关配置 # ssl_certificate cert.pem; //指定pem文件路径 # ssl_certificate_key cert.key; //指定key文件路径 # ssl_session_cache shared:SSL:1m; //指定session cache大小 # ssl_session_timeout 5m; //指定session超时时间 # ssl_protocols TLSv1 TLSv1.1 TLSv1.2; //指定ssl协议 # ssl_ciphers HIGH:!aNULL:!MD5; //指定ssl算法 # ssl_prefer_server_ciphers on; //优先采取服务器算法 # location / { # root html; # index index.html index.htm; # } #}   location ^~ /api { rewrite ^/api/(.*)$ /$1 break; proxy_pass http://localhost:8080; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_redirect off; }     ","permalink":"https://rex0520.github.io/posts/back/microservices/nginx%E4%BD%BF%E7%94%A8/","summary":"Nginx Nginx介绍 使用场景  HTTP的反向代理服务器  负载均衡 缓存   动态静态资源分离  优点  高并发、高性能 可扩展性好，体现在模块化设计 高可靠性，可以持续不断数十年运行 热部署，不停止服务来升级nginx 开源、可商用  Nginx常用命令 ./nginx # 启动nginx ps -aux|grep nginx # 查看nginx相关进程，也可以查到nginx运行的路径 nginx -h # 帮助 nginx -c # 读取指定配置文件 nginx -s stop # 关闭nginx nginx -t # 检查当前配置文件是否有问题，查看当前配置文件路径 nginx -v # 简要版本信息 -V详细信息 nginx -s stop|quit| # -s信号 stop立即停止，quit优雅停止，reload重启，reopen更换日志文件 Nginx配置文件   语法\n ;结尾 {}组织多条指令 include 引入 #注释 $ 变量    默认配置文件分析","title":"Nginx使用"},{"content":"微服务 微服务概述 单体应用的痛点  部署效率低下 团队写作开发成本高 系统高可用性差  服务化  把传统的单机应用中的本地方法调用，改造成通过RPC、HTTP产生的远程方法调用 把模块从单体应用中拆分出来，独立成一个服务部署 用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合  从单体到微服务架构 微服务   一种架构风格 开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源API 这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署 这些服务的集中式管理做到了最小化（例如docker相关技术），每一种服务都可以通过不同的变成语言进行编写，并且可以使用不同的数据存储技术   微服务的特点   组件以服务形式来提供\n  产品不是项目\n  轻量级通信、独立进程\n  分散治理、去中心化治理\n  容错性设计\n  会带来团队组织架构的调整\n  微服务优点  服务简单、便于学习和上手，先对易于维护 独立部署，灵活扩展 技术栈丰富  微服务缺点  运维成本过高 接口可能不匹配 代码可能重复 架构复杂度提高  微服务有两大门派  Spring Cloud：众多子项目 dubbo：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡以及服务自动注册和发现     核心组件 Dubbo Spring Cloud     服务注册中心 Zookeeper Spring Cloud Netflix Eureka   服务调用方式 RPC REST API   服务网关 无 Spring Cloud Netflix Zuul   断路器 不完善 Spring Cloud Netflix Hystrix   分布式配置 无/百度的disconf、百度的diamond Spring Cloud Config   服务跟踪 无/京东开源Hydra Spring Cloud Sleuth   消息总线 无 Spring Cloud Bus   数据流 无 Spring Cloud Stream   批量任务 无/当当开源Elastic-Job Spring Cloud Task    通信协议对比  RPC vs REST 服务提供方与调用方接口依赖方式太强 服务对平台敏感，难以简单服务  微服务拆分 服务化拆分  第一阶段的主要目标是快速开发和验证想法 进一步增加更多的新特性来吸引更多的目标用户 同时进行开发的人员超过10人，这个时候就该考虑服务化拆分了  不适合拆分的情况  小团队，技术基础较薄弱 流量不够，压力小，业务变化也不大 对延迟很敏感的低延迟高并发系统  拆分方式  纵向拆分，按照业务维度拆分 横向拆分，按照公共领域拆分 结合业务综合分析  服务扩展  x轴-水平复制，作为整体复制多个系统，重新部署几套，加一个负载均衡器 y轴-功能解耦，微服务拆解 z轴-数据分区，拆分数据库  自动按需扩展  根据CPU负载程度、特定时间（比如周末）、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展 自动分配了一个新的服务实例，提高可用性 提高了可伸缩性（双11之后，自动减少了服务器） 具有最佳使用率，节约成本  微服务重要模块  服务描述 注册服务中心 服务框架 负载均衡 熔断和降级，兜底策略 网关：统一转换，校验，过滤器  ","permalink":"https://rex0520.github.io/posts/back/microservices/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","summary":"微服务 微服务概述 单体应用的痛点  部署效率低下 团队写作开发成本高 系统高可用性差  服务化  把传统的单机应用中的本地方法调用，改造成通过RPC、HTTP产生的远程方法调用 把模块从单体应用中拆分出来，独立成一个服务部署 用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合  从单体到微服务架构 微服务   一种架构风格 开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源API 这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署 这些服务的集中式管理做到了最小化（例如docker相关技术），每一种服务都可以通过不同的变成语言进行编写，并且可以使用不同的数据存储技术   微服务的特点   组件以服务形式来提供\n  产品不是项目\n  轻量级通信、独立进程\n  分散治理、去中心化治理\n  容错性设计\n  会带来团队组织架构的调整\n  微服务优点  服务简单、便于学习和上手，先对易于维护 独立部署，灵活扩展 技术栈丰富  微服务缺点  运维成本过高 接口可能不匹配 代码可能重复 架构复杂度提高  微服务有两大门派  Spring Cloud：众多子项目 dubbo：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡以及服务自动注册和发现     核心组件 Dubbo Spring Cloud     服务注册中心 Zookeeper Spring Cloud Netflix Eureka   服务调用方式 RPC REST API   服务网关 无 Spring Cloud Netflix Zuul   断路器 不完善 Spring Cloud Netflix Hystrix   分布式配置 无/百度的disconf、百度的diamond Spring Cloud Config   服务跟踪 无/京东开源Hydra Spring Cloud Sleuth   消息总线 无 Spring Cloud Bus   数据流 无 Spring Cloud Stream   批量任务 无/当当开源Elastic-Job Spring Cloud Task    通信协议对比  RPC vs REST 服务提供方与调用方接口依赖方式太强 服务对平台敏感，难以简单服务  微服务拆分 服务化拆分  第一阶段的主要目标是快速开发和验证想法 进一步增加更多的新特性来吸引更多的目标用户 同时进行开发的人员超过10人，这个时候就该考虑服务化拆分了  不适合拆分的情况  小团队，技术基础较薄弱 流量不够，压力小，业务变化也不大 对延迟很敏感的低延迟高并发系统  拆分方式  纵向拆分，按照业务维度拆分 横向拆分，按照公共领域拆分 结合业务综合分析  服务扩展  x轴-水平复制，作为整体复制多个系统，重新部署几套，加一个负载均衡器 y轴-功能解耦，微服务拆解 z轴-数据分区，拆分数据库  自动按需扩展  根据CPU负载程度、特定时间（比如周末）、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展 自动分配了一个新的服务实例，提高可用性 提高了可伸缩性（双11之后，自动减少了服务器） 具有最佳使用率，节约成本  微服务重要模块  服务描述 注册服务中心 服务框架 负载均衡 熔断和降级，兜底策略 网关：统一转换，校验，过滤器  ","title":"微服务"},{"content":"RabbitMQ RabbitMQ简介 核心思想  接受并转发消息。\n producer: P queue: queue_name Consumer: C 消息队列：  业务无关 FIFO 容灾 性能  特点：  开源、跨语言 Erlang语言编写 应用广泛 社区活跃、API丰富  AMBQ协议  Advanced Message Queue Protocol   RabbitMQ核心概念  Server：服务 connection：与Server建立连接 channel：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道 message：消息，有properties和body组成 virtual host：虚拟主机，顶层隔离。同一个虚拟主机下，不能有重复的交换机和queue Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到锁绑定的队列上 binding：绑定交换机和队列 routing key：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由 queue：队列，消费者只需要监听队列来消费信息，不需要关注消息来自于哪个Exchange Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列 消息流转过程      RabbitMQ常用命令 systemctl start rabbitmq-server # 启动rabbitmq rabbitmqctl status # 查看状态 RabbitMQ后台管理  http://1.117.91.88:15672/#/connections rabbitmq management\n RabbitMQ应用 第一个java应用 Hello world   导入依赖\n  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.rabbitmq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;amqp-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-nop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.29\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     Send.java\n  package helloworld; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: Hello world发送类，连接到RabbitMQ服务端， * 然后发送一条消息，然后退出。 * @Author: Rex * @Create: 2021-06-16 12:54 */ public class Send { private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂  ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址  factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接  Connection conn = factory.newConnection(); // 获得信道  Channel channel = conn.createChannel(); // 声明队列  channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发布消息  String message = \u0026#34;Hello rex!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, QUEUE_NAME, null, message.getBytes(\u0026#34;UTF-8\u0026#34;)); System.out.println(\u0026#34;发送了消息：\u0026#34; + message); // 关闭连接  channel.close(); conn.close(); } }     Resv.java\n  package helloworld; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 接受消息，并打印，持续运行 * @Author: Rex * @Create: 2021-06-16 13:11 */ public class Recv { private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂  ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址  factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接  Connection conn = factory.newConnection(); // 获得信道  Channel channel = conn.createChannel(); // 声明队列  channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 接受消息  channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;接收到了消息：\u0026#34; + message); } }); } }     控制台\n  Send 发送了消息：Hello rex! Recv 接收到了消息：Hello rex!     多个消费者平均分配 NewTask.java\npackage workqueues; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 消费者，接受前面的批量消息 * @Author: Rex * @Create: 2021-06-16 14:23 */ public class Worker { private final static String TASK_QUEUE_NAME = \u0026#34;task_queue\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂  ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址  factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接  Connection conn = factory.newConnection(); // 获得信道  Channel channel = conn.createChannel(); // 声明队列  channel.basicQos(1); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\u0026#34;开始接收消息\u0026#34;); channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;收到了消息：\u0026#34; + message); try { doWork(message); } finally { System.out.println(\u0026#34;完成消息处理\u0026#34;); channel.basicAck(envelope.getDeliveryTag(), false); } } }); } private static void doWork(String task){ char[] chars = task.toCharArray(); for (char ch : chars) { if (ch == \u0026#39;.\u0026#39;){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } Worker\npackage workqueues; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @Description: 消费者，接受前面的批量消息 * @Author: Rex * @Create: 2021-06-16 14:23 */ public class Worker { private final static String TASK_QUEUE_NAME = \u0026#34;task_queue\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂  ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ地址  factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 建立连接  Connection conn = factory.newConnection(); // 获得信道  Channel channel = conn.createChannel(); // 声明队列  channel.basicQos(1); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\u0026#34;开始接收消息\u0026#34;); channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;收到了消息：\u0026#34; + message); try { doWork(message); } finally { System.out.println(\u0026#34;完成消息处理\u0026#34;); channel.basicAck(envelope.getDeliveryTag(), false); } } }); } private static void doWork(String task){ char[] chars = task.toCharArray(); for (char ch : chars) { if (ch == \u0026#39;.\u0026#39;){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 控制台\nNewTask 发送了消息：message 0... 发送了消息：message 1 发送了消息：message 2... 发送了消息：message 3 发送了消息：message 4... 发送了消息：message 5 发送了消息：message 6... 发送了消息：message 7 发送了消息：message 8... 发送了消息：message 9 Worker(1) 开始接收消息 收到了消息：message 0... 完成消息处理 收到了消息：message 5 完成消息处理 收到了消息：message 7 完成消息处理 收到了消息：message 8... 完成消息处理 Worker(2) 开始接收消息 收到了消息：message 1 完成消息处理 收到了消息：message 3 完成消息处理 收到了消息：message 4... 完成消息处理 收到了消息：message 9 完成消息处理 Worker(3) 开始接收消息 收到了消息：message 2... 完成消息处理 收到了消息：message 6... 完成消息处理 交换机 交换机工作模式   fanout\n 广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的\n EmitLog.java\npackage fanout; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.Exchanger; import java.util.concurrent.TimeoutException; /** * @Description: 发送日志信息 * @Author: Rex * @Create: 2021-06-17 15:58 */ public class EmitLog { private static final String EXCHANGE_NAME = \u0026#34;logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT.getType()); String message = \u0026#34;info: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息：\u0026#34; + message); channel.close(); conn.close(); } } ReceiveLogs.java\npackage fanout; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受日志消息 * @Author: Rex * @Create: 2021-06-17 16:07 */ public class ReceiveLogs { private static final String EXCHANGE_NAME = \u0026#34;logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT.getType()); // 临时队列  String queueName = channel.queueDeclare().getQueue(); // 将队列绑定在交换机上  channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLog 发送了消息：info: Hello World! ReceiveLogs 开始接受消息 收到消息：info: Hello World! ReceiveLogs(2) 开始接受消息 收到消息：info: Hello World! ReceiveLogs(3) 开始接受消息 收到消息：info: Hello World!   direct\n 根据RoutingKey匹配消息路由到指定的队列\n EmitLogDirect\npackage direct; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: direct类型的交换机，发送消息 * @Author: Rex * @Create: 2021-06-17 16:31 */ public class EmitLogDirect { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); String message = \u0026#34;info: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;info\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为info，消息内容：\u0026#34;+ message); message = \u0026#34;warning: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;warning\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为warning，消息内容：\u0026#34;+ message); message = \u0026#34;error: Hello World!\u0026#34;; channel.basicPublish(EXCHANGE_NAME, \u0026#34;error\u0026#34;, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了消息，\u0026#34; + \u0026#34;等级为error，消息内容：\u0026#34;+ message); channel.close(); conn.close(); } } ReceiveLogsDirect1.java\npackage direct; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受3个类型等级的日志 * @Author: Rex * @Create: 2021-06-17 16:37 */ public class ReceiveLogsDirect1 { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); // 生成一个随机的临时的队列  String queueName = channel.queueDeclare().getQueue(); // 一个交换机同时绑定3个对列  channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;info\u0026#34;); channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;warning\u0026#34;); channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;error\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } ReceiveLogsDirect2.java\npackage direct; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 接受1个类型等级的日志 * @Author: Rex * @Create: 2021-06-17 16:37 */ public class ReceiveLogsDirect2 { private static final String EXCHANGE_NAME = \u0026#34;direct_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT.getType()); // 生成一个随机的临时的队列  String queueName = channel.queueDeclare().getQueue(); // 一个交换机只绑定1个对列  channel.queueBind(queueName, EXCHANGE_NAME, \u0026#34;error\u0026#34;); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLogDirect: 发送了消息，等级为info，消息内容：info: Hello World! 发送了消息，等级为warning，消息内容：warning: Hello World! 发送了消息，等级为error，消息内容：error: Hello World! ReceiveLogsDirect1: 开始接受消息 收到消息：info: Hello World! 收到消息：warning: Hello World! 收到消息：error: Hello World! ReceiveLogsDirect2: 开始接受消息 收到消息：error: Hello World!   topic\n 生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发\n *可以代替一个单词 #可以代替零个或多个单词   EmitLogTopic.java\npackage topic; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: Topic模式交换机，发送消息 * @Author: Rex * @Create: 2021-06-18 11:23 */ public class EmitLogTopic { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); String message = \u0026#34;Animal world!\u0026#34;; String[] routingKeys = new String[9]; routingKeys[0] = \u0026#34;quick.orange.rabbit\u0026#34;; routingKeys[1] = \u0026#34;lazy.orange.elephant\u0026#34;; routingKeys[2] = \u0026#34;quick.orange.fox\u0026#34;; routingKeys[3] = \u0026#34;lazy.brown.fox\u0026#34;; routingKeys[4] = \u0026#34;lazy.pink.rabbit\u0026#34;; routingKeys[5] = \u0026#34;quick.brown.fox\u0026#34;; routingKeys[6] = \u0026#34;orange\u0026#34;; routingKeys[7] = \u0026#34;quick.orange.male.rabbit\u0026#34;; routingKeys[8] = \u0026#34;lazy.orange.male.rabbit\u0026#34;; for (int i = 0; i \u0026lt; routingKeys.length; i++) { channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;发送了：\u0026#34; + message + \u0026#34;routingKey：\u0026#34; + routingKeys[i]); } channel.close(); conn.close(); } } ReceiveLogsTopic1.java\npackage topic; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 特定路由键 * @Author: Rex * @Create: 2021-06-18 11:48 */ public class ReceiveLogsTopic1 { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); // 生成一个随机的临时的队列  String queueName = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;*.orange.*\u0026#34;; channel.queueBind(queueName, EXCHANGE_NAME, routingKey); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message + \u0026#34; routingKey: \u0026#34; + envelope.getRoutingKey()); } }; channel.basicConsume(queueName, true, consumer); } } ReveiveLogsTopic2.java\npackage topic; import com.rabbitmq.client.*; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * @Description: 特定路由键 * @Author: Rex * @Create: 2021-06-18 11:48 */ public class ReceiveLogsTopic1 { private static final String EXCHANGE_NAME = \u0026#34;topic_logs\u0026#34;; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;1.117.91.88\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); Connection conn = factory.newConnection(); Channel channel = conn.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC.getType()); // 生成一个随机的临时的队列  String queueName = channel.queueDeclare().getQueue(); String routingKey = \u0026#34;*.orange.*\u0026#34;; channel.queueBind(queueName, EXCHANGE_NAME, routingKey); System.out.println(\u0026#34;开始接受消息\u0026#34;); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, StandardCharsets.UTF_8); System.out.println(\u0026#34;收到消息：\u0026#34; + message + \u0026#34; routingKey: \u0026#34; + envelope.getRoutingKey()); } }; channel.basicConsume(queueName, true, consumer); } } 控制台\nEmitLogTopic 发送了：Animal world!routingKey：quick.orange.rabbit 发送了：Animal world!routingKey：lazy.orange.elephant 发送了：Animal world!routingKey：quick.orange.fox 发送了：Animal world!routingKey：lazy.brown.fox 发送了：Animal world!routingKey：lazy.pink.rabbit 发送了：Animal world!routingKey：quick.brown.fox 发送了：Animal world!routingKey：orange 发送了：Animal world!routingKey：quick.orange.male.rabbit 发送了：Animal world!routingKey：lazy.orange.male.rabbit ReceiveLogsTopic1 开始接受消息 收到消息：Animal world! routingKey: quick.orange.rabbit 收到消息：Animal world! routingKey: lazy.orange.elephant 收到消息：Animal world! routingKey: quick.orange.fox ReceiveLogsTopic2 开始接受消息 收到消息：Animal world! routingKey: quick.orange.rabbit 收到消息：Animal world! routingKey: lazy.orange.elephant 收到消息：Animal world! routingKey: lazy.brown.fox 收到消息：Animal world! routingKey: lazy.pink.rabbit 收到消息：Animal world! routingKey: lazy.orange.male.rabbit   headers（不常用）\n 根据发送消息内容中的headers属性来匹配\n   SpringBoot整合RabbitMQ   引入依赖文件\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp \u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   编写application.propertise\nconsumer\nserver.port=8081 spring.application.name=consumer spring.rabbitmq.addresses=1.117.91.88:5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000 producer\nserver.port=8080 spring.application.name=producer spring.rabbitmq.addresses=1.117.91.88:5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000   生产者中编写配置文件\npackage com.imooc.springbootrabbitmqproducer; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Description: rabbitmq配置类 * @Author: Rex * @Create: 2021-06-19 9:58 */ @Configuration public class TopicRabbitConfig { @Bean public Queue queue1(){ return new Queue(\u0026#34;queue1\u0026#34;); } @Bean public Queue queue2(){ return new Queue(\u0026#34;queue2\u0026#34;); } @Bean TopicExchange exchange(){ return new TopicExchange(\u0026#34;bootExchange\u0026#34;); } @Bean Binding bindingExchangeMessage1(Queue queue1, TopicExchange exchange){ return BindingBuilder.bind(queue1).to(exchange).with(\u0026#34;dog.red\u0026#34;); } @Bean Binding bindingExchangeMessage2(Queue queue2, TopicExchange exchange){ return BindingBuilder.bind(queue2).to(exchange).with(\u0026#34;dog.#\u0026#34;); } }   生产者发送消息\npackage com.imooc.springbootrabbitmqproducer; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; /** * @Description: 发送消息 * @Author: Rex * @Create: 2021-06-19 10:06 */ @Component public class MessageSender { @Autowired private AmqpTemplate rabbitmqTemplate; public void send1(){ String message = \u0026#34;This is message 1, routing key is dog.red\u0026#34;; System.out.println(\u0026#34;发送了：\u0026#34; + message); this.rabbitmqTemplate.convertAndSend(\u0026#34;bootExchange\u0026#34;, \u0026#34;dog.red\u0026#34;, message); } public void send2(){ String message = \u0026#34;This is message 1, routing key is dog.black\u0026#34;; System.out.println(\u0026#34;发送了：\u0026#34; + message); this.rabbitmqTemplate.convertAndSend(\u0026#34;bootExchange\u0026#34;, \u0026#34;dog.black\u0026#34;, message); } }   消费者接受消息\nReceiver1.java\npackage com.imooc.springbootrabbitmqconsumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @Description: 接收者1 * @Author: Rex * @Create: 2021-06-19 10:11 */ @Component @RabbitListener(queues = \u0026#34;queue1\u0026#34;) public class Receiver1 { @RabbitHandler public void process(String message){ System.out.println(\u0026#34;Receiver1：\u0026#34; + message); } } Receiver2.java\npackage com.imooc.springbootrabbitmqconsumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @Description: 接收者2 * @Author: Rex * @Create: 2021-06-19 10:11 */ @Component @RabbitListener(queues = \u0026#34;queue2\u0026#34;) public class Receiver2 { @RabbitHandler public void process(String message){ System.out.println(\u0026#34;Receiver2：\u0026#34; + message); } }   生产者发送消息\npackage com.imooc.springbootrabbitmqproducer; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class SpringBootRabbitmqProducerApplicationTests { @Autowired private MessageSender messageSender; @Test public void send1(){ messageSender.send1(); } @Test public void send2(){ messageSender.send2(); } }   结果\n生产者：\n2021-06-19 10:19:00.888 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : Starting SpringBootRabbitmqProducerApplicationTests on LAPTOP-LRX with PID 20912 (started by Rex in G:\\Web开发\\后端\\code\\spring-boot-rabbitmq-producer) 2021-06-19 10:19:00.891 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : No active profile set, falling back to default profiles: default 2021-06-19 10:19:05.283 INFO 20912 --- [ main] ringBootRabbitmqProducerApplicationTests : Started SpringBootRabbitmqProducerApplicationTests in 5.244 seconds (JVM running for 8.205) 发送了：This is message 1, routing key is dog.red 2021-06-19 10:19:05.814 INFO 20912 --- [ main] o.s.a.r.c.CachingConnectionFactory : Attempting to connect to: [1.117.91.88:5672] 2021-06-19 10:19:06.059 INFO 20912 --- [ main] o.s.a.r.c.CachingConnectionFactory : Created new connection: rabbitConnectionFactory#7072bc39:0/SimpleConnection@ff6077 [delegate=amqp://admin@1.117.91.88:5672/, localPort= 10788] 发送了：This is message 1, routing key is dog.black 消费者\n2021-06-19 10:18:35.322 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : Starting SpringBootRabbitmqConsumerApplication on LAPTOP-LRX with PID 30312 (started by Rex in G:\\Web开发\\后端\\code\\spring-boot-rabbitmq-consumer) 2021-06-19 10:18:35.328 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : No active profile set, falling back to default profiles: default 2021-06-19 10:18:37.160 INFO 30312 --- [ main] o.s.a.r.c.CachingConnectionFactory : Attempting to connect to: [1.117.91.88:5672] 2021-06-19 10:18:37.299 INFO 30312 --- [ main] o.s.a.r.c.CachingConnectionFactory : Created new connection: rabbitConnectionFactory#21a21c64:0/SimpleConnection@7c098bb3 [delegate=amqp://admin@1.117.91.88:5672/, localPort= 7674] Receiver1：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.black 2021-06-19 10:18:37.602 INFO 30312 --- [ main] .s.SpringBootRabbitmqConsumerApplication : Started SpringBootRabbitmqConsumerApplication in 3.042 seconds (JVM running for 6.02) Receiver1：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.red Receiver2：This is message 1, routing key is dog.black   @RabbitListener   当@RabbitListener注解标注在方法上，监听到队列 debug 中有消息时则会进行接收并处理。 当@RabbitListener标注在类上面时，需配合@RabbitHandler注解一起使用。   @RabbitHandler  （@RabbitHandle注解用于表示收到某队列对应类型的消息时，要执行的内容。）\n当有收到某队列queue里面的消息的时候，就交给有@RabbitHandler注解的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型。RabbitMQ支持任何类型的数据消息。\n ","permalink":"https://rex0520.github.io/posts/back/microservices/rabbitmq/","summary":"RabbitMQ RabbitMQ简介 核心思想  接受并转发消息。\n producer: P queue: queue_name Consumer: C 消息队列：  业务无关 FIFO 容灾 性能  特点：  开源、跨语言 Erlang语言编写 应用广泛 社区活跃、API丰富  AMBQ协议  Advanced Message Queue Protocol   RabbitMQ核心概念  Server：服务 connection：与Server建立连接 channel：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道 message：消息，有properties和body组成 virtual host：虚拟主机，顶层隔离。同一个虚拟主机下，不能有重复的交换机和queue Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到锁绑定的队列上 binding：绑定交换机和队列 routing key：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由 queue：队列，消费者只需要监听队列来消费信息，不需要关注消息来自于哪个Exchange Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列 消息流转过程      RabbitMQ常用命令 systemctl start rabbitmq-server # 启动rabbitmq rabbitmqctl status # 查看状态 RabbitMQ后台管理  http://1.117.91.88:15672/#/connections rabbitmq management","title":"Rabbitmq使用"},{"content":"CSS3 CSS新增选择器 属性选择器    选择器 简介     E[attr] 选择具有attr属性的E元素   E[attr=\u0026ldquo;val\u0026rdquo;] 选择具有attr属性且属性值等于E的元素   E[attr^=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val开头的E元素   E[attr$=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val结尾的E元素   E[attr*=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值中含有val的E元素    属性选择器的权重为10\n结构伪类选择器    选择符 简介     E:first-child 匹配父元素中的第一个子元素E   E:last-child 匹配父元素中最后一个E元素   E:nth-child(n) 匹配父元素中的第n个子元素E   E:first-of-type 指定类型E的第一个   E:last-of-type 指定类型E的最后一个   E:nth-of-type(n) 指定类型E的第n个    nth-child(n)\n n可以是数字，关键字和公式 n如果是是数字，就是选择第n个子元素，里面数字从1开始 n可以是关键字：even偶数，odd奇数  伪元素选择器 ​\t伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构\n   选择器 简介     ::before 在元素内部的前面插入内容   ::after 在元素内部的后面插入内容    注意：\n before和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法：element::before{} before和after必须有content属性 before在父元素内容的前面创建元素，after在父元素内容的后面插入元素 伪元素选择器和标签选择器一样，权重为1  CSS3盒子模型 box-sizing:  content-box 盒子大小为width+padding+border(以前默认的) border-box 盒子大小width  其他特性（了解）   filter CSS属性将模糊或颜色偏移等图形效果应用于元素。\nfilter: 函数(); 例如filter:blur(5px); blur模糊处理数值越大越模糊   calc()此CSS函数让你在声明CSS属性值时执行一些计算。\nwidth:calc(100%-80px);   CSS过渡 transition:要过渡的属性 花费时间 运动曲线 何时开始;\n  属性：想要变化的CSS属性，宽度高度 背景颜色 内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以。\n  花费时间：单位是秒（必须写单位）比如0.5s\n  运动曲线：默认是ease（可以省略）\nlinear:匀速\nease:逐渐慢下来\nease-in:加速\nease-out:减速\nease-in-out:先加速后减速\n  何时开始：单位是秒（必须写单位）可以设置延迟触发时间 默认是0s（可以省略）\n  谁做过渡给谁加\n2D转换  转换(transform)是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果\n 移动：translate 旋转：rotate 缩放：scale  2D转换是改变在二维平面上的位置和形状的一种技术\n translate:  平移元素\ntransform: translate(x, y) | translateX(x) | translateY(y)\n  定义2D转换中的移动，沿着X和Y轴移动元素 translate最大的优点：不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的translate：(50%, 50%); 对行内标签没有效果  rotate旋转：  旋转元素\ntransform: rotate(xdeg)\n transform-origin  设置元素中心点\ntransform-origin: x y;\n  参数x和y用空格隔开 x y默认转换的中心点是元素的中心点（50%, 50%） 给x y设置像素或方位名词（top bottom left right center）  2D转换之缩放scale  控制元素的放大与缩小\ntransform: scale(x, y)\n  注意其中的x和y用逗号分隔 transform: scale(1, 1)：宽和高都放大一倍，相对于没有放大 transform: scale(2, 2)：宽和高都放大了2倍 transform: scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于scale(2,2) transform：scale(0.5, 0.5)：缩小 scale缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子  2D转换综合写法  同时使用多个转换，其格式为：transform: translate() rotate() scale() \u0026hellip;等 其顺序回影响转换的效果。（先旋转会改变坐标轴方向） 当我们同时有位移和其他属性的时候，记得要将位移放到最前  动画  动画（animation）是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。\n相比较过渡，动画可以实现更多变化，更多控制，连续自动播放。\n 基本使用 @keyframes move { /* 开始状态 */ 0% { transform: translateX(0px); } /* 结束状态 */ 100% { transform: translateX(100px); } } div { width: 200px; height: 200px; background-color: pink; /* 调用动画 */ animation-name: move; /* 持续时间 */ animation-duration: 1s; } 动画序列  可以做多个状态的变化 keyframe关键帧 里面的百分比要是整数 里面的百分比就是总的时间  动画常用属性    属性 描述     @keyframes 规定动画   animation 所有动画属性的简写属性，除了animation-play-state属性。   animation-name 规定@keyframes动画的名称。（必须的）   animation-duration 规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须的）   animation-timing-function 规定动画的速度曲线，默认是“ease”。   animation-delay 规定动画何时开始，默认是0。   animation-iteration-count 规定动画播放的次数，默认是1，还有infinite   animation-direction 规定动画是否在下一周期逆向播放，默认是\u0026quot;normal\u0026quot;，alternate逆播放   animation-play-state 规定动画是否正在运行或暂停。默认是\u0026quot;running\u0026quot;，还有\u0026quot;pause\u0026quot;。   animation-fill-mode 规定动画结束后状态，保持forwards回到起始backwards    ","permalink":"https://rex0520.github.io/posts/front/css3/","summary":"CSS3 CSS新增选择器 属性选择器    选择器 简介     E[attr] 选择具有attr属性的E元素   E[attr=\u0026ldquo;val\u0026rdquo;] 选择具有attr属性且属性值等于E的元素   E[attr^=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val开头的E元素   E[attr$=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值以val结尾的E元素   E[attr*=\u0026ldquo;val\u0026rdquo;] 匹配具有attr属性且值中含有val的E元素    属性选择器的权重为10\n结构伪类选择器    选择符 简介     E:first-child 匹配父元素中的第一个子元素E   E:last-child 匹配父元素中最后一个E元素   E:nth-child(n) 匹配父元素中的第n个子元素E   E:first-of-type 指定类型E的第一个   E:last-of-type 指定类型E的最后一个   E:nth-of-type(n) 指定类型E的第n个    nth-child(n)","title":"CSS3"},{"content":"Nginx的安装 Linux安装  登录root账号 执行yum install yum-utils 运行vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true  然后查看源 yum list | grep nginx 看到存在稳定版的源，确认无误。 运行安装命令 yum install nginx 1:1.16.1-1.el7.ngx 过程中输入y，确认 查看版本，若出现版本号，则安装成功 用whereis nginx可以查看到目录： nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz  MacOS的安装  安装homebrew，然后nginx使用安装brew： $ brew install nginx  笔记：\n nginx的配置文件位于中/usr/local/etc/nginx/nginx.conf。 要编辑配置文件或运行nginx，您需要使用sudo： sudo nano /usr/local/etc/nginx/nginx.conf和 sudo nginx \u0026hellip;\n Windows下的安装 不推荐，nginx不适合运行在Windows上，功能不完整，我们尽量运行在linux上。\n","permalink":"https://rex0520.github.io/posts/back/microservices/nginx%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"Nginx的安装 Linux安装  登录root账号 执行yum install yum-utils 运行vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true  然后查看源 yum list | grep nginx 看到存在稳定版的源，确认无误。 运行安装命令 yum install nginx 1:1.16.1-1.el7.ngx 过程中输入y，确认 查看版本，若出现版本号，则安装成功 用whereis nginx可以查看到目录： nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz  MacOS的安装  安装homebrew，然后nginx使用安装brew： $ brew install nginx  笔记：\n nginx的配置文件位于中/usr/local/etc/nginx/nginx.conf。 要编辑配置文件或运行nginx，您需要使用sudo： sudo nano /usr/local/etc/nginx/nginx.conf和 sudo nginx \u0026hellip;\n Windows下的安装 不推荐，nginx不适合运行在Windows上，功能不完整，我们尽量运行在linux上。","title":"Nginx的入门"},{"content":"Docker的安装 在Cent OS安装docker  先有一个Cent OS 7.6系统   这个很重要，不同版本按照的时候是不一样的。查看CentOS版本 cat /etc/redhat-release\n 用root账户登录进去 配置国内yum源   wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache\n 卸载旧版本   较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。 如果yum报告未安装这些软件包，也没问题。\n docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 更新yum   yum check-update yum update\n 安装所需的软件包  yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的存储库。   sudo yum-config-manager \u0026ndash;add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n 查看docker版本   yum list docker-ce \u0026ndash;showduplicates | sort -r\n 安装指定的版本   yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io\n Docker 是服务器\u0026mdash;-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动   systemctl start docker\n 安装完成后，运行下面的命令，验证是否安装成功。   docker version 或者 docker info\n ","permalink":"https://rex0520.github.io/posts/back/microservices/docker%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"Docker的安装 在Cent OS安装docker  先有一个Cent OS 7.6系统   这个很重要，不同版本按照的时候是不一样的。查看CentOS版本 cat /etc/redhat-release\n 用root账户登录进去 配置国内yum源   wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache\n 卸载旧版本   较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。 如果yum报告未安装这些软件包，也没问题。\n docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 更新yum   yum check-update yum update\n 安装所需的软件包  yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的存储库。   sudo yum-config-manager \u0026ndash;add-repo http://mirrors.","title":"Docker的安装"},{"content":"分布式 定义：  利用物理架构形成多个自治的处理元素，不共享主内存, 但是通过发送信息合作。\u0026mdash; Leslie Lamport\n 实际项目的演进过程  一个项目，大而全 多台机器，部署同样的应用 分布式：权限系统、员工系统、请假系统  分布式的作用 为什么需要分布式  解决单体应用的问题  应用代码耦合严重，功能扩展难 新需求开发交互周期长，测试工程量大 新加入的开发同事需要很长时间才能属性系统 升级维护困难（改动任何一点地方都要升级整个系统） 系统性能提升艰难，可用性低，不稳定    分布式的好处  增大系统容量 加强系统可用 因为模块化，所以系统模块重用度高 因为软件服务模块被拆分，开发和发布速度可以并行变得更块 系统拓展性更高 团队协作流程也会得到改善 技术升级  分布式和单体结构的对比     传统单体结构 分布式架构     新人的学习成本 业务逻辑成本高 架构逻辑成本高   部署、运维 容易 发布频繁，发布顺序复杂、运维难   隔离性 一损俱损，殃及鱼塘 故障影响范围小   架构设计 难度低 难度指数级上升   系统性能 响应快、吞吐量小 响应慢、吞吐量大   测试成本 低 很高   技术多样性 技术单一且封闭 技术多样且开放   系统扩展性 扩展性差 扩展性很好   系统管理成本 成本低 成本高    CAP定理   CAP理论：三者不可兼得\n C：（Consistency，一致性）：读操作是否总能读到前一个写操作的结果 A：（Availbilty，可用性）：非故障节点应该在合理的时间内做出合理的响应，但是可能不是最新的数据 P：（Partition tolerance，分区容错性）：当出现网络分区现象后，系统能够继续运行    分区容错（P）\n  一致性（C）\n  可用性(A)\n  CAP的选取\n 火车票 C 银行转账 A    集群、分布式、微服务的区别 集群与分布式  集群：一个业拆分多个子业务，部署在不同的服务器上 分布式：同一个业务，部署在多个服务器上  集群和微服务  集群：分散压力 微服务：分散能力  分布式和微服务  分布式：系统部署方式，部署角度（后） 微服务：架构设计方式，逻辑角度（先）  ","permalink":"https://rex0520.github.io/posts/back/microservices/%E5%88%86%E5%B8%83%E5%BC%8F/","summary":"分布式 定义：  利用物理架构形成多个自治的处理元素，不共享主内存, 但是通过发送信息合作。\u0026mdash; Leslie Lamport\n 实际项目的演进过程  一个项目，大而全 多台机器，部署同样的应用 分布式：权限系统、员工系统、请假系统  分布式的作用 为什么需要分布式  解决单体应用的问题  应用代码耦合严重，功能扩展难 新需求开发交互周期长，测试工程量大 新加入的开发同事需要很长时间才能属性系统 升级维护困难（改动任何一点地方都要升级整个系统） 系统性能提升艰难，可用性低，不稳定    分布式的好处  增大系统容量 加强系统可用 因为模块化，所以系统模块重用度高 因为软件服务模块被拆分，开发和发布速度可以并行变得更块 系统拓展性更高 团队协作流程也会得到改善 技术升级  分布式和单体结构的对比     传统单体结构 分布式架构     新人的学习成本 业务逻辑成本高 架构逻辑成本高   部署、运维 容易 发布频繁，发布顺序复杂、运维难   隔离性 一损俱损，殃及鱼塘 故障影响范围小   架构设计 难度低 难度指数级上升   系统性能 响应快、吞吐量小 响应慢、吞吐量大   测试成本 低 很高   技术多样性 技术单一且封闭 技术多样且开放   系统扩展性 扩展性差 扩展性很好   系统管理成本 成本低 成本高    CAP定理   CAP理论：三者不可兼得","title":"分布式"},{"content":"ThreadLocal详解 使用场景：   每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）\n 每个Thread内有自己的实例副本，不共享 比喻：教材只有一本，一起做笔记有线程安全问题。复印后没有问题，ThreadLocal相当于生成了一个副本  重写initialValue方法\npackage treadlocal; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @Description: 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 * @Author: Rex * @Create: 2021-06-09 14:43 */ public class ThreadLocalNormalUsage05 { public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws InterruptedException { for (int i = 0; i \u0026lt; 1000; i++) { int finalI = i; executor.submit(new Thread(new Runnable() { @Override public void run() { String date = new ThreadLocalNormalUsage05().date(finalI); System.out.println(Thread.currentThread().getName ()+\u0026#34;:\u0026#34;+date); } })); } executor.shutdown(); } public String date(int seconds){ // 参数的单位是毫秒，从1970.1.1 00:00:00 GMT+计时  Date date = new Date(1000 * seconds); SimpleDateFormat sdf = ThreadSafeFormatter.threadLocal.get(); return sdf.format(date); } } class ThreadSafeFormatter { public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; dateFormatThreadLocal = new ThreadLocal\u0026lt;SimpleDateFormat\u0026gt;(){ @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;); } }; public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; threadLocal = ThreadLocal.withInitial(()-\u0026gt;new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;)); }   每个线程内需要保存全局变量（例如获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦\n手动调用set方法\npackage treadlocal; /** * @Description: 演示ThreadLocal用法2：避免传递参数的麻烦 * @Author: Rex * @Create: 2021-06-09 19:49 */ public class ThreadLocalNormalUsage06 { public static void main(String[] args) { new Service1().process(); } } class UserContextHolder{ public static ThreadLocal\u0026lt;User\u0026gt; holder = new ThreadLocal\u0026lt;\u0026gt;(); } class Service1 { public void process(){ User user = new User(\u0026#34;超哥\u0026#34;); UserContextHolder.holder.set(user); new Service2().process(); } } class Service2 { public void process(){ User user = UserContextHolder.holder.get(); System.out.println(\u0026#34;service2拿到用户名：\u0026#34; + user.name); new Service3().process(); } } class Service3 { public void process(){ User user = UserContextHolder.holder.get(); System.out.println(\u0026#34;service3拿到用户名：\u0026#34; + user.name); } } class User { String name; public User(String name) { this.name = name; } } /** 结果： service2拿到用户名：超哥 service3拿到用户名：超哥 */   ThreadLocal的两大作用  让某个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象) 在任何方法中都可以轻松获取到该对象  initialValue  在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制  set  如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息 用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用  ThreadLocal的好处：   达到线程安全\n  不需要加锁，提高执行效率\n  更高效地利用内存、节省开销\n 相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销    免去传参的繁琐\n  不需要每次都传同样的参数\n  ThreadLocal使得代码耦合度低，更优雅\n    主要方法：  T initialValue(): 初始化  该方法会返回当前线程对应的\u0026quot;初始值\u0026quot;，这是一个延迟加载的方法，只有在调用get的时候，才会触发 当线程第一次使用get方法访问变量，将调用此方法 每个线程最多调用一次此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法 如果不重写此方法，这个方法会放回null。一般使用匿名内部类的方法来重写initialValue()方法   void set(T t)：为这个线程设置一个新值 T get()：得到这个线程对应的value。如果是首次调用get()，则会调用initialize来得到这个值 void remove()：删除对应这个线程的值  源码分析 get方法:\nset方法：\n  get方法是先取出当前线程的ThreadLocal\n  然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入\n  取出map中属于ThreadLocal的value\n注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal\n  initialValue方法\n 没有默认实现 如果要用initialValue()方法，需要自己实现 通常使用匿名内部类的方式实现  remove方法\nThreadLocalMap\n  ThreadLocalMap 类， 也就是Thread.threadLocals\n  ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个map，键值对：\n 键：这个ThreadLocal 值：实际需要的成员变量，比如user或者simpleDateFormat对象    冲突：\n  HashMap\n  ThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是链表拉链\n    使用注意点  内存泄露（OOM）  什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收 key的泄露：ThreadLocalMap中的Entry继承自WeakReference，是弱引用 value的泄露  ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用 正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收机制回收，因为没有任何强引用了 但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链：Thread -\u0026gt; ThreadLocalMap -\u0026gt; Entry(key为null) -\u0026gt; value 因为value和Thread还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM 扫描key为null的Entry，并把对应的value设置为null 如果一个ThreadLocal不被使用，就可能导致value的内存泄露   如何避免（阿里规约）：  调用remove方法，就会删除对应的Entry对象，可以避免内存泄露，所以使用完ThreadLocal之后，应该调用remove方法     空指针异常(NPE)  包装类不能用基本数据类型去接受    ","permalink":"https://rex0520.github.io/posts/back/threadpool/threadlocal%E8%AF%A6%E8%A7%A3/","summary":"ThreadLocal详解 使用场景：   每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）\n 每个Thread内有自己的实例副本，不共享 比喻：教材只有一本，一起做笔记有线程安全问题。复印后没有问题，ThreadLocal相当于生成了一个副本  重写initialValue方法\npackage treadlocal; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @Description: 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 * @Author: Rex * @Create: 2021-06-09 14:43 */ public class ThreadLocalNormalUsage05 { public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws InterruptedException { for (int i = 0; i \u0026lt; 1000; i++) { int finalI = i; executor.submit(new Thread(new Runnable() { @Override public void run() { String date = new ThreadLocalNormalUsage05().","title":"Threadlocal详解"},{"content":"关于ReentrantLock和Condition ReentrantLock是Java中一种常见的“锁”，锁是什么？  并发编程的时候，比如说有一个业务是读写操作，那多个线程执行这个业务就会造成已经写入的数据又写一遍，就会造成数据错乱。\n所以需要引入锁，进行数据同步，强制使得该业务执行的时候只有一个线程在执行，从而保证不会插入多条重复数据。\n一些共享资源也是需要加锁，从而保证数据的一致性。\n 使用Condition实现线程等待和唤醒  通常在开发并发程序的时候，会碰到需要停止正在执行业务A，来执行另一个业务B，当业务B执行完成后业务A继续执行。ReentrantLock通过Condtion等待/唤醒这样的机制。\n ","permalink":"https://rex0520.github.io/posts/back/threadpool/%E5%85%B3%E4%BA%8Ereentrantlock%E5%92%8Ccondition/","summary":"关于ReentrantLock和Condition ReentrantLock是Java中一种常见的“锁”，锁是什么？  并发编程的时候，比如说有一个业务是读写操作，那多个线程执行这个业务就会造成已经写入的数据又写一遍，就会造成数据错乱。\n所以需要引入锁，进行数据同步，强制使得该业务执行的时候只有一个线程在执行，从而保证不会插入多条重复数据。\n一些共享资源也是需要加锁，从而保证数据的一致性。\n 使用Condition实现线程等待和唤醒  通常在开发并发程序的时候，会碰到需要停止正在执行业务A，来执行另一个业务B，当业务B执行完成后业务A继续执行。ReentrantLock通过Condtion等待/唤醒这样的机制。\n ","title":"关于reentrantlock和condition"},{"content":"守护线程 两类线程：  User Thread 用户线程 Daemon Thread 守护线程   分类标准是线程是否会阻止JVM的停止，只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部继续工作；只有当最后一个非守护线程结束时，所有守护线程才会随着JVM一同结束工作。（非守护线程等同于用户线程）\n JVM停止的情况  已调用System.exit()方法 所有非守护程序线程都已结束   而一般情况下我们不会调用System.exit()方法，所以大部分的Java程序的结束都是由于所有用户线程都结束而导致的。\n所以可以认为，任何一个守护线程都是整个JVM中所有用户线程（非守护线程）的管家。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它是一个很称职的守护者。\n 守护线程的特性  线程类型默认继承自父线程 守护线程创建的线程为默认是守护线程，同样，用户线程创建的线程默认为用户线程。非守护线程如果想创建一个守护线程，需要调用Thread.setDaemon来设置它（Thread类用布尔值daemon属性来表示线程是否是守护线程），并且，该方法必须在start之前调用，否则会抛出 IllegalThreadStateException 异常。  被谁启动  通常由JVM启动，而不是由用户去启动。当JVM启动时，通常会有一个非守护线程（通常为执行main函数的线程）。\n 不影响JVM退出  当只剩下守护线程时，JVM就会退出，因为如果只剩下守护线程，就没必要继续运行程序了。\n守护线程没结束并不会影响JVM的正常停止:假设所有用户线程都结束了，那么就算有5个守护线程正在运行，JVM也会正常停止：\n 守护线程和普通线程的区别  虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护者”，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 这就是守护线程的作用：告诉JVM不需要等待它退出,当JVM中所有的线程都是守护线程的时候，JVM就可以正常的退出了。  我们是否需要给线程设置为守护线程？  我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。\n ","permalink":"https://rex0520.github.io/posts/back/threadpool/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/","summary":"守护线程 两类线程：  User Thread 用户线程 Daemon Thread 守护线程   分类标准是线程是否会阻止JVM的停止，只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部继续工作；只有当最后一个非守护线程结束时，所有守护线程才会随着JVM一同结束工作。（非守护线程等同于用户线程）\n JVM停止的情况  已调用System.exit()方法 所有非守护程序线程都已结束   而一般情况下我们不会调用System.exit()方法，所以大部分的Java程序的结束都是由于所有用户线程都结束而导致的。\n所以可以认为，任何一个守护线程都是整个JVM中所有用户线程（非守护线程）的管家。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它是一个很称职的守护者。\n 守护线程的特性  线程类型默认继承自父线程 守护线程创建的线程为默认是守护线程，同样，用户线程创建的线程默认为用户线程。非守护线程如果想创建一个守护线程，需要调用Thread.setDaemon来设置它（Thread类用布尔值daemon属性来表示线程是否是守护线程），并且，该方法必须在start之前调用，否则会抛出 IllegalThreadStateException 异常。  被谁启动  通常由JVM启动，而不是由用户去启动。当JVM启动时，通常会有一个非守护线程（通常为执行main函数的线程）。\n 不影响JVM退出  当只剩下守护线程时，JVM就会退出，因为如果只剩下守护线程，就没必要继续运行程序了。\n守护线程没结束并不会影响JVM的正常停止:假设所有用户线程都结束了，那么就算有5个守护线程正在运行，JVM也会正常停止：\n 守护线程和普通线程的区别  虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护者”，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 这就是守护线程的作用：告诉JVM不需要等待它退出,当JVM中所有的线程都是守护线程的时候，JVM就可以正常的退出了。  我们是否需要给线程设置为守护线程？  我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。\n ","title":"守护线程"},{"content":"线程池 线程池介绍 软件中的池可以理解为计划经济\n优点：\n 复用线程 控制资源总量  好处：\n 加快响应速度 合理利用CPU和内存 统一管理  适用场合\n 服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理  创建和停止线程池 线程池构造方法的参数    参数名 类型 含义     corePoolSize int 核心线程数   maxPoolSize int 最大线程数   keepAliveTime long 保持存活时间   workQueue BlockingQueue 任务存储队列   threadFactory ThreadFactory 当线程池需要新的线程的时候，会使用threadFactory来生成新的线程   Handler RejectedExecutionHandler 由于线程池无法接受你所提交的任务的拒绝策略    添加线程规则  如果线程数小于corePoolSize，创建一个新线程来运行新任务。 如果线程数等于（或大于）corePoolSize但少于maxmumPoolSize，则将任务放入队列。 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程。 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝。  是否需要增加线程的判断顺序是：\n corePoolSize workQueue maxPoolSize  增减线程的特点  通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它  举例：\n 线程池：核心池大小为5，最大池大小为10，队列为100 因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建最新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝  keepAliveTime\n 如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，他们就会被终止  ThreadFactory\n 默认使用Executors.defaultThreadFactory() 创建出来的都在同一个线程组 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。  工作队列\n  有3种最常见的队列类型：\n  直接交接：SynchronousQueue\n适用于任务不多的情况，只作为中转\n内部没有容量，maxPoolSize需要设置的大一点\n  无界队列：LinkedBlockingQueue\n可以防止浏览突增\n但是如果处理的速度跟不上任务提交的速度，队列里的东西会越来越多造成内存浪费或OOM(Out of Memory)异常\n不会被塞满，maxPoolSize无效\n  有界队列：ArrayBlockingQueue\n可以设置maxPoolSize，控制队列容量\n    自动创建（即直接调用JDK封装好的构造方法）VS自动创建  手动创建线程可以更加明确线程池的运行规则，避免资源耗尽的风险  自动创建：\n  newFixedThreadPool\n因为默认使用的是LinkedBlockingQueue，容易造成大量内存占用，可能会导致OOM错误\n  newSingleThreadExecutor\n当请求堆积的时候，可能会占用大量的内存\n  newCachedThreadPool\n 可缓存线程池 特点：具有自动回收多余线程的功能 弊端在于第二个参数maxmumPoolSize被设置为了Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM    newScheduledThreadPool\n 支持定时及周期性执行任务    workStealingPool(jdk1.8)\n 适合于有子任务的，如树的遍历 窃取(stealing)    正确的创建线程池的方法\n 根据业务场景，设置线程池参数 比如：内存有多大，给线程取什么名字等等  线程数量的设置：\n  CPU密集型（大量加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。\n  耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍（如10倍）\n参考Brain Geoetz推荐的计算方法：\n线程数 = CPU核心数 × (1 + 平均等待时间/平均工作时间)\nor压测\n     Parameter FIXEDTHREADPOOL CACHEDTHREADPOLL sCHEDULEDtHREADPOOL SINGLETHREADED     corePoolSize constructor-arg 0 constructor-arg 1   maxPoolSize same as corePoolSize Integer.MAX_VALUE Integer.MAX_VALUE 1   keepAliveTime 0 seconds 60 seconds 0 seconds 0 seconds    停止线程池的正确做法  shutdown：初始化整个关闭过程，并不会马上关闭 isShutdown：判断是否进入停止状态 isTerminated：判断线程是否已经终止 awaitTermination：判断在一段时间内线程是否完全停止 shutdownNow：暴力关闭  暂停和恢复线程池 拒绝任务   拒绝时机\n 当Executor关闭时，提交新任务会被拒绝 以及当Executor对最大线程和工作队列容量使用有限边界且 已经饱和时    拒绝策略\n  AbortPolicy\n抛出异常\n  DiscardPolicy（Discard丢弃）\n默默丢弃任务，不知道任务是否被丢弃\n  DiscardOledestPolicy\n丢弃最老的任务\n  CallerRunsPolicy\n让调用者去执行任务\n    钩子方法-给线程池加点料\n  每个任务执行前后\n  日志、统计\n  示例代码：\npackage threadpool; import java.util.concurrent.*; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; /** * @Description: 描述每个任务执行前后放钩子函数 * @Author: Rex * @Create: 2021-06-08 14:22 */ public class PauseableThreadLocal extends ThreadPoolExecutor { private final ReentrantLock lock = new ReentrantLock(); private boolean isPaused; private Condition unpause = lock.newCondition(); public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); } public PauseableThreadLocal(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); lock.lock(); try{ while(isPaused) { unpause.await(); } }catch (InterruptedException e){ e.printStackTrace(); }finally { lock.unlock(); } } private void pause(){ lock.lock(); try { isPaused = true; } finally { lock.unlock(); } } public void resume(){ lock.lock(); try { isPaused = false; unpause.signalAll(); } finally { lock.unlock(); } } public static void main(String[] args) throws InterruptedException { PauseableThreadLocal pauseableThreadLocal = new PauseableThreadLocal(10, 20, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue\u0026lt;\u0026gt;()); for (int i = 0; i \u0026lt; 10000; i++) { pauseableThreadLocal.execute(() -\u0026gt; { System.out.println(\u0026#34;我被执行\u0026#34;); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } }); } Thread.sleep(1500); pauseableThreadLocal.pause(); System.out.println(\u0026#34;线程池被暂停了\u0026#34;); Thread.sleep(1500); pauseableThreadLocal.resume(); System.out.println(\u0026#34;线程池被恢复了\u0026#34;); } }     线程池实现原理   线程池组成部分\n 线程池管理器 工作线程 任务队列 任务接口（Task）  Executor -\u0026gt; ExecutorService -\u0026gt; AbstractExecutorService -\u0026gt; ThreadPoolExecutor\n  线程池实现任务复用\n 相同线程执行不同任务    线程池状态    状态 含义     Running 接受新任务并处理排队任务   Shutdown 不接受新任务，但处理排队任务   Stop 不接受新任务，也不处理排队任务，并中断正在进行的任务   Tydying 所有任务都已终止，workCount为零时，线程会转换到Tidying状态，并将运行terminal()钩子方法   Terminated terminal()运行完成    使用线程池的注意点  避免任务堆积 避免线程数过渡增加 排查线程泄露  ","permalink":"https://rex0520.github.io/posts/back/threadpool/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","summary":"线程池 线程池介绍 软件中的池可以理解为计划经济\n优点：\n 复用线程 控制资源总量  好处：\n 加快响应速度 合理利用CPU和内存 统一管理  适用场合\n 服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理  创建和停止线程池 线程池构造方法的参数    参数名 类型 含义     corePoolSize int 核心线程数   maxPoolSize int 最大线程数   keepAliveTime long 保持存活时间   workQueue BlockingQueue 任务存储队列   threadFactory ThreadFactory 当线程池需要新的线程的时候，会使用threadFactory来生成新的线程   Handler RejectedExecutionHandler 由于线程池无法接受你所提交的任务的拒绝策略    添加线程规则  如果线程数小于corePoolSize，创建一个新线程来运行新任务。 如果线程数等于（或大于）corePoolSize但少于maxmumPoolSize，则将任务放入队列。 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程。 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝。  是否需要增加线程的判断顺序是：","title":"线程池"},{"content":"CSS CSS简介  层叠样式表(Cascading Style Sheets)的简称 美化HTML、布局网页 结构（HTML）-样式（CSS）分离  语法规范： ​\t选择器{属性:值}\nh1{color: red;} 语法风格   紧凑格式\nh3 {color:red}   展开格式(强推)\nh3 { color: pink; font-size:20px; }   选择器： CSS引入方式  内部样式表 行内样式表 外部样式表  CSS常用选择器 基础选择器  标签选择器 类选择器 id选择器 通配符选择器  复合选择器   后代选择器\n元素1 元素2 { 样式声明 }\n  子选择器：只能选择作为某元素的最近一级 元素，\n元素1\u0026gt;元素2 { 样式声明 }\n  并集选择器\n元素1,元素2 { 样式声明 }\n  伪类选择器\n  链接伪类选择器：必须按照lvha的顺序\n  a:link /*选择所有未被访问的链接*/   a:visited /*选择所有已被访问的链接*/   a:hover /*选择鼠标指针位于其上的链接*/   a:active /*选择活动链接*/     focus伪类选择器用于获取焦点的表单元素。\ninput:focus{ background-color: yellow; }     CSS三大特性：   层叠性\n解决样式冲突问题\n样式冲突时遵循就近原则，哪个结构近，就执行哪个样式\n  继承性\n子标签继承父标签的某些样式\n  优先级\n   选择器 选择器权重     继承或者* 0,0,0,0   元素选择器 0,0,0,1   类选择器，伪类选择器 0,0,1,0   ID选择器 0,1,0,0   行内样式style=\u0026quot;\u0026quot; 1,0,0,0   !important 重要的 ∞ 无穷大    选择性相同，则执行层叠性\n选择性不同，则根据选择器权重执行\n  tip:复合选择器存在权重叠加的问题\nCSS显示模式： 分类   块级元素（div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等）\n 独占一行 高度、宽度、外边距以及内边距都可以控制 宽度默认是容器的100% 是一个容器及盒子，里面可以放行内元素或者块级元素  注意：\n 文字类的元素内不能使用块级元素 \u0026lt;p\u0026gt;标签主要用于存放文字，因此\u0026lt;p\u0026gt;不能放块级元素，特别是不能放\u0026lt;div\u0026gt; 同理\u0026lt;h1\u0026gt;~\u0026lt;h6\u0026gt;等都是文字类块级标签，里面也不能放其他块级元素    行内元素（span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block））\n 相邻行内元素在一行上，一行可以显示多个 高、宽直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素  注意：\n 链接里面不能再放链接 特殊情况链接\u0026lt;a\u0026gt;里面可以放块级元素，但是给\u0026lt;a\u0026gt;转换以下块级模式最安全    行内块元素（button、img、input、select、textarea、td）\n 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点） 默认宽度就是它本身内容的宽度（行内元素特点） 高度，行高，外边距以及内边距都可以控制（块级元素特点）    转换：  转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块元素：display:inline-block  CSS的背景：   background-color:颜色值;\n设置背景颜色，默认为transparent(透明)\n  background-image:none|url\n设置背景图片，默认为none\n  background-repeat: repeat | no-repeat | repeat-x | repeat-y\n背景平铺，默认为repeat\n  background-position:[length]or[position]\nposition:top | center | bottom | left | center | right\n背景图片的位置\n  background-attachment:scroll | fixed\n背景图像固定(背景附着)\n  背景复合写法\nbackground:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置（习惯约定）\n注意：rgba是CSS3新增属性，是IE9+版本浏览器才支持的\n  盒子模型（Box Model）： 组成   border边框\n 边框粗细 border-width 边框样式 border-style 边框颜色 border-color  border: border-width || border-style || border-color\nborder-collapse属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。\n  content内容\n  padding内边距\n边框与内容之间的距离\n   值的个数 表达意思     padding: 5px; 1个值，代表上下左右都有5像素内边距;   padding: 5px 10px; 2个值，代表上下内边距是5像素，左右内边距是10像素;   padding: 5px 10px 20px 3个值，代表上内边距5像素，左右内边距10像素 下内边距是20px;   padding: 5px 10px 20px 30px; 4个值，上5像素 右10像素 下20像素 左30像素      margin外边距\n控制盒子和盒子之间的\t距离\nmargin简写类似padding\n外边距典型应用-块级盒子水平居中 ，条件\n 盒子必须指定宽度 盒子左右的外边距都设置为auto  tip:\n  相邻元素垂直外边距的合并\n尽量只给一个盒子设置外边距\n  嵌套块元素垂直外边距的塌陷\n 为父元素定义上边框 为父元素定义内边距 为父元素添加overflow:hidden    行内元素为了照顾兼容性，尽量只设置内外边距，不要设置上下内外边距。但是转换为块级和行内元素就可以了\n  浮动的盒子不会有外边距合并问题\n    三种布局方式 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级横向排列找浮动\n网页布局第二准则：先设置盒子大小，之后设置盒子的位置\n普通流（普通流/文档流） ​\t标签按照规定好默认方式排列\n  块级元素独占一行，从上向下排列\n  行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行\n  浮动 ​\t典型应用：可以让多个块级元素一行内排列显示。\n​\n   属性值 描述     none 元素不浮动   left 元素向左浮动   right 元素向右浮动    浮动特性  脱标  脱离标准普通流的控制（浮）移动到指定位置（动）（脱标） 浮动的盒子不再保留原先的位置   如果多个盒子都设置了浮动，则它们会按照属性值一行显示并且顶端对齐排列 浮动元素具有行内块元素特性  注意点 浮动元素经常和标准流父级搭配使用 ​\t先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置.符合网页布局第一准则\n清除浮动 ​\t由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占位置，最后父级盒子高度为0时，会影响下面的标准流盒子。\n选择器{ clear:both } 清除浮动的策略是闭合浮动\n清除浮动的方法\n  额外标签法也成为隔墙法，是W3C推荐的做法。\n优点：通俗易懂，书写方便\n缺点：添加许多无意义的标签，结构化较差\ntips：添加的元素必须是块级元素\n  父级添加overflow属性\n优点：代码简洁\n缺点：无法显示溢出的部分\n  父级添加after伪元素(比较常用)\n.clearfix::after { content: \u0026#34;\u0026#34;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7专有 */ *zoom: 1; } 优点：没有增加标签，结构更简单\n缺点：照顾低版本浏览器\n代表网站：百度、淘宝、网易等\n  父级添加双伪元素\n.clearfix::after, .clearfix::before { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { clear: both; } .clearfix { /* IE6、7专有 */ *zoom: 1; } 优点：代码简洁\n缺点：照顾低版本浏览器\n代表网站：小米、腾讯等\n  定位：  将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\n定位 = 定位模式 + 边偏移\n 定位模式    值 语义     static 静态定位   relative 相对定位   absulte 绝对定位   fixed 固定定位    static：默认定位方式，无定位\n 静态定位按照标准流特性摆放位置，它没有边偏移 静态定位在布局时很少用到  relative：相对定位是元素在移动的时候，是相对于它原来的位置来说的\n 它是相当于自己原来的位置来移动的 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱标）  absolute：绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的(拼爹型)\n 如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准单位（Document文档） 如果祖先元素有定位（相对、绝对、固定定位），则以最近一级有定位祖先元素为参考点移动位置 绝对定位不再占有原来的位置（脱标）  fixed：固定定位是元素固定于浏览器可视区的位置。可以在浏览器页面滚动时元素的位置不会改变\n 以浏览器可视窗口为参照点移动元素  跟父元素无关 不随滚动条滚动   固定定位不在占有原先的位置  固定定位也是脱标的，其实固定定位也可以看作是一种特殊的绝对定位    sticky：粘性定位可以被认为是相对定位和固定定位的混合。IE不支持\n 以浏览器的可视窗口为参照点移动元素（固定定位） 粘性定位占有原先的位置 必须添加top、left、right、bottom其中一个才有效  定位特殊特性：  行内添加绝对或者固定定位，可以直接设置高度和宽度。 浮动不会压住盒子的内容（浮动产生的目的最初就是为了做文字环绕效果的），而绝对定位会完全压住盒子  边偏移： ​\ttop、bottom、right、left\n定位叠放次序：z-index  数值可以是正整数、负整数或0，默认是auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性  常见应用：  子绝父相：子级是绝对定位，父级是相对定位 固定定位技巧：固定在版心右侧位置：  让固定定位的盒子left:50%。走到浏览器可视区的一半位置。 让固定定位的盒子margin-left: 版心宽度的一半距离。多走版心宽度的一半位置   绝对定位的盒子居中（无法用margin:0 auto）  left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。 margin-left: -100px; 让盒子向左移动宽度的一半    常见样式： 字体属性： font-family:\u0026#34;宋体\u0026#34;;/*常见的字体\u0026#39;Microsoft YaHei\u0026#39;,tahoma,arial,\u0026#39;Hiragino Sans GB\u0026#39;*/ font-size:20px;/*定义字体大小，标题标签需要单独设置*/ font-weight:700;/*不需要单位，提倡使用数字*/ font-style:normal/*文本风格,平时很少给文字加斜体，反而要给斜体改为不倾斜 font:font-style font-weight font-size/line-height font family/*字体复合属性*/ 文本属性： color: red;/*文本颜色：预定义的颜色值;进制表示;rgb和rgba*/ text-align:center;/*用于元素内文本内容的水平对其方式:left、right、center*/ text-decoration: underline;/*装饰文本：none、underline、overline、line-through*/ text-indent: ;/*指定文本的第一行的缩进，通常是将段落首行缩进, 一般用em，em是一个相对单位，就是当前元素1格文字的大小*/ line-height:;/*行间距*/ 圆角边框(CSS3) border-radius:length; /*设置元素外边框圆角。 radius-\u0026gt;半径原理：（椭）圆与边框的交集形成圆角效果。参数值可以是百分比，即宽的百分比和高的百分比*/ border-radisu:10px 20px 30px 40px; /*给四个角设置不同的圆角，顺时针*/ border-top-left-radius:10px /*给单独一个角设置圆角：border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius*/ 元素的显示与隐藏：   display 显示隐藏\ndisplay隐藏元素后，不再占有原来的位置，常搭配js\n  visibility 显示隐藏\nvisibility隐藏元素后，继续占有原来的位置\n  overflow 溢出隐藏\n如果有定位的盒子，请慎用overflow:hidden 因为它会隐藏多余的部分\n  盒子阴影(CSS3)    值 描述     h-shadow 必须。水平阴影的位置。允许负值。   v-shadow 必须。垂直阴影的位置。允许负值。   blur 可选。模糊距离。   spread 可选。阴影的尺寸。   color 可选。阴影的颜色。   inset 可选。将外部阴影改为内部阴影。    ​\nbox-shadow: h-shadow v-shadow blur spread color insert; /*盒子阴影*/ 文字阴影(CSS3) text-shadow:h-shadow v-shadow blur color    值 描述     h-shadow 必须。水平阴影的位置。允许负值。   v-shadow 必须。垂直阴影的位置。允许负值。   blur 可选。模糊距离。   color 可选。阴影的颜色。    CSS初始化 /* 把我们所有标签的内外边距清零 */ * { margin: 0; padding: 0; /* css3盒子模型 */ box-sizing: border-box } /* em 和 i 斜体的文字不倾斜 */ em, i { font-style: normal } /* 去掉li的小圆点 */ li { list-style: none } /* */ img { /* border 0照顾低版本浏览器 如果 图片外边包含了链接会有边框 的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle } button { /* 当鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer } a { color: #666; text-decoration: none } a:hover { color: #c81623 } button, input { /* \u0026#34;\\5B8B\\4F53\u0026#34;就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif } body { /* CSS3 抗锯齿性 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; color: #666 } .hide, .none { display: none } /* 清除浮动 */ .clearfix:after { visibility: hidden; clear: both; display: block; content: \u0026#34;.\u0026#34;; height: 0 } .clearfix { *zoom: 1 } 技巧 布局技巧 margin负值运用  让每个盒子margin往左移动-1px 正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高盒子的层级即可（如果没有定位，则加相对定位（保留位置），如果有定位，则加z-index）  文字围绕浮动元素  float属性  CSS三角的做法 等腰三角形\n.div { width: 0; height: 0; line-height: 0;/*考虑兼容性*/ font-size: 0;/*考虑兼容性*/ border: 50px solid transparent; border-top-color: pink; margin: 100px auto; } 三角强化-直角三角形\n.box1 { width: 0; height: 0; border-top: 100px solid transparent; border-right: 50px solid skyblue; border-bottom: 0 solid blue; border-left: 0 solid green; } .box1{ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2.样式都是solid */ border-style: solid; /* 3.上边框宽度要大，右边框稍小，其余的边框为0 */ border-width: 100px 50px 0 0; } 界面样式：   更改用户的鼠标样式\ncursor: pointer\n   属性值 描述     default 小白 默认   pointer 小手   move 移动   text 文本   not-allowed 禁止      表单轮廓和文本域拖拽\noutline: none 取消轮廓线\nresize: none （文本域）防止拖拽文本域\n  精灵图(sprites)技术： 优点：  为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度  缺点：  图片文件还是比较大的。 图片本身放大缩小会失真 一旦图片制作完毕想要更换比较复杂  使用核心：  精灵图主要针对于背景图片使用。就是把多个小图片整合到一张大图片中 这个大图片也称为sprites精灵图或者雪碧图 主要借助于背景位置来实现\u0026mdash;background-position. 一般情况下精灵图都是负值。（千万注意网页中的坐标：x轴右边走是正值，左边是负值，y轴同理）  字体图标 优点：  轻量级：一个图标字体要比一系列的图像要小，一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用  注意：字体图片不能代替精灵技术，只是对工作中图标部分技术的提升和优化。\n常用字体库：  icomoon：http://icomoon.io 阿里iconfont： http://www.iconfont.cn  vertical-align属性应用 ​\t用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效\nvertical: baseline | top | middle | bottom 解决图片底部默认空白缝隙问题  给图片添加vertical-align: middle|top|bottom等(提倡) 把图片转换为块级元素 display: block  溢出文本省略号表示   单行文本\ndiv { width: 150px; height: 80px; background-color: pink; margin: 100px auto; /* 如果文字显示不开自动换行 */ /* white-space: normal; */ /* 如果文字显示不开也必须一行内显示完 */ white-space: nowrap; /* 溢出的部分隐藏起来 */ overflow: hidden; /* 文字溢出的时候用省略号来显示 */ text-overflow: ellipsis; }   多行文本\n有较大兼容性问题，适合于webkit浏览器或移动端（移动端内核大部分是webkit）\ndiv { width: 150px; height: 80px; background-color: pink; margin: 100px auto; overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 4; /* 设置或间所伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical; }   ","permalink":"https://rex0520.github.io/posts/front/css/","summary":"CSS CSS简介  层叠样式表(Cascading Style Sheets)的简称 美化HTML、布局网页 结构（HTML）-样式（CSS）分离  语法规范： ​\t选择器{属性:值}\nh1{color: red;} 语法风格   紧凑格式\nh3 {color:red}   展开格式(强推)\nh3 { color: pink; font-size:20px; }   选择器： CSS引入方式  内部样式表 行内样式表 外部样式表  CSS常用选择器 基础选择器  标签选择器 类选择器 id选择器 通配符选择器  复合选择器   后代选择器\n元素1 元素2 { 样式声明 }\n  子选择器：只能选择作为某元素的最近一级 元素，\n元素1\u0026gt;元素2 { 样式声明 }\n  并集选择器\n元素1,元素2 { 样式声明 }","title":"CSS"},{"content":"网页开发 浏览器内核    浏览器 内核 备注     IE Trident IE、猎豹、360极速浏览器、百度浏览器   firefox Gecko 火狐浏览器内核   Safari Webkit 苹果浏览器内核   Chrome/Opera Blink Chrome/Opera浏览器内核。Blink其实是Webkit的分支    Web标准 目的： ​\t浏览器不同，他们显示页面或者排版不同\n构成：  结构 - HTML 表现 - CSS 行为 - JavaScript  SEO优化 TDK三大标签   title\ntitle是搜索引擎了解网页入口和网页主题归属的最佳判断点\n建议：网站名（产品名）-网站的介绍（尽量不超过30个汉字）\n  description\n简要说明我们网站主要是做什么的。\n我们提倡，description作为网站的总体业务和主题概况\n  keyword\nkeywords是页面关键字，是搜索引擎的关注点之一。\nkeywords最好限制为6~8个关键字，关键字之间用英文逗号隔开，采用关键词1，关键词2的形式\n  LOGO SEO优化  logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要 h1里面再放一个链接，可以返回首页的，把logo的背景图片给链接即可。 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来  方法1：text-index移到盒子外面（text-indent:-9999px），然后overflow:hidden，淘宝的做法 方法2：直接给font-size:0;就看不到文字了，京东的做法。   最后给链接一个title属性，这样鼠标放到logo上就可以看到提示文字了  HTML标签 声明部分 文档类型声明标签 ​\t\u0026lt;!DOCTYPE\u0026gt;文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页\n\u0026lt;!DOCTYPE html\u0026gt;指当前页面采用HTML5版本来显示网页\nlang语言种类  en定义语言为中文 zh-CN定义语言为中文  这个对于网页的编码没有什么影响，主要针对浏览器和搜索引擎\n字符集 ​\t\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;在\u0026lt;head\u0026gt;标签内，用于指定HTML文档的编码方式\ncharset常用的值有：GB2312，BIG5，GBK和UTF-8，其中UTF-8为万国码，包含了各个国家的字符\n图标： \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;./images/favicon.ico\u0026#34;\u0026gt; 常用标签 标题标签：\u0026lt;h1\u0026gt; - \u0026lt;h6\u0026gt;  h -\u0026gt; head的缩写 作为标题使用，并且依据重要性递减  段落：\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;   p -\u0026gt; paragraph\n  可以把HTML文档分割为若干段落\n  特点\n 文本在一个段落中会根据浏览器窗口的大小自动换行 段落和段落之间保有空隙。    换行标签：\u0026lt;br /\u0026gt;  br -\u0026gt; break 强制换行 特点  单标签。 \u0026lt;br /\u0026gt;标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距    文本格式化标签    语义 标签 说明     加粗 或者 更推荐使用标签加粗 语义更强烈   倾斜 或者 更推荐使用标签加粗 语义更强烈   删除线 或者 更推荐使用标签加粗 语义更强烈   下划线 或者 更推荐使用标签加粗 语义更强烈    div和span标签：\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;、\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;  div -\u0026gt; division 分割、分区；span 跨度、跨距 特点：  \u0026lt;div\u0026gt;标签用来布局，但是现在一行只能放一个\u0026lt;div\u0026gt;。大盒子 \u0026lt;span\u0026gt;标签用来布局，一行可以多个\u0026lt;span\u0026gt;。小盒子    图像标签：\u0026lt;img src=\u0026quot;图像URL\u0026quot;\u0026gt;   img -\u0026gt; image 图像\n  图像标签属性\n   属性 属性值 说明     src 图片路径 必须属性   alt 文本 替换文本。图像不能显示的文字   title 文本 提示文本。鼠标放到图像上，显示的文字   width 像素 设置图像的宽度   height 像素 设置图像的高度   border 像素 设置图像的边框粗细      超链接标签/锚点链接：\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;   a -\u0026gt; anchor 锚\n  属性\n   属性 作用     href 用于指定连接目标的url地址，为href属性时，他就具有了超链接的功能   target 用于指定链接页面的打开方式，其中_self为默认值，__blank为在新窗口中打开      注释和特殊字符 注释标签：\u0026lt;!-- --\u0026gt; 特殊字符    特殊字符 描述 字符的代码      空格符 \u0026amp;nbsp;   \u0026lt; 小于号 \u0026amp;lt;   \u0026gt; 大于号 \u0026amp;gt;   \u0026amp; 和号 \u0026amp;amp;   ￥ 人民币 \u0026amp;yen;   © 版权 \u0026amp;copy;   ® 注册商标 \u0026amp;reg;   ° 摄氏度 \u0026amp;deg;   ± 正负号 \u0026amp;plusmn;   × 乘号 \u0026amp;times;   ÷ 除号 \u0026amp;divide;   ² 平方2(上标2) \u0026amp;sup2;   ³ 立方3(上标3) \u0026amp;sup3;    表格标签   \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;用于定义表格的标签\n  \u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;用于定义表格中的行，必须嵌套在\u0026lt;table\u0026gt;\u0026lt;table\u0026gt;标签中.\ntable row\n  \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;用于定义表格中的单元格，必须嵌套在\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;标签中.\n字母td指表格(table data)，即数据单元格的内容。\n  \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;表头单元格\ntable head\n  表格属性    属性名 属性值 描述     align left、center、right 规定表格相对周围元素的对齐方式   border 1或\u0026quot;\u0026quot; 规定表格单元格是否拥有边框，默认为\u0026quot;\u0026quot;，表示没有边框   cellpadding 像素值 规定单元边沿与其内容之间的空白，默认像素为1   cellspacing 像素值 规定单元格之间的空白，默认2像素   width 像素值 规定表格的宽度    表格结构标签 \u0026lt;thead\u0026gt;\u0026lt;/thead\u0026gt;表格的头部区域\n\u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt;表格的主体区域\n合并单元格  跨行合并：rowspan=\u0026ldquo;合并单元格的个数\u0026rdquo; 跨列合并：colspan=\u0026ldquo;合并单元格的个数\u0026rdquo;  列表标签：用来布局  特点：整齐、整洁、有序  无序列表：\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\n有序列表：\u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\n自定义列表：\u0026lt;dl\u0026gt;\u0026lt;/dl\u0026gt;、\u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt;、\u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt;\n表单   定义表单域：\u0026lt;form\u0026gt;\n常用属性：\n   属性 属性值 作用     action url地址 用于指定接受并处理表单数据的服务器程序的url地址   method get、post\u0026hellip; 用于设置表单数据的提交方式，其取值为get或post等等   name 名称 用于指定表单的名称，以区分同一个页面的多个表单域      表单控件\n  input输入表单元素\ntype属性\n   属性值 描述     button 定义可点击按钮（多数情况下，用于通过JavaScript启动脚本）。   checkbox 定义复选框   file 定义输入字段和浏览按钮，供文件上传   hidden 定义隐藏的输入字段   image 定义图像形式的提交按钮。   password 定义密码字段。该字段中的字符被掩码。   radio 定义单选按钮。   reset 定义重置按钮。重置按钮会清除表单中的所有数据   submit 定义提交按钮。提交按钮会把表单数据发送到服务器   text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。    其他属性\n   属性 属性值 描述     name 由用户自定义 定义input元素的名称   value 由用户自定义 规定input元素的值   checked checked 规定此input元素首次加载时应当被选中。   maxlength 正整数 规定输入字段中的字符的最大长度      label标签用于绑定表单元素\n  select下拉表单元素\n  textarea文本域元素\n    表单信息\n  ","permalink":"https://rex0520.github.io/posts/front/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","summary":"网页开发 浏览器内核    浏览器 内核 备注     IE Trident IE、猎豹、360极速浏览器、百度浏览器   firefox Gecko 火狐浏览器内核   Safari Webkit 苹果浏览器内核   Chrome/Opera Blink Chrome/Opera浏览器内核。Blink其实是Webkit的分支    Web标准 目的： ​\t浏览器不同，他们显示页面或者排版不同\n构成：  结构 - HTML 表现 - CSS 行为 - JavaScript  SEO优化 TDK三大标签   title\ntitle是搜索引擎了解网页入口和网页主题归属的最佳判断点\n建议：网站名（产品名）-网站的介绍（尽量不超过30个汉字）\n  description\n简要说明我们网站主要是做什么的。\n我们提倡，description作为网站的总体业务和主题概况\n  keyword\nkeywords是页面关键字，是搜索引擎的关注点之一。\nkeywords最好限制为6~8个关键字，关键字之间用英文逗号隔开，采用关键词1，关键词2的形式\n  LOGO SEO优化  logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要 h1里面再放一个链接，可以返回首页的，把logo的背景图片给链接即可。 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来  方法1：text-index移到盒子外面（text-indent:-9999px），然后overflow:hidden，淘宝的做法 方法2：直接给font-size:0;就看不到文字了，京东的做法。   最后给链接一个title属性，这样鼠标放到logo上就可以看到提示文字了  HTML标签 声明部分 文档类型声明标签 ​\t\u0026lt;!","title":"网页开发"},{"content":"HTML5 TIP: 存在兼容性问题，基本上IE+9以上版本的浏览器才支持\n语义化标签  \u0026lt;head\u0026gt;: 头部标签 \u0026lt;nav\u0026gt;: 导航标签 \u0026lt;artivle\u0026gt;: 内容标签 \u0026lt;section\u0026gt;: 定义文档某个区域 \u0026lt;aside\u0026gt;: 侧边栏标签 \u0026lt;footer\u0026gt;: 尾部标签  注意：\n 这种语义化标准主要是针对搜索引擎的 这些新标签页面可以使用多次 在IE9中，需要把这些元素转换为块级元素 移动端更喜欢使用这些标签  多媒体标签   \u0026lt;vedio\u0026gt;\n   浏览器 MP4 Webm ogg     Internet Explore Yes No No   Chrome Yes Yes Yes   Firefox Yes从Firefox21版本开始Linux系统从Firefox30开始 Yes Yes   Safari Yes No No   Opera Yes Yes Yes    语法：\n\u0026lt;video src=\u0026quot;文件地址\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/video\u0026gt;\n属性：\n   属性 值 描述     autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。   controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。   height pixels 设置视频播放器的高度。   loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。   muted muted 规定视频的音频输出应该被静音。   poster URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。   preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 \u0026ldquo;autoplay\u0026rdquo;，则忽略该属性。   src url 要播放的视频的 URL。   width pixels 设置视频播放器的宽度。      \u0026lt;audeo\u0026gt;\n   浏览器 MP3 wav ogg     Internet Explore Yes No No   Chrome Yes Yes Yes   Firefox Yes Yes Yes   Safari Yes YES No   Opera Yes Yes Yes    语法：\n\u0026lt;audio src=\u0026quot;文件地址\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt;\n属性\n   属性 值 描述     autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。   controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。   loop loop 如果出现该属性，则每当音频结束时重新开始播放。   muted muted 规定视频输出应该被静音。   preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 \u0026ldquo;autoplay\u0026rdquo;，则忽略该属性。   src url 要播放的音频的 URL。      多媒体标签总结\n 音频和视频使用方式基本一致 浏览器支持情况不同 谷歌浏览器把音频和视频自动播放了 我们可以给视频标签添加muted属性来静音播放视频，音频不可以（可以通过JavaScript解决） 视频标签是重点，我们经常设置自动播放，不适用controls控件，循环和设置大小属性    input类型    属性值 说明     type=\u0026ldquo;email\u0026rdquo; 限制用户输入必须为Email类型   type=\u0026ldquo;url\u0026rdquo; 限制用户输入必须为URL类型   type=\u0026ldquo;date\u0026rdquo; 限制用户输入必须为日期类型   type=\u0026ldquo;time\u0026rdquo; 限制用户输入必须为时间类型   type=\u0026ldquo;month\u0026rdquo; 限制用户输入必须为月类型   type=\u0026ldquo;week\u0026rdquo; 限制用户输入必须为周类型   type=\u0026ldquo;number\u0026rdquo; 限制用户输入必须为数字类型   type=\u0026ldquo;tel\u0026rdquo; 手机号   type=\u0026ldquo;search\u0026rdquo; 搜索框   type=\u0026ldquo;color\u0026rdquo; 生成一个颜色选择表单    新增的表单属性    属性 值 说明     required required 表单拥有该属性表示其内容不能为空，必填   placeholder 提示文本 表单的提示信息，存在默认值将不显示   autofocus autofocus 自动聚焦属性，页面加载完成自动聚焦到指定表单   autocomplate off/on 当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。默认已经打开，如autocomplete=\u0026ldquo;on\u0026rdquo;, 关闭autocomplete=\u0026ldquo;off\u0026quot;需要放在表单内，同时加上name属性，同时成提交   multiple mltiple 可以多选文件提交    ","permalink":"https://rex0520.github.io/posts/front/html5/","summary":"HTML5 TIP: 存在兼容性问题，基本上IE+9以上版本的浏览器才支持\n语义化标签  \u0026lt;head\u0026gt;: 头部标签 \u0026lt;nav\u0026gt;: 导航标签 \u0026lt;artivle\u0026gt;: 内容标签 \u0026lt;section\u0026gt;: 定义文档某个区域 \u0026lt;aside\u0026gt;: 侧边栏标签 \u0026lt;footer\u0026gt;: 尾部标签  注意：\n 这种语义化标准主要是针对搜索引擎的 这些新标签页面可以使用多次 在IE9中，需要把这些元素转换为块级元素 移动端更喜欢使用这些标签  多媒体标签   \u0026lt;vedio\u0026gt;\n   浏览器 MP4 Webm ogg     Internet Explore Yes No No   Chrome Yes Yes Yes   Firefox Yes从Firefox21版本开始Linux系统从Firefox30开始 Yes Yes   Safari Yes No No   Opera Yes Yes Yes    语法：","title":"HTML5"},{"content":"Vue进阶 Vue路由 1.初始路由 **路由**：表示一种对应关系，某些事物的一一对应的关系 **后端路由**：后端路由是由服务器端进行实现，并完成资源的分发（url与资源/数据的对应关系） **前端路由**：前端路由是依靠hash值（锚点链接）的变化进行实现页面内容的切换（锚点与组件之间的关系）  2.vue-router   vue-router工作原理\n  它是一个Vue.js官方提供的路由管理器，是一个功能更加强大的前端路由器，可以实现前端界面内容切换\n  SPA：Single Page Application，单页面应用，整个网站只有一个页面\n  SPA推荐使用vue-router，实现界面内容的切换\n  vue-router提供两种模式\n  hash模式：hash又叫锚点：比如#/login，根据hash改变，来实现界面切换\n  history模式：history模式不会出现#号比较美观，利用history.pushState()来完成URL的跳转而且无须重写加载页面\n  示例代码\nconst router = new VueRouter({ mode: \u0026#39;history\u0026#39;, router: [...] })   vue-router默认为hash模式，需要通过mode来改变模式\n        vue-router基本使用\n  引入vue-router.js\n  定义路由链接和路由视图\n代码示例：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34; tag=\u0026#34;span\u0026#34;\u0026gt;前往登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; router-link是路由链接，to代表链接地址，tag代表渲染的标签\nrouter-view是路由视图，用于显示路由链接对应的组件\n  定义路由匹配规则\n代码示例\nvar login = { template: \u0026#34;\u0026lt;h1\u0026gt;登录组件\u0026lt;/h1\u0026gt;\u0026#34; } const router = new VueRouter({ routes: [ { path: \u0026#39;/login\u0026#39;, component: login } ] }); 在实例化VueRouter的时候传入routes\n通过routes定义路由匹配规则，可以定义多个\n匹配规则是一个对象，key是路由链接path，value是组件component\n  注册路由\n代码示例\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, router: router }); 在实例化Vue的时候，通过选项router来注册路由\n    路由对象属性\n  this.$router表示全局路由器对象，就是通过router选项注册的VueRouter路由管理器对象\n  this.$route代表当前路由对象，而已获取当前路由相关信息\n  路由对象属性\n   属性名 类型 说明     $route.path String 对应当前路由的路径   $route.query Object 一个{key:value}对象，表示URL查询参数   $route.params Object 一个{key:value}对象，路由跳转携带参数   $route.hash String 在history模式下获取当前路由hash值（带#），如果没有hash值，则为空字符串   $route.fullPath String 完成解析后的URL，包含查询参数和hash的完整路径   $route.name String 当前路由的名称   $route.matched Array 路由记录，当前路由下路由声明的所有信息，从父路由（如果有）到当前路由为止   $route.redirectedFrom String 如果存在重定向，即为重定向来源的路由        3.用户登录注册案例 4.动态路由   什么是动态路由\n可以匹配带有不同参数的url的路由规则就是动态路由\n  query方式传参\n  通过？传参\n  传参\n  示例\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user?id=1\u0026amp;name=Rex\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; id: {{this.$route.query.id}} name: {{this.$route.query.name}} \u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt;   传参语法：?参数名1=参数值1\u0026amp;参数名2=参数值2\n    定义路由\nconst router = new VueRouter({ routes: [{ path: \u0026#39;/user\u0026#39;, component: user }] })   获取参数\n{{this.$route.query.参数名}}\n    params方式传参\n  通过url本身传递\n  传参\n  示例代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user/10/admin\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; id:{{this.$route.params.id}} name:{{this.$route.params.name}} \u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt;   传参语法：/参数值1/参数值2，这里只需要传递值即可\n    定义动态路由\n  实例代码\nconst router = new VueRouter({ routes: [ { path: \u0026#34;/user/:id/:name\u0026#34;, component: user } ] })   动态路由语法，:参数名，以冒号开头就代表动态匹配\n  :id就会匹配10，:name就会匹配admin\n    获取参数\n{{$route.params.参数名}}\n    5. 嵌套路由   什么是嵌套路由\n  界面中如果存在嵌套组件,那么就需要组件对应的路由也是嵌套路由\n  定义嵌套路由:\n  通过在路由对象中定义children属性,定义嵌套的子路由\n  示例代码\nvar router = new VueRouter({ routes:[{ path: \u0026#39;/home\u0026#39;, component: home, children:[ {path: \u0026#39;login\u0026#39;, component: login}, {path: \u0026#39;register\u0026#39;, component: register} ] }] })     使用嵌套路由\n  示例代码:\n\u0026lt;router-link to=\u0026#34;/父路由的地址/要去的子路由\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   子路由的url是:父path/子path\n      6. 命名路由   如果路由的path比较长,使用的时候比较麻烦,这时候可以给路由起个名字,用的时候通过名字使用\n  定义命名路由\n  示例代码\n​\nconst router = new VueRouter({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: user } ] })   在定义路由对象时,通过name来给路由起名字\n    使用命名路由\n  示例代码\n\u0026lt;router-link :to=\u0026#34;{name:\u0026#39;user\u0026#39;, params: {id:123}}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt;   使用属性绑定,是因为to的值是一个js对象\n    7. 命名视图   给视图起名字,就是命名视图\n  在开发中想同时显示多个同级视图,这时候就需要使用命名视图\n  定义命名视图\n  示例代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view name=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   通过name属性给router-view添加名字\n    路由规则使用命名视图\n  示例代码\nvar header = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;header\u0026#34;\u0026gt;header头部区域\u0026lt;/h1\u0026gt;\u0026#39; } var sidebar = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;sidebar\u0026#34;\u0026gt;sidebar测导航区域\u0026lt;/h1\u0026gt;\u0026#39; } var mainbox = { template: \u0026#39;\u0026lt;h1 class=\u0026#34;main\u0026#34;\u0026gt;mainBox主题区域\u0026lt;/h1\u0026gt;\u0026#39; }   路由对象中通过components来使用多个视图\n    8. 编程式导航   router.push()\n  push:推,push方法可以实现url跳转\n  语法:\n  //先获取router实例 var router = new VueRouter() //字符串形式 router.push(\u0026#39;user\u0026#39;) //对象形式 router.push({path:\u0026#39;/login?url=\u0026#39;+this.$route.path}) //命名路由 router.push({name:\u0026#39;user\u0026#39;, params:{userId:123}}) //带查询参数/user?id=1 route.push({path:\u0026#39;user\u0026#39;,queyr:{id:\u0026#39;1\u0026#39;}})   push可以传递一个字符串路径,也可以是对象\n  对象中可以是路径path,也可以是路由的名字\n    注意\n  在参数对象中,如果提供了path,params会被忽略,为了传参数,需要提供路由的name或者手写带有参数的路径\n  const userId = \u0026#39;123\u0026#39; router.push({name:\u0026#39;user\u0026#39;, params:{userId}}) // /user/123 router.push({path:\u0026#39;/user/${userId}\u0026#39;})\t// /user/123 //这里的params不生效 router.push({path:\u0026#39;/user\u0026#39;, params:{userId}})// /user       router.replace()\n  replace:替换,可以替换当前界面的url\n  语法\n//编程式 router.replace({path:\u0026#39;user\u0026#39;}) //声明式 \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;user\u0026#39;} replace\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;   与push的区别:push有history记录,replace没有\n    router.go()\n go:去,可以实现前进后退 go()方法,接受正数或负数,表示前进或后退 后退一个界面:$router.go(-1) 前进一个界面:$router.go(1)    Vuex状态管理 初始Vuex   Vuex是一套组件状态（数据）管理维护工具\n  使得Vue组件的状态更加容易维护\n  创建Vuex的store示例\n  const store = new Vuex.Store({ state:{}, mutations:{} })   使用Vuex就是使用store来对状态进行管理\n  Vuex通过store(存储来存储数据)，并且管理数据\n    Vuex的下载和安装   script引入文件\n  下载Vuex\n  引入\n\u0026lt;script src=\u0026#34;../js/vuex.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   使用\n  创建store\nconst store = new Vuex.Store({ state: { name: \u0026#39;vuex.js直接引用\u0026#39; } }) 实例化Store的时候，可以传入state选项\nstate选项：状态选项，数据选项，用于定义要存储的数据\n  挂载store\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store })   使用state数据\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{this.$store.state.name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 获取state数据是一层一层的获取的\nthis中有store选项，所以：this.$store\nstore中有state，所以this.$store.state\nstate中有name，所以this.$store.state.name\n  使用计算属性\n  上边的方式，使用state数据，太麻烦了，每次都要this.$store.state.name\n  我们可以在计算属性中将state数据返回，相当于将state数据变为计算属性，这样在使用的时候就简单很多\n  定义计算属性\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, computed: { name() { return this.$store.state.name; } } })   使用\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;     mapState辅助函数\n  当一个组件需要获取多个状态时，将这些状态都声明为计算属性有些麻烦，这时候可以使用mapState辅助函数来生成计算属性\n  使用mapState\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, computed: Vuex.mapState({ //key:计算属性的名字  //value:函数，将state数据返回  name: state =\u0026gt; state.name }) })  mapState是Vuex提供的一个方法 mapState，是状态映射，理解为将state数据映射（转换）为计算属性 mapState接受一个对象，对象中可以映射多个数据 对象中的key是计算属性的名字，value是一个箭头函数，箭头函数有一个state参数然后直接将state的数据返回即可    使用数据\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{name}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;         npm安装\n  需要船舰出来一个项目才可以导入npm安装的包\n 创建项目需要脚手架vue-cli npm install vue-cli \u0026ndash;save    创建webpack模板的vue项目\n vue init webpack demo02 cd demo02    安装vuex\n npm install vuex@3.1.1 \u0026ndash;save    定义store的数据\n  创建store\\index.js文件，用来导出store实例\n  import Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;Vuex\u0026#39; Vue.use(Vuex) export default new Vuex.Store({ state: {name: \u0026#39;正在使用Vuex\u0026#39;} }) 通过import导入npm安装的包\n通过Vue.use安装Vuex\nexport default将store导出，其他组件都可以使用\n    导入store\n  修改src\\main.js文件导入相关文件\n  import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false  导入Vue，并且配置productionTip为false 导入根组件App 导入路由router 导入数据store      注册store\n  修改src\\main.js文件，在Vue实例中注册store\n  /*eslint-disable no new*/ new Vue({ el:\u0026#39;#app\u0026#39;, router, components:{App}, template:\u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, store })  eslint-disable no-new：是关闭eslint语法校验 components:{App}:注册组件App template: '\u0026lt;App/\u0026gt;'使用组件App，App.vue中的#app的div el: \u0026lsquo;#app\u0026rsquo;, 这个是index.html中的div      修改App.vue\n  映射state数据\n\u0026lt;script\u0026gt; import { mapState } from \u0026#34;vuex\u0026#34;; export default { name: \u0026#34;App\u0026#34;, computed: mapState({ name: (state) =\u0026gt; state.name, }), }; \u0026lt;/script\u0026gt;   使用数据\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ name }}\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;     运行项目 npm run dev\n    Vuex状态管理模式   单项数据流机制：在Vue中，组件的状态变化是通过Vue单向数据流的设计理念实现的。\n  单项数据流组成部分主要包括\n State：驱动应用的数据源 View：以声明方式将state映射到视图 Actions：响应在View上的用户输入导致状态变化     代码:\nnew Vue({ //State  data(){ return {count: 0} }, //View  template: \u0026#39;\u0026lt;div\u0026gt;{{ count }}\u0026lt;/div\u0026gt;\u0026#39;, //Actions  methods:{ increment(){ this.count++; } } })   Vuex的工作流程关系 actions、mutations和state的关系\n State数据render渲染到vue组件 用户在Vue组件中点击按钮，触发逻辑Actions Actions中通过commit触发修改数据逻辑Mutations Mutations修改的state，重新渲染到Vue组件  Vuex配置选项 1.mutations   mutations是一个对象，可以定义多个方法\n  mutations方法用来操作state数据（翻译：变化，理解为数据变化）\n  mutations方法接受state对象作为参数\n  在组件中通过store.commit(\u0026ldquo;mutations方法名\u0026rdquo;)来触发mutations方法执行\n  代码：\nconst store = new Vuex.Store({ state: { param: \u0026#34;\u0026#34; }, mutations: { reciver(state, param) { this.state.param = param; console.log(param); } } }) new Vue({ el: \u0026#34;#app\u0026#34;, store: store, methods: { param() { this.$store.commit({ type: \u0026#34;reciver\u0026#34;, name: \u0026#34;我是传递的数据\u0026#34; }) } }, })   2.actions   actions类似于mutations，不同之处在于actions是异步执行的（翻译：动作，理解为执行异步动作）\n  actions函数接受store对象，用于完成mutations提交\n  store的dispatch方法触发actions函数\n  代码\n  const store = new Vuex.Store({ state: { count: 0 }, //mutations：专门用来修改state的数据  mutations: { increment(state) { state.count++; } }, actions: { add(context) { setTimeout(() =\u0026gt; { context.commit(\u0026#34;increment\u0026#34;) }, 1000); } } })   context即为store实例\n  简写\nactions:{ add({commit}){ commit(\u0026#34;increment\u0026#34;)\t}\t}     var vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, methods: { calc() { this.$store.dispatch(\u0026#34;add\u0026#34;); } }, }); store的dispatch方法，用于触发actions方法\n    3.getters   getters，类似于Vue实例的computed计算属性（翻译：获取者，获取计算之后的数据）\n  定义\nconst store = new Vuex.Store({ state: { todos: [{ id: 1, text: \u0026#39;列表1\u0026#39; }, { id: 2, text: \u0026#39;列表2\u0026#39; }], id: 0 }, mutations: { searchM(state, id) { state.id = id; } }, getters: { searchG: state =\u0026gt; { return state.todos.filter( todo =\u0026gt; (todo.id == state.id) ) } } }) getters是计算属性，计算属性其实是方法，只不过使用的时候是属性\n  使用\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;列表查询\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;search\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;搜索结果：{{this.$store.getters.searchG}}\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in this.$store.state.todos\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;   4.modules   modules模块就是为了应对复杂的业务逻辑，将数据与操作数据的逻辑分模块处理\n  modules的配置选项：\n  与store数据参考中的参数是相同的\n  key:{\t//key表示模块名称  state,\t//初始数据  mutations,\t//状态提交，同步 \tactions,\t//状态分发，异步  getters,\t//计算属性  modules\t//模块 }   代码\nconst moduleA = { state: { nameA: \u0026#39;A\u0026#39; } } const moduleB = { state: { nameB: \u0026#39;B\u0026#39; } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }); console.log(store.state.a); console.log(store.state.b);     5.plugins   用于给Vuex添加插件，插件本身为函数\n  函数接受参数store对象作为参数\n  代码\nconst myPlugin = store =\u0026gt; { store.subscribe((mutation, state) =\u0026gt; { // 每次mutation提交后调用，mutation格式{type, paylooad}  console.log(mutation.type, mutation.payload); }) } const store = new Vuex.Store({ mutations: { do(state) { console.log(state); } }, plugins: [myPlugin] }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, store, }); store.commit(\u0026#39;do\u0026#39;, \u0026#39;plugin\u0026#39;) 插件函数中通过store实例对象的subscribe函数可以用来处理mutation\nsubscribe函数接受参数为mutation和state\n  作用：一般在项目中我们会使用plugin初始化一些数据\n  6.devtools  用来设置是否在devtools调试工具中应用Vuex 默认值为true，表示在启用，设为false表示停止使用  Vuex中的API 模块注册   store.registerModule()用于动态创建模块的接口\n  与modules选项作用类似，但是registerModule()更加灵活\n  代码\n  const store = new Vuex.Store({ state: {}, }); store.registerModule(\u0026#39;myModule\u0026#39;, { state: { name: \u0026#34;我是注册模块的数据\u0026#34; } }) modules选项只能在实例化store的时候，注册模块\nregisterMudule()方法只要是能够获取到store对象的地方都可以注册\n    状态替换   store.replaceState()方法用于实现状态替换\n  该方法接受新的state对象\n  代码\nconst store = new Vuex.Store({ state: { name: \u0026#39;我是初始值数据\u0026#39; } }); store.replaceState({ name: \u0026#34;替换后的新数据\u0026#34; }) var vm = new Vue({ el: \u0026#34;#app\u0026#34;, store, }) \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{this.$store.state.name}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   ","permalink":"https://rex0520.github.io/posts/front/vue/vue%E8%BF%9B%E9%98%B6/","summary":"Vue进阶 Vue路由 1.初始路由 **路由**：表示一种对应关系，某些事物的一一对应的关系 **后端路由**：后端路由是由服务器端进行实现，并完成资源的分发（url与资源/数据的对应关系） **前端路由**：前端路由是依靠hash值（锚点链接）的变化进行实现页面内容的切换（锚点与组件之间的关系）  2.vue-router   vue-router工作原理\n  它是一个Vue.js官方提供的路由管理器，是一个功能更加强大的前端路由器，可以实现前端界面内容切换\n  SPA：Single Page Application，单页面应用，整个网站只有一个页面\n  SPA推荐使用vue-router，实现界面内容的切换\n  vue-router提供两种模式\n  hash模式：hash又叫锚点：比如#/login，根据hash改变，来实现界面切换\n  history模式：history模式不会出现#号比较美观，利用history.pushState()来完成URL的跳转而且无须重写加载页面\n  示例代码\nconst router = new VueRouter({ mode: \u0026#39;history\u0026#39;, router: [...] })   vue-router默认为hash模式，需要通过mode来改变模式\n        vue-router基本使用\n  引入vue-router.js\n  定义路由链接和路由视图\n代码示例：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34; tag=\u0026#34;span\u0026#34;\u0026gt;前往登录\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; router-link是路由链接，to代表链接地址，tag代表渲染的标签","title":"Vue进阶"},{"content":"JPA 一、什么是jpa ​\tJPA是Java Persistence API的意思，是一种ORM框架。是使用JDK 5.0注解或XML描述对象－关系表的映射关系的元数据，并将运行期的面向对象语言程序中的实体对象持久化到数据库中。\n二、基于注解的使用  JPA常用注解    注解 解释     @Entity 声明类为实体或表。   @Table 声明表名。   @Basic 指明非约束明确的各个字段。   @Embedded 指定类或它的值是一个可嵌入的类的实体的属性。   @Id 指定的类的属性，用于识别（一个表中的主键）。   @GeneratedValue 指定如何标识属性可以被初始化，例如自动、手动、或从序列表中获得的值。   @Transient 指定的属性，它是不持久的，即：该值永远不会存储再数据库中。   @Column 指定持久属性栏属性。   @SequenceGenerator 指定在@GeneratedValue注解中指定的属性的值。它创建了一个序列。   @TableGenerator 指定在@GeneratedValue批注指定属性的值发生器。它创造了的值生成的表。   @AccessType 这种类型的注释用于设置访问类型。如果设置@AccessType(FIELD)，则可以直接访问变量并且不需要getter和setter，但必须为public。如果设置@AccessType(PROPERTY)，通过getter和setter方法访问Entity的变量。   @JoinColumn 指定一个实体组织或实体的集合。这是用在多对一和一对多关联。   @UniqueConstraint 指定的字段和用于主要或辅助表的唯一约束。   @ColumnResult 参考使用select字句的SQL查询中的列明。   @ManyToMany 定义了连接表之间的多对多的的关系   @ManyToOne 定义了连接表之间的多对一的关系   @OneToMany 定义了连接表之间存在一个一对多的关系。   @OneToOne 定义了连接表之间有一个一对一的关系   @NamedQueries 指定命名查询的列表   @NamedQuery 指定使用静态名称的查询。      三、使用   在application.properties文件中的配置\n#jpa的配置 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=create tips:\n​\tjpa.hibernate.ddl-auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：\n  create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。\n  create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。\n  update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n  validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\n    四、JPQL查询 ​\t常用关键字\n   keyword sample jpaql snippet     And findByLastnameAndFirstname \u0026hellip;where x.firstname = ?1 and x.lastname = ?2   Or findByLastnameOrFirstname \u0026hellip;where x.firstname = ?1 or x.lastname = ?2   Is, Equals findByFirstnameIs, findByFirstnameEquals \u0026hellip;where x.firstname = ?1   Between findByStartDateBetween \u0026hellip;where x.firstname between ?1 and ?2   LessThan findByAgeLessThan \u0026hellip;where x.age \u0026lt; ?1   LessThanEqual findByAgeLessThanEqual \u0026hellip;where x.age \u0026lt;= ?1   GreaterThan findByAgeGreaterThan \u0026hellip;where x.age \u0026gt; ?1   GreaterThanEqual findByAgeGreaterThanEqual \u0026hellip;where x.age \u0026gt;= ?1   After findByStartDateAfter \u0026hellip;where x.startDate \u0026gt; ?1   Before findByStartDateBefore \u0026hellip;where x.startDate \u0026lt; ?1   IsNull findByAgeIsNull \u0026hellip;where x.age is null   IsNotNull, NotNull findByAge(IS)NotNull \u0026hellip;where x.age not null   Like findByFirstnameLike \u0026hellip;where x.firstname like ?1   NotLike findByFirstnameNotLike \u0026hellip;where x.firstname not like ?1   StartingWith findByFirstnameStartingWith \u0026hellip;where x.firstname like ?1(parameter bound with appended %)   EndingWith findByFirstnameEndingWith \u0026hellip;where x.firstname like ?1(parameter bound with prepended %)   Containing findByFirstnameContaining \u0026hellip;where x.firstname like ?1(parameter bound with wrapped in %)   OrderBy findByAgeOrderByLastnameDesc \u0026hellip; where x.age = ?1 order by x.lastname desc   Not findByLastnameNot \u0026hellip; where x.lastname \u0026lt;\u0026gt; ?1   In findByAgeIn (Collection ages) \u0026hellip; where x.age in ?1   NotIn findByAgeNotIn (Collection ages) \u0026hellip; where x.age not in ?1   TRUE findByActiveTrue() \u0026hellip;where x.active=true   FALSE findByActiveFalse() \u0026hellip;where x.active=false   IgnoreCase findByFirstnameIgnoreCase \u0026hellip;where UPPER(x.firstname) = UPPER(?1)    五、自定义Query 使用原生的sql语句 @Query(nativeQuery = true) 1.查询 实例 public interface UserRepository extends Repository\u0026lt;User, Long\u0026gt; { /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，参数分别为?1，?2，?3...... * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=?1\u0026#34;) public User findUser(Long id); /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * :id为传递的参数 * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=:id\u0026#34;) public User findUserByParam(@Param(\u0026#34;id\u0026#34;) Long id); /** * 根据id和name查询用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param id * @return */ @Query(\u0026#34;select u from User u where u.id=?1 and u.name=?2\u0026#34;) public User findUserByIdAndName(Long id, String name); /** * 查询所有用户信息 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * * @return */ @Query(\u0026#34;select u from User u\u0026#34;) public List\u0026lt;User\u0026gt; findUserList(); /** * 根据name模糊查询 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param name * @return */ @Query(\u0026#34;select u from User u where name like %?1%\u0026#34;) public List\u0026lt;User\u0026gt; findUserListByLikeName(String name); /** * 根据name模糊查询 * \u0026lt;p\u0026gt; * User为ORM映射的类名，即为ORM映射的实体类名 * 根据参数的顺序，分别为?1，?2，?3...... * * @param name * @return */ @Query(\u0026#34;select u from User u where name like concat(\u0026#39;%\u0026#39;,?1,\u0026#39;%\u0026#39;) \u0026#34;) public List\u0026lt;User\u0026gt; findUserListByLikeConcatName(String name); /** * 根据id查询用户信息 * \u0026lt;p\u0026gt; * nativeQuery = true时，JPA能够识别真正的SQL语句 * * @param id * @return */ @Query(value = \u0026#34;select * from user where id=?1\u0026#34;, nativeQuery = true) public User findUserByNativeQuery(int id); /** * 使用SpEL表达式 * \u0026lt;p\u0026gt; * 从Spring Data JPA 1.4版开始，我们支持在手动定义的查询中使用受限制的SpEL模板表达式@Query。 * 在执行查询时，将根据预定义的变量集评估这些表达式。Spring Data JPA支持一个名为的变量entityName。它的用法是select x from #{#entityName} x。 * 它插入entityName与给定存储库关联的域类型。该entityName解决如下：如果域类型已设置的name属性@Entity的注释，它被使用。否则，使用域类型的简单类名 * * @param name * @return */ @Query(\u0026#34;select u from #{#entityName} u where u.name = ?1\u0026#34;) public List\u0026lt;User\u0026gt; findBySpEL(String name); } 2.更新/删除 示例 ​\tUserRepository.java\n@Transactional//事务：原子性，回滚 @Modifying @Query(\u0026#34;update User set gender=:gender where userName=:name \u0026#34;) public int updateUser(@Param(\u0026#34;gender\u0026#34;) Integer gender ,@Param(\u0026#34;name\u0026#34;) String userName); 3.多表联查 示例 ​\tUserDepartVo.java\n@Data @AllArgsConstructor public class UserDepartVo { String code; String userName; Integer gender; String name; } ​\tUserRepository.java\n//查询所有用户的code，姓名，性别，部门名称 @Query(\u0026#34;select new com.wzy.jxx.jpa.UserDepartVo(u.code,u.userName,u.gender,d.name) \u0026#34; + \u0026#34;from User u,Department d where u.departmentId=d.id\u0026#34;) public List\u0026lt;UserDepartVo\u0026gt; getUserDeparment(); 4.分页查询 示例1 ​\tUserRepository.java\n@Query(\u0026#34;select u from User u where gender=?1 and age between ?2 and ?3 \u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender3(Integer gender, Integer minAge, Integer maxAge,Pageable pageable); ​\tUserController.java\n@PostMapping(\u0026#34;/findPageByGender3\u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender3(Integer page, Integer size,Integer gender, Integer minAge, Integer maxAge){ Pageable pageable = PageRequest.of(page,size); return userRepository.findPageByGender3(gender, minAge, maxAge, pageable); } 示例2 ​\tUserRepository.java\n@Query(value = \u0026#34;select * from User WHERE gender = ?1\u0026#34;,nativeQuery = true) Page\u0026lt;User\u0026gt; findPageByGender(Integer gender, Pageable page); ​\tUserController.java\n@PostMapping(\u0026#34;findPageByGender\u0026#34;) public Page\u0026lt;User\u0026gt; findPageByGender(Integer gender){ Pageable pageable = PageRequest.of(0,20); Page\u0026lt;User\u0026gt; userPage = userRepository.findPageByGender(gender,pageable); List\u0026lt;User\u0026gt; users = userPage.getContent(); return userPage; } 5.排序查询 示例 ​\tUserRepository.java\n@Query(value = \u0026#34;select u from User u WHERE gender = ?1\u0026#34;) List\u0026lt;User\u0026gt; findByGenderSort(Integer gender, Sort sort); ​\tUserController.java\n@PostMapping(\u0026#34;findByGenderSort\u0026#34;) public List\u0026lt;User\u0026gt; findByGenderSort(Integer gender){ Sort sort = Sort.by(Sort.Direction.DESC, \u0026#34;id\u0026#34;); List\u0026lt;User\u0026gt; users = userRepository.findByGenderSort(gender,sort); return users; } ","permalink":"https://rex0520.github.io/posts/back/jdbctool/jpa%E5%AD%A6%E4%B9%A0/","summary":"JPA 一、什么是jpa ​\tJPA是Java Persistence API的意思，是一种ORM框架。是使用JDK 5.0注解或XML描述对象－关系表的映射关系的元数据，并将运行期的面向对象语言程序中的实体对象持久化到数据库中。\n二、基于注解的使用  JPA常用注解    注解 解释     @Entity 声明类为实体或表。   @Table 声明表名。   @Basic 指明非约束明确的各个字段。   @Embedded 指定类或它的值是一个可嵌入的类的实体的属性。   @Id 指定的类的属性，用于识别（一个表中的主键）。   @GeneratedValue 指定如何标识属性可以被初始化，例如自动、手动、或从序列表中获得的值。   @Transient 指定的属性，它是不持久的，即：该值永远不会存储再数据库中。   @Column 指定持久属性栏属性。   @SequenceGenerator 指定在@GeneratedValue注解中指定的属性的值。它创建了一个序列。   @TableGenerator 指定在@GeneratedValue批注指定属性的值发生器。它创造了的值生成的表。   @AccessType 这种类型的注释用于设置访问类型。如果设置@AccessType(FIELD)，则可以直接访问变量并且不需要getter和setter，但必须为public。如果设置@AccessType(PROPERTY)，通过getter和setter方法访问Entity的变量。   @JoinColumn 指定一个实体组织或实体的集合。这是用在多对一和一对多关联。   @UniqueConstraint 指定的字段和用于主要或辅助表的唯一约束。   @ColumnResult 参考使用select字句的SQL查询中的列明。   @ManyToMany 定义了连接表之间的多对多的的关系   @ManyToOne 定义了连接表之间的多对一的关系   @OneToMany 定义了连接表之间存在一个一对多的关系。   @OneToOne 定义了连接表之间有一个一对一的关系   @NamedQueries 指定命名查询的列表   @NamedQuery 指定使用静态名称的查询。      三、使用   在application.","title":"JPA学习"},{"content":"Vue动画 Vue过渡和动画 1. 过渡和动画基础   什么是过渡和动画\n  过渡：从一个状态向另一个状态变化的过程\n  动画：与过渡非常类似，只不过动画控制的过程更加细腻，更加精准\n  过渡语法：\n\u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 需要添加过渡的div标签--\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; name指定的是过渡所需要的样式名的前提\n    transition组件\n  Vue给transition标签，提供了六个过度类\n   过渡类型 说明     v-enter 进入过渡的开始状态，作用于开始的一帧   v-enter-active 进入过渡生效时的状态，作用于整个过程   v-enter-to 进入过渡的结束状态，作用于结束的一帧   v-leave 离开过渡的开始状态，作用于开始的一帧   v-leave-active 离开过渡生效时的状态，作用于整个过程   v-leave-to 离开过渡的结束状态，作用于结束的一帧      过渡类分析图\n  代码示例：\nhtml：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;调整box的宽度\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; css：\n/* 图形的初始状态 */ .chart { width: 200px; height: 50px; background-color: orange; } .box-enter-active, .box-leave-active { transition: width 3s; } .box-enter, .box-leave-to { width: 0px; } .box-enter-to, .box-leave { width: 200px; } js：\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { show: true }, methods: { toggle() { this.show = !this.show; } }, })   总结\n v-enter 进入前的那一刻，和v-leave-to 离开结束的那一刻，就是隐藏的状态 v-enter-to 进入结束的那一刻，和v-leave 离开前的那一刻，就是显示的状态 v-enter-active 与 v-leave-active，是进入（显示）的整个过渡过程，与离开（隐藏）的整个过渡过程      自定义类名\n  transition允许使用自定义的类名\n  如果使用自定义类名，就不需要设置name属性\n  设置自定义类名的属性\n 进入：enter-class、enter-active-class、enter-to-class 离开：leave-class、leave-active-class、leave-to-class    初始化渲染动画\n\u0026lt;transition appear appear-active-class=\u0026#34;animated swing\u0026#34; enter-active-class=\u0026#34;animated bounceInLeft\u0026#34; leave-active-class=\u0026#34;animated bounceOutLeft\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34;\u0026gt;动画效果过渡\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt; 上述代码中，appear表示开启此特性，appear-class表示初始class样式，appear-to-class表示过渡完成的class样式，appear-active-class会应用在整个过渡过程中\n    使用@keyframes创建CSS动画\n  keyframes：关键帧，用于定义动画的每一帧\n  代码：\n.bounce-enter-active { animation: Anim 1s; } .bounce-leave-active { /* 反向 */ animation: Anim 1s reverse; } @keyframes Anim { /* 相当于v-enter和v-leave-to */ 0% { transform: scale(0); background-color: red; } /* 相当于 v-enter-to 和 v-leave */ 100% { transform: scale(1); background-color: blue; } }     钩子函数实现动画\n  在动画执行过程中的各个阶段会有不同的钩子函数，通过这些钩子函数也可以实现动画\n  钩子函数\n  入场钩子\n\u0026lt;transition @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @after-enter=\u0026#34;afterEnter\u0026#34; @enter-cancelled=\u0026#34;enterCancelled\u0026#34; \u0026lt;/transition\u0026gt;   出场钩子\n\u0026lt;transition @before-leave=\u0026#34;beforeLeave\u0026#34; @leave=\u0026#34;leave\u0026#34; @after-leave=\u0026#34;after-leave\u0026#34; @leave-cancelled=\u0026#34;leaveCancelled\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt;   Vue会跳过CSS的检测\n\u0026lt;transition v-bind:css=\u0026#34;false\u0026#34;\u0026gt; \u0026gt; \u0026lt;/transition\u0026gt;       Vue结合Velocity.js实现动画\n  Velocity.js是一个简单易用，高性能且功能丰富的轻量级JS动画库\n  代码：\nenter(el, done) { Velocity(el, { opacity: 1, fontSize: \u0026#39;1.4em\u0026#39; }, { duration: 300 }) Velocity(el, { fontSize: \u0026#39;1em\u0026#39; }, { complete: done }); },   注意\n 在动画钩子函数中可以利用velocity来确定执行的动画 velocity第一个参数是DOM元素，第二个参数是css样式，第三个参数表示动画的配置项 第三个参数可以配置duration动画时长，也可以配置动画完成complete      2. 多个元素过渡   不同标签名元素过渡\n  不同标签默元素可以使用v-if和v-else来进行过渡\n  代码\n\u0026lt;transition\u0026gt; \u0026lt;ul v-if=\u0026#34;items.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;li\u0026gt;项目1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p v-else\u0026gt;抱歉，没有找到您查询的内容\u0026lt;/p\u0026gt; \u0026lt;/transition\u0026gt;     相同标签名元素过渡\n  相同标签名的元素切换时，需要通过key设置唯一值\n  代码：\n\u0026lt;button @click=\u0026#34;isEdit=!isEdit\u0026#34;\u0026gt;切换编辑和保存\u0026lt;/button\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;button v-if=\u0026#34;isEdit\u0026#34; key=\u0026#34;edit\u0026#34;\u0026gt; 编辑 \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#39;save\u0026#39;\u0026gt; 保存 \u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { isEdit: \u0026#34;true\u0026#34; } });     过渡模式\n 过度模式描述  新旧俩个元素参与过渡的时候，新元素的进入和旧元素的离开会同时触发，这是因为\u0026lt;transition\u0026gt;的默认行为进入和离开同时发生了，如果要求离开的元素完全消失后，进入的元素再显示出来（如开始的切换），可以使用transition提供的过渡模式mode，来解决当一个组件离开后，另一个组件进来时发生的位置的闪动或阻塞问题 过渡模式的原理时，设置有序的过渡而不是同时发生过渡，在transition中加入mode属性，它的俩个值如下所示。 in-out：表示新元素先进行过渡，完成之后当前元素过渡离开 out-in：表示当前元素先进行过渡，完成之后新元素过渡进入      3. 多个组件过渡   什么是多个组件过渡\n  通过\u0026lt;component\u0026gt;元素的is属性来切换组件，实现动态组件，然后给组件添加过渡，这就是多组件过渡\n  案例演示\n\u0026lt;transition name=\u0026#34;fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;componentName\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; Vue.component(\u0026#39;example1\u0026#39;, { template: \u0026#34;#example1\u0026#34; }) Vue.component(\u0026#39;example2\u0026#39;, { template: \u0026#39;#example2\u0026#39; }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { componentName: \u0026#39;example1\u0026#39; } })     4. 列表过渡   什么是列表过渡\n通过v-for循环显示多个元素，并且通过transition-group组件来给这多个元素同时添加过渡效果\n  列表的进入和离开过渡\n\u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;span v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item}} \u0026lt;/span\u0026gt; \u0026lt;/transition-group\u0026gt; /* 插入或移除元素的过程 */ .list-enter-active, .list-leave-active { transition: all 1s; } /* 开始插入或移除结束的位置变化 */ .list-enter, .list-leave-to { opacity: 0; transform: translateY(30px); }   列表的排序过渡\n  排序过渡 - 其他元素平滑过渡\n当插入或移除元素的时候，虽然有过渡动画，但是周围的元素会瞬间移动到新的置，而不是平滑过渡。为了实现平滑过渡，可以借助v-move特性，v-move对于设置过渡的切换时机和过渡曲线非常有用。v-move特性会在元素改变定位的过程中应用，它同之前的类名一样，可以通过name属性来自定义前缀（例如name）\n.list-move { transition: transform 1s; }   Flip\nVue使用了FLIIP简单动画队列来实现排序过渡，所以即使没有插入或者移除元素，对于元素顺序的变化也支持过渡动画，FLIP动画能提高动画的流畅度，可以解决动画的卡顿，闪烁等不流畅的现象，它不禁可以实现单列过渡，也可以实现多维网络的过渡。FLIP代表First、Last、Invert、Play，有兴趣的读者可以自行研究学习\n    列表的交错过渡\n  列表的交错过渡，其实就是多个li在做动画时，每一个li做过渡时有时间差，依次过渡\n  延迟做过渡动画\nenter(el, done) { //交错过渡，每个li都做延迟过渡  var delay = el.dataset.index * 150; setTimeout(function () { Velocity(el, { opacity: 1, height: \u0026#39;1.6em\u0026#39; }, { complete: done }); }); }, leave(el, done) { var delay = el.dataset.index * 150; setTimeout(function () { Velocity(el, { opacity: 0, height: 0 }, { complete: done }) }) }     可复用的过渡\n template方式 函数式组件方式    ","permalink":"https://rex0520.github.io/posts/front/vue/vue%E5%8A%A8%E7%94%BB/","summary":"Vue动画 Vue过渡和动画 1. 过渡和动画基础   什么是过渡和动画\n  过渡：从一个状态向另一个状态变化的过程\n  动画：与过渡非常类似，只不过动画控制的过程更加细腻，更加精准\n  过渡语法：\n\u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 需要添加过渡的div标签--\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; name指定的是过渡所需要的样式名的前提\n    transition组件\n  Vue给transition标签，提供了六个过度类\n   过渡类型 说明     v-enter 进入过渡的开始状态，作用于开始的一帧   v-enter-active 进入过渡生效时的状态，作用于整个过程   v-enter-to 进入过渡的结束状态，作用于结束的一帧   v-leave 离开过渡的开始状态，作用于开始的一帧   v-leave-active 离开过渡生效时的状态，作用于整个过程   v-leave-to 离开过渡的结束状态，作用于结束的一帧      过渡类分析图\n  代码示例：","title":"Vue动画"},{"content":"Vue基础 初始Vue 前端技术的发展   HTML：用于编写网页的结构\n  CSS：用于美化网页\n  JS：用于处理页面的交互效果\n  JQuery：JS的升级版，代码简洁，更高效的开发项目\n  Vue：采用虚拟DOM技术，代码更加简洁\n虚拟DOM技术\n 和真实DOM结构类似的JS对象 可以提高浏览器的渲染速度    什么是Vue   一条基于构建用户界面的渐进式框架\n 渐进式理解：Vue提供的一系列技术，可以渐渐的，一步一步的使用这个框架 框架理解：解决一类问题的解决方案，理解为工具    Vue的数据绑定基于MVVM设计思想\nMVVM：Model，View，ViewModel\n可以将模型数据与视图连接起来\n 模型数据变化会影响视图 视图数据变化会影响模型    Vue的优势  轻量级：Vue简单、直接，所以Vue使用起来更加友好 数据绑定：数据驱动视图，视图也可以驱动数据 指令：指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为 插件：插件用于对Vue框架功能进行扩展  Vue、Angular和React的区别：  Angular相对Vue学习成本高，更复杂，性能稍差 React采用了特殊的JSX语法，Vue中推崇编写以*.vue后缀命名的文件格式  Vue开发基础上 1.Vue实例   说明\n  Vue实例：通过new关键字实例化Vue({})构造函数\n  实例化Vue时的参数内的属性，我们称之为选项：\n       选项 说明     data Vue实例数据对象   methods 定义Vue实例中的方法   component 定义子组件   computed 计算属性   filters 过滤器   el 唯一根元素   watch 监听数据变化    el唯一根标签：在创建Vue实例时，el表示唯一根标签，通过指定class或id选择器可用来将页面结构与Vue实例对象vm进行绑定。  el：element，元素 el选项表示：当前Vue实例绑定的页面怨怒是 绑定的这个元素，作为Vue实例在界面上的元素 el选项的值：“id或类选择器” 注意：Vue的数据只能在el绑定的元素内部使用   data初始数据：Vue实例的数据对象为data，Vue会将data的属性转换为getter、setter，从而让data的属性能够响应数据变化。  data：数据 data选项表示：当前Vue实例可以使用的数据 data选项的值：对象，对象中可以定义多个数据 js中获取data数据：vm.$data.name、vm.name   methods定义方法：  method：方法，为啥加s，因为可以有多个方法 methods选项表示：当前Vue实例可以用到的方法 methods选项的值：对象，对象中定义方法   computed计算属性：计算属性结果会被缓存起来，当依赖的响应式属性发生变化时，才会重新计算，返回最终结果。  computed：计算 computed选项表示：当前Vue实例可以用到的计算属性 computed选项的值：对象，对象中定义方法 应用场景：当有些数据需要随着其他数据变动而变动时，就需要使用computed计算数学；一般处理计算逻辑 注意：计算属性，定义时是一个方法，但是当属性使用（所以才叫计算属性）；计算属性需要将结果放回；计算属性具有缓存，这就意味着只要计算属性的依赖没有进行相应的数据更新，那么computed会直接从缓存中获取值，多次访问都会返回之前的计算结果   watch状态监听：用来检测Vue实例中的数据变动  watch：观察、检测 watch选项表示：检测data选项中的数据变化 watch选项的值：对象，对象中定义方法 应用场景：要在数据变化同时进行异步操作或者是比较大的开销时使用 注意：watch是检测data的数据变化，watch的方法必须与data的属性名一致   filter过滤器：对数据进行格式化，比如字符串字母变大写，日期格式化等。  filter：过滤器 filters选项表示：对data选项中的数据进行格式化 filters选项的值：对象，对象中定义方法 应用场景：对数据格式化（字符串中首字母大写，字符串大小写转换、日期格式化） 注意：过滤器函数，必须定义一个参数，此参数就是使用过滤器的数据，将格式化的结果返回 使用过滤器：插值表达式使用：{{data属性名 | 过滤器名称}}或属性绑定使用 v-bind=\u0026quot;{{data属性名 | 过滤器名称}}\u0026quot;    2.Vue数据绑定   绑定样式：内联样式和绑定样式\n 绑定行内样式style  绑定对象语法：v-bind:style=\u0026quot;{backgroundColor:pink, width:width, height:height} 绑定数组语法：v-bind:style=\u0026quot;[myDiv, xxx]\u0026quot;，数组中是一个一个的样式对象，如果只绑定一个对象中括号可以省略 上述语法中：pink，width，myDiv均为data数据 为什么要进行样式绑定：绑定之后可以通过操作data数据来改变样式，理解为绑定样式就是为了操作样式   绑定类样式class  绑定对象语法：v-bind:class=\u0026quot;{box}\u0026quot;,data中需要有一个属性：box:\u0026ldquo;box\u0026rdquo;,这里的大括号可以省略 绑定数组语法：v-bind:class=\u0026quot;[box1,box2]\u0026quot;      内置指令\n  常用内置指令：\n   路径 说明     v-model 双向数据绑定   v-on 监听事件   v-bind 单向事件绑定   v-text 插入文本内容   v-html 插入包含html的内容   v-for 列表渲染   v-if 条件渲染   v-show 显示隐藏      详解\n v-model  v-model主要实现数据双向绑定，通常用在表单元素上，例如input、textarea、select等 双向数据绑定：数据改变影响界面，界面改变影响数据   v-text指令：  v-text是在DOM元素内部插入文本内容，类似于之前的innerText，理解：v-text是将元素内部文本与data属性进行数据绑定 这个实现的是单项绑定：数据改变影响界面，处理v-model其他的数据绑定都是单向的   v-html指令：  v-html是在DOM元素内部插入HTML内容，类似于之前的innerHTML，理解：v-text是将元素内部HTML与data属性进行单向数据绑定   v-bind指令：  v-bind可以实现属性单向数据绑定 目的是为了操作DOM元素的属性   v-on指令：  v-on是事件监听指令，负责给DOM元素绑定事件，配合事件类型使用 语法：v-on:事件名 = \u0026ldquo;事件处理程序\u0026rdquo;   v-for指令：  v-for可以实现页面列表渲染，常用来循环数组 语法：v-for = \u0026ldquo;(value, key) in xxx\u0026rdquo;;   v-if和v-show指令：  用来控制元素显示或隐藏，属性为布尔值 语法：v-if=\u0026ldquo;isShow\u0026rdquo;，isShow是data中的一个布尔类型数据 区别：v-if控制元素是否渲染，v-show控制元素是否显示，操作display属性        3.Vue事件   事件监听：在Vue中可使用内置指令v-on监听DOM事件，并在触发时运行一些Javascript代码，或绑定事件处理方法。\n  语法：v-on:事件名 = \u0026ldquo;事件函数\u0026rdquo;；v-on:事件名 = \u0026ldquo;js代码\u0026rdquo;\n  按键修饰符\n 监听哪个键盘/抬起 v-on:keyup.案件修饰符 = \u0026lsquo;xxx\u0026rsquo; 案件修饰符其实就是按键名，代表监听哪个按键    事件修饰符\n常用事件修饰符：\n   修饰符 说明     .stop 阻止事件冒泡（如:阻止点击子元素触发父元素的点击事件）   .prevent 阻止默认事件行为（a标签单击的默认跳转）   .capture 事件捕获（如：先执行父元素的点击事件再执行子元素的点击事件）   .self 将事件绑定到自身，只有自身才能触发（不能冒泡触发）   .once 事件只触发一次      4.Vue组件   什么是组件\n  组件是构成页面中独立结构单元，组件主要以页面结构形式存在，不同组件也具有基本交互功能\n  组件理解为自定义标签即可，可以是一个标签组成，也可以是多个标签组成\n  组件的定义：Vue.component(id, [definition]);\n参数id：组件名称\n参数[definition]：组件配置对象，包括data、template\n    局部注册组件\n 局部组件，通过components选项来定义 全局组件与局部组件的区别  全局组件再项目中的任何界面都可以使用 局部组件只能在当前界面中使用      template模板\n Vue提供了template标签，可以编写组件的结构 优势  改善开发体验：之前的组件模板都是直接以字符串形式书写，这种方式很容易出错 有代码提示，代码高亮，提高开发效率      组件之间数据传递：在Vue开发中，我们会使用大量的组件，所以会存在组件嵌套的情况，那么子组件之间经常需要传递数据\n props传值  props：properties：意为通过属性传智 这种方式是父组件向子组件传值  my-parent是父组件 template中的标签就是子组件 父组件在使用的时候，通过属性，给子组件div传递值     $emit传值  emit：发射，理解为触发 Vue实例中提供了一个$emit方法，专门用于触发自定义事件的执行      组件切换\n 通过v-if和v-else来控制是否显示组件    5.Vue生命周期  钩子函数：钩子函数用来描述Vue实例从创建到销毁的整个生命周期  Vue生命周期：Vue从创建到销毁的整个过程 在生命周期过程中，会执行很多回调函数，这些回调函数叫钩子函数   实例创建  beforeCreate:创建实例对象之前执行，【此时数据不能使用】 created:建实例对象之后执行，【此时数据可以使用】   页面挂载  beforeMount:页面挂载成功之前执行，【无法展示数据】 Mounted: 页面挂载成功之后执行，【可以展示数据】   数据更新  beforeUpdate:组件更新之前执行，【数据更新之前】 update:组件更新之后执行，【数据更新之后】   实例销毁  beforeDestroy:实例销毁之前执行，【可以操作DOM】 destroyed:实例销毁之后执行，【无法操作DOM】    Vue开发基础下 1.全局API   Vue.directive\n  用来注册指令\n  注册语法\nVue.directive(\u0026#39;focus\u0026#39;, { inserted(el, binding){ if(binding.value){ el.focus(); } } }) 参数1：自定义指令的名称\n参数2：配置对象\n 配置对象中使用inserted函数处理 inserted函数：会在使用指令的元素被插入到DOM中的时候被带哦用 inserted参数el：使用指令的元素 inserted参数binding：指令相关的配置    使用：\n\u0026lt;div\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; v-foucs/\u0026gt; \u0026lt;/div\u0026gt;     Vue.use\n  用于给Vue安装插件\n  自定义插件\n//定义一个MyPlugin(自定义插件)对象 let MyPlugin = {};   安装插件\n//编写插件对象的install方法 MyPlugin.install = function (Vue, options) { console.log(options); //在插件中为Vue添加自定义指令  Vue.directive(\u0026#39;my-directive\u0026#39;, { bind(el, binding) { //为自定义指令v-my-directive绑定的DOM元素设置style样式  el.style = \u0026#34;width:100px; height:100px; background-color:#ccc;\u0026#34;; } }); } Vue.use(MyPlugin, { options: true });   使用插件中的指令\n\u0026lt;div id=\u0026#34;app\u0026#34; v-my-directive\u0026gt;\u0026lt;/div\u0026gt;     Vue.extend\n  用于创建Vue的子类，对Vue进行扩展\n  创建子类\nVue2 = Vue.extend({ data() { return { title: \u0026#39;hello，我是vue的子类\u0026#39; } } }) 这个Vue2子类中，默认携带title数据\n  使用子类：\nvar vm = new Vue2({ el: \u0026#39;#app2\u0026#39;, }); \u0026lt;div id=\u0026#34;app2\u0026#34;\u0026gt; app2:{{title}} \u0026lt;/div\u0026gt;     Vue.set\n  用于响应式对象中增加新属性，确保属性也具备响应式特点\n  语法：Vue.set(target, key, value)\n target：要更改的数据源（可以是对象或者数组） key：要更改或新增的属性 value：新值    代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { a: \u0026#34;我是根级响应式属性a\u0026#34;, obj: {} } }); Vue.set(vm.obj, \u0026#39;b\u0026#39;, \u0026#39;我是Vue.set添加的响应式的属性b\u0026#39;)   注意\n data中的根数据是响应式的：a和obj 如果是新增加的obj的属性，这个属于二级数据，而新增加的二级数据默认不是响应式的，即直接通过vm.obj.b=\u0026ldquo;我是xxx\u0026rdquo;，是无法做到响应的 通过Vue.set添加的二级数据可以是响应式的      Vue.mixin\n  mix：混合，in：进入，minxin：混入\n  Vue.mixin：用于给Vue增加混入对象\n  理解：在Vue中混进去一个拓展的对象，增加功能\n  定义混入：\nVue.mixin({ //混入对象可以有组件的选项  data() { return { msg: \u0026#39;混入的数据\u0026#39; } }, created() { console.log(\u0026#34;混入的created\u0026#34;); var myOption = this.$options.myOption; if (myOption) { console.log(myOption.toUpperCase()); } }, })   Vue实例化：\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, myOption: \u0026#39;hello vue！\u0026#39;, data: { title: \u0026#39;我是title\u0026#39; }, created() { console.log(\u0026#34;Vue的created钩子函数\u0026#34;); }, });     2.实例属性   vm.$props\n  用于接受父组件向子组件传递的数据\n  代码：\nVue.component(\u0026#39;my-child\u0026#39;, { props: [\u0026#34;name\u0026#34;], watch: { name() { var brand = this.$props.name; var found = false; this.content.forEach((value, index) =\u0026gt; { if (value.brand == brand) { found = value; } }); this.show = found ? found : { brand: \u0026#39;\u0026#39;, type: \u0026#39;\u0026#39;, price: \u0026#39;\u0026#39; } } }  props定义可以通过name传递数据 然后在方法或watch中可以通过this.$props.name获取name属性 其实也可以通过this.name直接获取      vm.$options\n  用于获取Vue实例化时传入的选项的值\n  代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, customOption: \u0026#39;我是自定义数据\u0026#39;, data: { base: \u0026#34;我是data里的基础数据\u0026#34; }, created() { this.noBase = this.$options.customOption; }, }); \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{base}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{noBase}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;     vm.$el\n  用于获取Vue绑定的根元素\n  代码\nvar vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {} }); vm.$el.innerHTML = \u0026#34;\u0026lt;div\u0026gt;我是替换后的div标签\u0026lt;/div\u0026gt;\u0026#34; 通过vm.$el修改根元素的内部标签\n    vm.$children\n  用于获取当前实例的直接子组件\n  什么是直接子组件\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;child\u0026#34;\u0026gt;查看子组件\u0026lt;/button\u0026gt; \u0026lt;my-componet\u0026gt;\u0026lt;/my-componet\u0026gt; \u0026lt;/div\u0026gt; 在app根元素下的my-componet就是直接子组件\n  通过vm.$children可以获取到my-componet\n    vm.$root\n  用于获取当前组件树的根Vue实例\n  组件实例对象和Vue实例对象都有$root属性\n  代码\nVue.component(\u0026#39;my-component\u0026#39;, { template: \u0026#39;\u0026lt;button @click=\u0026#34;root\u0026#34;\u0026gt;查看根实例\u0026lt;/button\u0026gt;\u0026#39;, methods: { root() { console.log(this.$root); console.log(this.$root == vm.$root); } } })     vm.$slot\n  用于获取插槽\n  插槽是用于父组件向子组件传递内容\n  代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt;你好\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#39;first\u0026#39;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 插槽：用于接受自定义组件的内容 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 获取插槽的内容：vm.$children[0].slots.default[0].text\n    vm.$attrs\n  用于获取组件的属性，但不包含class、style以及被声明为props的属性\n  定义属性\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt;   获取属性\nVue.component(\u0026#39;my-component\u0026#39;, { template: \u0026#39;\u0026lt;button @click=\u0026#34;showAttrs\u0026#34;\u0026gt;查看属性\u0026lt;/button\u0026gt;\u0026#39;, methods: { showAttrs() { console.log(this.$attrs); } }, })     3.全局配置   productionTip\n  用于配置是否显示生产信息提示，默认打开\n  关闭生产信息提示：\nVue.config.productionTip = false   productionTip：生产信息提示\n    silent\n  用于配置是否显示Vue日志和警告，默认打开\n  关闭日志和警告：\nVue.config.silent = true   slient：沉默的\n  注意：配置要写在Vue实例的上方，在Vue实例下方不生效\n    devtools\n  用于配置是否允许使用开发工具调试代码，默认允许\n  关闭调试\nVue.config.devtools = false   devtools: development tools, 开发工具\n    4.组件进阶   mixins\n  用于注册混入对象，混入对象：包含公共的方法或者数据，计算属性等，然后混入到多个组件中使用，方便管理与统一修改\n  定义混入对象并注册\nvar myMixin = { data() { return { message: \u0026#39;mixin的数据\u0026#39; } } } var vm = new Vue({ data: { message: \u0026#39;Vue的数据\u0026#39; }, mixins: [myMixin], created() { console.log(this.message); } })     render\n  实现对虚拟DOM的操作，通过JS来渲染界面元素\n  代码\nrender(createElement) { return createElement(\u0026#39;p\u0026#39;, { style: { color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;16px\u0026#39;, backgroundColor: \u0026#39;#eee\u0026#39; } }, this.$slots.default); },   说明\n render是一个函数，他作为一个选项存在，可以在Vue和组件中使用这个选项 render的参数：createElment是一个用于创建元素的函数      createElement\n  用于创建元素\n  说明\ncreateElement，createElement()函数返回的并不是一个实际的DOM元素，\n他返回的其实是一个描述节点(createNodeDescription)。\n 第1个参数可以是一个HTML标签名或组件选项对象 第2个参数是可选的，可以传入一个与模板中属性对应的数据对象。 第3个参数是由createElement()构建而成的子级虚拟节点，也可以使用字符串来生成文本虚拟节点。      ","permalink":"https://rex0520.github.io/posts/front/vue/vue%E5%9F%BA%E7%A1%80/","summary":"Vue基础 初始Vue 前端技术的发展   HTML：用于编写网页的结构\n  CSS：用于美化网页\n  JS：用于处理页面的交互效果\n  JQuery：JS的升级版，代码简洁，更高效的开发项目\n  Vue：采用虚拟DOM技术，代码更加简洁\n虚拟DOM技术\n 和真实DOM结构类似的JS对象 可以提高浏览器的渲染速度    什么是Vue   一条基于构建用户界面的渐进式框架\n 渐进式理解：Vue提供的一系列技术，可以渐渐的，一步一步的使用这个框架 框架理解：解决一类问题的解决方案，理解为工具    Vue的数据绑定基于MVVM设计思想\nMVVM：Model，View，ViewModel\n可以将模型数据与视图连接起来\n 模型数据变化会影响视图 视图数据变化会影响模型    Vue的优势  轻量级：Vue简单、直接，所以Vue使用起来更加友好 数据绑定：数据驱动视图，视图也可以驱动数据 指令：指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为 插件：插件用于对Vue框架功能进行扩展  Vue、Angular和React的区别：  Angular相对Vue学习成本高，更复杂，性能稍差 React采用了特殊的JSX语法，Vue中推崇编写以*.vue后缀命名的文件格式  Vue开发基础上 1.Vue实例   说明\n  Vue实例：通过new关键字实例化Vue({})构造函数\n  实例化Vue时的参数内的属性，我们称之为选项：\n       选项 说明     data Vue实例数据对象   methods 定义Vue实例中的方法   component 定义子组件   computed 计算属性   filters 过滤器   el 唯一根元素   watch 监听数据变化    el唯一根标签：在创建Vue实例时，el表示唯一根标签，通过指定class或id选择器可用来将页面结构与Vue实例对象vm进行绑定。  el：element，元素 el选项表示：当前Vue实例绑定的页面怨怒是 绑定的这个元素，作为Vue实例在界面上的元素 el选项的值：“id或类选择器” 注意：Vue的数据只能在el绑定的元素内部使用   data初始数据：Vue实例的数据对象为data，Vue会将data的属性转换为getter、setter，从而让data的属性能够响应数据变化。  data：数据 data选项表示：当前Vue实例可以使用的数据 data选项的值：对象，对象中可以定义多个数据 js中获取data数据：vm.","title":"Vue基础"},{"content":"Lambda表达式 什么是Lambda表达式  JDK8开始支持Lambda表达式，用来让程序编写更优雅 利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 基于Lambda提供stream流式处理极大简化对集合的操作  Lambda表达式语法格式： 说明： 代码示例：  MathOperation.java\npackage com.imooc.lambda; /** * 四则运算接口 * @author CubeMonkey * @create 2020-10-23 17:39 */ @FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查 public interface MathOperation { public Float operate(Integer a, Integer b); } LambdaSample.java\npackage com.imooc.lambda; /** * @author CubeMonkey * @create 2020-10-23 17:42 */ public class LambdaSample { public static void main(String[] args) { //1.标准的使用方式  //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口，Java称为\u0026#34;函数式接口\u0026#34;  MathOperation addition = (Integer a, Integer b)-\u0026gt;{ System.out.println(\u0026#34;加法运算\u0026#34;); return a+b+0f; }; System.out.println(addition.operate(5, 3)); //2.Lambda允许忽略参数类型  MathOperation substraction = (a, b)-\u0026gt;{ return a - b + 0f; }; System.out.println(substraction.operate(5, 3)); //3.单行实现代码可以省略大括号和return  MathOperation multiplication = (a, b) -\u0026gt; a*b+0f; System.out.println(multiplication.operate(5, 3)); //test  MathOperation division = (a, b) -\u0026gt;{ System.out.println(\u0026#34;除法运算\u0026#34;); return a * 1.0f / b; }; System.out.println(division.operate(5, 3)); } }  函数式编程 什么是函数式编程  函数式编程是基于函数式接口并使用lambda表达的编程方式 函数式编程理念是将代码作为可重用数据带入到程序中 函数式编程强调“你想做什么”，而不是“你想怎么做”  什么是函数式接口  函数式接口是有且只有一个抽象方法的接口 Java中拥有大量函数式接口，如java.lang.Runnable JDK8后提供了一系列新的函数式接口，位于java.util.function  JDK8常用函数式接口    接口 用途     Consumer 对应一个输入参数无输出的功能代码   Function\u0026lt;T, R\u0026gt; 对应一个输入参数且需要返回数据的功能代码   Predicate 用于条件判断，固定返回布尔值    一、函数式接口Predicate 说明：  Predicate是新增的函数式接口，位于java.util.function Predicate用于测试传入的数据是否满足判断要求 Predicate接口需要实现test()方法进行逻辑判断  代码示例： package com.imooc.lambda; import java.util.Arrays; import java.util.List; import java.util.function.Predicate; /** * 理解函数式编程 * Predicate函数式接口的使用方法 * @author CubeMonkey * @create 2020-10-23 18:20 */ public class PredicateSample { public static void main(String[] args) { Predicate\u0026lt;Integer\u0026gt; predicate = n-\u0026gt;n\u0026lt;4; boolean result = predicate.test(10); System.out.println(result); List\u0026lt;Integer\u0026gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); /*for (Integer num:list){ if (num % 2 == 1){ System.out.println(num); } }*/ filter(list, n -\u0026gt; n % 2 == 1);//取所有奇数  filter(list, n -\u0026gt; n % 2 == 0);//取所有偶数  filter(list, n -\u0026gt; n \u0026gt; 5 \u0026amp;\u0026amp; n % 2 == 0);//取所有大于5的偶数  } public static void filter(List\u0026lt;Integer\u0026gt; list, Predicate\u0026lt;Integer\u0026gt; predicate){ for (Integer num:list){ if (predicate.test(num)){ System.out.print(num+\u0026#34; \u0026#34;); } } System.out.println(); } } 二、函数式接口Consumer 代码示例： package com.imooc.lambda; import java.util.function.Consumer; /** * Consumer接口的使用 * @author CubeMonkey * @create 2020-10-23 18:57 */ public class ConsumerSample { public static void main(String[] args) { output(s-\u0026gt;System.out.println(\u0026#34;向控制台打印：\u0026#34; + s)); output(s-\u0026gt;{ System.out.println(\u0026#34;向xxx网站发送数据包：\u0026#34;+s); }); } public static void output(Consumer\u0026lt;String\u0026gt; consumer){ String text = \u0026#34;天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为。\u0026#34;; consumer.accept(text); } } 三、函数式接口Function 代码示例： package com.imooc.lambda; import java.util.Random; import java.util.function.Function; /** * 利用Function函数式接口生成定长随机字符串 * @author CubeMonkey * @create 2020-10-23 19:07 */ public class FunctionSample { public static void main(String[] args) { Function\u0026lt;Integer, String\u0026gt; randomStringFunction = l -\u0026gt; { String chars = \u0026#34;abcdefhigklmnopqrstuvwxyz0123456789\u0026#34;; StringBuffer stringBuffer = new StringBuffer(); Random random = new Random(); for (int i = 0; i \u0026lt; l; i++) { int position = random.nextInt(chars.length()); stringBuffer.append(chars.charAt(position)); } return stringBuffer.toString(); }; System.out.println(randomStringFunction.apply(32)); } } 面向函数式编程与面向对象编程比较     面向对象编程 函数式编程     设计思路 面向对象 面向过程   开发侧重 侧重过程，重分析，重设计 侧重结果，快速实现   可读性 结构复杂，相对较差 更适合人眼阅读，可读性更好   代码量 多 少   并发问题 设计不当，会出现线程安全问题 不会出现线程安全问题   健壮性 好 差   使用场景 中大型项目，多人协作工程 小型应用，要求快速实现    Stream流式处理 什么是Stream流式处理  Stream流式处理是建立在Lambda基础上的多数据处理技术 Stream对集合数据处理进行高度抽象，极大简化代码量 Stream可对集合进行迭代，去重，筛选，排序，聚合等一系列处理  Stream常用方法    接口 用途     forEach 循环遍历   map map方法用于映射每个元素对应的结果   filter filter方法用于通过设置的条件过滤出元素   limit limit方法用于获取指定数量的流   sorted sorted方法用于对流进行排序   Collectors Collectors类实现将流转换成集合和聚合元素    Stream流的五种创建方式 package com.imooc.stream; import org.junit.Test; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.stream.IntStream; import java.util.stream.Stream; /** * Stream流对象的五种创建方式 * @author CubeMonkey * @create 2020-10-23 19:50 */ public class StreamGenerator { //基于数组进行创建  @Test public void generator1(){ String[] arr = {\u0026#34;Lily\u0026#34;, \u0026#34;Andy\u0026#34;, \u0026#34;Jackson\u0026#34;, \u0026#34;Smith\u0026#34;}; Stream\u0026lt;String\u0026gt; stream = Stream.of(arr); stream.forEach(s-\u0026gt; System.out.println(s)); } //2.基于集合进行创建  @Test public void generator2(){ List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Lily\u0026#34;); list.add(\u0026#34;Andy\u0026#34;); list.add(\u0026#34;Jackson\u0026#34;); list.add(\u0026#34;Smith\u0026#34;); Stream\u0026lt;String\u0026gt; stream = list.stream(); stream.forEach(s-\u0026gt; System.out.println(s)); } //3.利用generate方法创建无限长度流  @Test public void generator3(){ Stream\u0026lt;Integer\u0026gt; stream = Stream.generate(() -\u0026gt; new Random().nextInt(100000)); stream.limit(10).forEach(i-\u0026gt; System.out.println(i)); } //4.基于迭代器创建流  @Test public void generator4(){ Stream\u0026lt;Integer\u0026gt; stream = Stream.iterate(1, n -\u0026gt; n + 1); stream.limit(100).forEach(i-\u0026gt; System.out.println(i)); } //5.基于字符序列创建流  @Test public void generator5(){ String str = \u0026#34;abcdefg我的\u0026#34;; IntStream stream = str.chars(); stream.forEach(c-\u0026gt; System.out.println(c)); } } Stream常用方法代码示例 package com.imooc.stream; import org.junit.Test; import java.util.Arrays; import java.util.List; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Stream; /** * @author CubeMonkey * @create 2020-10-23 20:29 */ public class StreamMethod { //提取集合中所有偶数并求和  @Test public void case1(){ List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;); int sum = list.stream()//获取stream对象  .mapToInt(s -\u0026gt; Integer.parseInt(s)) //mapToInt将流中每一个数据转为整数  .filter(num -\u0026gt; num % 2 == 0)//filter对流数据进行过滤  .sum();//求和  System.out.println(sum); } //所有名字首字母大写  @Test public void case2(){ List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;lily\u0026#34;, \u0026#34;smith\u0026#34;, \u0026#34;jackson\u0026#34;); Stream\u0026lt;String\u0026gt; stream = list.stream(); //按规则对每一个流进行转化  List\u0026lt;String\u0026gt; collect = stream.map(s -\u0026gt; s.substring(0, 1).toUpperCase() + s.substring(1)) //collect对流数据进行收集，生成新的List/Set  .collect(Collectors.toList()); for (String s : collect) { System.out.println(s); } } //将所有奇数从大到小进行排序，且不许出现重复  @Test public void case3(){ List\u0026lt;Integer\u0026gt; list = Arrays.asList(1, 60, 38, 21, 51, 60, 51, 73); List\u0026lt;Integer\u0026gt; newList = list.stream().filter(num -\u0026gt; num % 2 == 1) .distinct() .sorted((a, b) -\u0026gt; b - a) .collect(Collectors.toList()); System.out.println(newList); } } ","permalink":"https://rex0520.github.io/posts/back/java/lambda/","summary":"Lambda表达式 什么是Lambda表达式  JDK8开始支持Lambda表达式，用来让程序编写更优雅 利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 基于Lambda提供stream流式处理极大简化对集合的操作  Lambda表达式语法格式： 说明： 代码示例：  MathOperation.java\npackage com.imooc.lambda; /** * 四则运算接口 * @author CubeMonkey * @create 2020-10-23 17:39 */ @FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查 public interface MathOperation { public Float operate(Integer a, Integer b); } LambdaSample.java\npackage com.imooc.lambda; /** * @author CubeMonkey * @create 2020-10-23 17:42 */ public class LambdaSample { public static void main(String[] args) { //1.标准的使用方式  //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口，Java称为\u0026#34;函数式接口\u0026#34;  MathOperation addition = (Integer a, Integer b)-\u0026gt;{ System.","title":"Lambda(java)"},{"content":"Maven入门 Maven介绍  Maven是项目管理工具，对软件项目提供构建与依赖管理 Maven是Apache下的Java开源项目 Maven为Java项目提供了统一的管理方式，已成为业界标准  解决了的问题  工程的结构不统一 第三方jar包多的时候，不便于管理 工程打包的困难  Maven核心特性  项目设置遵循统一的规则，保证不同开发环境的兼容性 强大的依赖管理，项目依赖组件自动下载、自动更新 可扩展的插件机制，使用简单，功能丰富  Maven的坐标： GroupId：机构或者团队的英文，采用\u0026quot;逆向域名\u0026quot;形式书写 ArtifactId：项目名称，说明其用途，例如：cms(内容管理系统)，oa(办公自动化系统) Version：版本号，一般采用“版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构    目录 用途     ${basedir} 根目录，用于保存pom.xml   ${basedir}/src/main/java Java源代码目录   ${basedir}/src/main/resources 资源目录，保存配置文件、静态图片等   ${basedir}/src/test/java 测试类的源代码   ${basedir}/src/test/resources 测试时需要使用的资源文件   ${basedir}/target 项目输出的目录，用于存储jar、war文件   ${basedir}/target/classes 字节码(.class)的编译输出目录   ${basedir}/pom.xml 项目(Project)对象(Object)模型(Model)文件    Maven的依赖管理 说明  Maven利用dependency(依赖)自动下载、管理第三方Jar 在pom.xml文件中配置项目依赖的第三方组件 maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用  获取 apache：https://search.maven.org/\n阿里云：https://maven.aliyun.com/mvn/search\n本地仓库与中央仓库  使用代理：\n \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!-- 创建私服的地址 --\u0026gt; \u0026lt;id\u0026gt;aliyun\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 普通项目的创建与打包案例（实现中文与拼音的转化） 创建\u0026amp;使用：   新建一个Maven项目，默认的jdk是1.5，将jdk的版本调整为1.8\n  配置第三方组件，使得maven自动从远程仓库中下载第三方jar包到本地仓库\n 核心语句\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.belerweb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pinyin4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;    创建简单的java文件\n PinyinTestor.java\npublic class PinyinTestor { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String str = scanner.nextLine(); String[] pinyin = PinyinHelper.toHanyuPinyinStringArray(str.charAt(0)); for(String py:pinyin) { System.out.println(py); } } }    运行main方法\n   打包   在pom.xml配置文件中，根目录下配置打包的信息，使用maven-assemble-plugin插件进行打包输出\n\u0026lt;build\u0026gt; \u0026lt;!-- 配置插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 经典版本 --\u0026gt; \u0026lt;version\u0026gt;2.5.5\u0026lt;/version\u0026gt; \u0026lt;!-- 用于说明打包过程中的一些细节 --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 指定项目的入口类 --\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;com.imooc.maven.PinyinTestor \u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;!-- 描述符引用 打包过程中所用到的参数 --\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;!-- all in one, 在打包时会将所有引用的jar包合并到jar文件中 --\u0026gt;\t\u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   运行assembly插件，输出合并的jar文件\n  用命令行执行输出的jar包\n  Web项目的创建与打包案例 创建\u0026amp;使用   配置好tomcat，创建一个普通的Maven项目，默认的jdk是1.5，将jdk的版本调整为1.8\n  进入项目的配置信息，配置java的编译级别为jdk1.8\n  在src/main目录下创建一个文件夹，名为webapp\n  将maven工程变成标准的web项目，打开该工程的属性配置页面，选择Project Facets，点击Convert to facted from\u0026hellip;开启项目模块的面板，选择版本为3.1，并指定运行环境，不要直接点击apply and close，还没完\n  点击图中出现的Further configuration available\u0026hellip;，设置content directory为src/main/webapp，勾选配置xml文件\n  再在右侧找到deployment assembly，添加maven的依赖，否则在maven加入的jar包会失效\n  在创建的webapp文件夹中出现MATE-INF和WEB-INF目录说明，已经成功将普通的maven工程变为标准的web工程\n  在webapp文件夹下创建一个index.jsp ， 在里面写如this is a maven project!!!\n  将当前工程发布到tomcat下运行\n  在浏览器的url中输入http:localhost:8080/web-maven/， 在页面上显示this is a maven project!!!\n​\t  打包   在pom.xml文件的根目录中编写配置war包的信息\n\u0026lt;!-- packaging代表输出的格式，默认的是jar包 --\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!-- 输出的war包名 --\u0026gt; \u0026lt;finalName\u0026gt;web-maven\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   运行maven中的插件\n  点击run\n  将生成的war包放在tomcat的webapp目录下，运行tomcat bin目录下的startup.bat文件，在浏览器中输入http:localhost:8080/web-maven/\n  Maven常用命令    命令 用途     mvn archetype:generate 创建工程结构   mvn compile 编译源代码   mvn test 执行测试用例   mvn clean 清除产生的项目   mvn package 项目打包   mvn install 安装至本地仓库    ","permalink":"https://rex0520.github.io/posts/back/maven/maven%E5%9F%BA%E7%A1%80/","summary":"Maven入门 Maven介绍  Maven是项目管理工具，对软件项目提供构建与依赖管理 Maven是Apache下的Java开源项目 Maven为Java项目提供了统一的管理方式，已成为业界标准  解决了的问题  工程的结构不统一 第三方jar包多的时候，不便于管理 工程打包的困难  Maven核心特性  项目设置遵循统一的规则，保证不同开发环境的兼容性 强大的依赖管理，项目依赖组件自动下载、自动更新 可扩展的插件机制，使用简单，功能丰富  Maven的坐标： GroupId：机构或者团队的英文，采用\u0026quot;逆向域名\u0026quot;形式书写 ArtifactId：项目名称，说明其用途，例如：cms(内容管理系统)，oa(办公自动化系统) Version：版本号，一般采用“版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构    目录 用途     ${basedir} 根目录，用于保存pom.xml   ${basedir}/src/main/java Java源代码目录   ${basedir}/src/main/resources 资源目录，保存配置文件、静态图片等   ${basedir}/src/test/java 测试类的源代码   ${basedir}/src/test/resources 测试时需要使用的资源文件   ${basedir}/target 项目输出的目录，用于存储jar、war文件   ${basedir}/target/classes 字节码(.class)的编译输出目录   ${basedir}/pom.xml 项目(Project)对象(Object)模型(Model)文件    Maven的依赖管理 说明  Maven利用dependency(依赖)自动下载、管理第三方Jar 在pom.","title":"Maven基础"},{"content":"MyBatis基础入门 软件开发中的框架  框架是可被应用开发者定制的应用骨架 框架是一种规则，保证开发者遵循相同的方式开发程序 框架提倡“不要重复造轮子”，对基础功能进行封装  框架的优点  极大提高了开发效率 统一的编码规则，有利于团队管理 灵活配置的应用，拥有更好的维护性  SSM开发框架  S -\u0026gt; Spring S -\u0026gt; Spring MVC M -\u0026gt; MyBatis  什么是MyBatis  MyBatis是优秀的持久层框架 MyBatis使用XML将SQL与程序解耦，便于维护 MyBatis学习简单，执行高效，是JDBC的延展  MyBatis开发流程  引入MyBatis依赖 创建核心配置文件 创建实体(Entity)类 创建Mapper映射文件 初始化SessionFactory 利用SqlSession对象操作数据  MyBatis环境配置 mybatis-config.xml说明  MyBatis采用XML格式配置数据库环境信息 MyBatis环境配置标签 environment包含数据库驱动、URL、用户名于密码  mybatis-config.xml示例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--根据环境，不同的环境不同的id，dev-\u0026gt;开发环境 prd-\u0026gt;生产环境 --\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--数据连接方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;environment id=\u0026#34;prd\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--数据连接方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://192.168.1.1:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 创建SqlSession SqlSessionFactory  SqlSessionFactory是MyBatis的核心对象 用于初始化MyBatis，创建SqlSession对象 保证SqlSessionFactory在应用中全局唯一  SqlSession  SqlSession是MyBatis操作数据库的核心对象 SqlSession使用JDBC方式与数据库交互 SqlSession对象提供了数据表CRUD对应方法  示例代码 package com.imooc.mybatis; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.Reader; import java.sql.Connection; /** * JUNIT单元测试类 * @author CubeMonkey * @create 2020-10-27 10:21 */ public class MyBatisTestor { @Test public void testSqlSessionFactory() throws IOException { //利用Reader加载classpath下的mybatis-config.xml核心配置文件  Reader reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); //初始化SqlSessionFactory对象，同时解析mybatis-config.xml文件  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = null; try { //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互  sqlSession = sqlSessionFactory.openSession(); //创建数据库连接（测试用）  Connection conn = sqlSession.getConnection(); System.out.println(conn); }catch (Exception e){ e.printStackTrace(); } finally { if (sqlSession != null) { //如果type=\u0026#34;POOLED\u0026#34;, 代表使用连接池，close则是将连接回收到连接池中  //如果type=\u0026#34;UNPOOLED\u0026#34;,代表直连，close则会调用Connection.close()方法关闭连接  sqlSession.close(); } } } } 初始化工具类MyBatisUtils MyBatisUtils代码示例： package com.imooc.mybatis.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.Reader; /** * MyBatisUtils工具类，创建全局唯一的SqlSessionFactory对象 * @author CubeMonkey * @create 2020-10-27 10:51 */ public class MyBatisUtils { //利用static(静态)属于类不属于对象，且全局唯一  private static SqlSessionFactory sqlSessionFactory = null; //利用静态代码块在初始化类时实例化sqlSessionFactory  static{ Reader reader = null; try { reader = Resources.getResourceAsReader(\u0026#34;mybatis-config.xml\u0026#34;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); } catch (IOException e) { e.printStackTrace(); //初始化错误时，通过抛出异常ExceptionInitializerError通知调用者  throw new ExceptionInInitializerError(e); } } /** * openSession 创建一个新的SqlSession对象 * @return SqlSession对象 */ public static SqlSession openSession(){ return sqlSessionFactory.openSession(); } /** * 释放一个有效的SqlSession对象 * @param sqlSession 准备释放sqlSession对象 */ public static void closeSession(SqlSession sqlSession){ if (sqlSession != null){ sqlSession.close(); } } } MyBatisUtils工具类使用实例：\n@Test public void testMyBatisUtils(){ SqlSession sqlSession = null; try { sqlSession = MyBatisUtils.openSession(); Connection conn = sqlSession.getConnection(); System.out.println(conn); }catch (Exception e){ e.printStackTrace(); }finally { MyBatisUtils.closeSession(sqlSession); } } MyBatis数据查询 简单查询 MyBatis数据查询步骤  创建实体类(Entity) 创建Mapper Xml 编写SQL标签 开启驼峰命名映射 新增 SqlSession执行select语句  示例：   创建实体类\n Goods.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 11:28 */ public class Goods { private Integer goodsId;//商品编号  private String title;//标题  private String subTitle;//子标题  private Float originalCost;//原始价格  private Float currentPrice;//当前价格  private Float discount;//折扣率  private Integer isFreeDelivery;//是否包邮，1-包邮 0-不包邮  private Integer categoryId;//分类编号  public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.goodsId = goodsId; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getSubTitle() { return subTitle; } public void setSubTitle(String subTitle) { this.subTitle = subTitle; } public Float getOriginalCost() { return originalCost; } public void setOriginalCost(Float originalCost) { this.originalCost = originalCost; } public Float getCurrentPrice() { return currentPrice; } public void setCurrentPrice(Float currentPrice) { this.currentPrice = currentPrice; } public Float getDiscount() { return discount; } public void setDiscount(Float discount) { this.discount = discount; } public Integer getIsFreeDelivery() { return isFreeDelivery; } public void setIsFreeDelivery(Integer isFreeDelivery) { this.isFreeDelivery = isFreeDelivery; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } }    创建Mapper Xml\n  编写SQL标签\n resources/mappers/goods.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goods\u0026#34;\u0026gt; \u0026lt;!--resultType-\u0026gt;返回的数据类型 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods order by goods_id desc limit 10 \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;    开启驼峰命名映射\n 在mybatis-config.xml中的configuration下添加settings配置\n\u0026lt;settings\u0026gt; \u0026lt;!--goods_id ==\u0026gt; goodsId 驼峰命名转化--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;    新增 在mybatis-config.xml中的configuration下添加mapper配置\n\u0026lt;mappers\u0026gt; \u0026lt;!--resource指的是映射文件的目录--\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/goods.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt;    SqlSession执行select语句\n MyBatisTestor部分测试代码：\n@Test public void testSelectAll(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectAll\u0026#34;); for (Goods goods : list) { System.out.println(goods.getTitle()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } }    SQL传参   单参数传参\n goods.xml\n\u0026lt;!--单参数传递，使用parameterType指定参数的数据类型即可，SQL#{value}提取参数--\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where goods_id = #{value} \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectById(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = session.selectOne(\u0026#34;goods.selectById\u0026#34;, 1603); System.out.println(goods.getTitle()); }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } }    多参数传参\n goods.xml\n\u0026lt;select id=\u0026#34;selectByPriceRange\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limit} \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectByPriceRange(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Map param = new HashMap\u0026lt;String, Integer\u0026gt;(); param.put(\u0026#34;min\u0026#34;, 100); param.put(\u0026#34;max\u0026#34;, 500); param.put(\u0026#34;limit\u0026#34;, 10); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectByPriceRange\u0026#34;, param); for (Goods goods : list) { System.out.println(goods.getTitle()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } }    多表查询 示例（不用ResultMap结果映射）：  goods.xml中添加以下代码\n\u0026lt;!--利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值，字段类型根据表结构进行自动判断 优点：易于扩展，易于使用 缺点：太过灵活，无法进行编译时检查 --\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsMap\u0026#34; resultType=\u0026#34;java.util.LinkedHashMap\u0026#34;\u0026gt; select g.*, c.category_name from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; MyBatisTestor.java部分代码\n@Test public void testSelectGoodsMap(){ SqlSession sqlSession = null; sqlSession = MyBatisUtils.openSession(); List\u0026lt;Map\u0026gt;list = sqlSession.selectList(\u0026#34;goods.selectGoodsMap\u0026#34;); for (Map map : list) { System.out.println(map); } }  ResultMap结果映射  ResultMap可以将查询结果映射为复杂类型的Java对象 ResultMap使用于Java对象保存多表关联结果 ResultMap支持对象关联查询等高级特性  tip:DTO-\u0026gt;Data Transfer Object \u0026ndash; 数据传输对象 使用ResultMap结果映射  编写GoodsDTO -\u0026gt;\npackage com.imooc.mybatis.dto; import com.imooc.mybatis.entity.Category; import com.imooc.mybatis.entity.Goods; /** * @author CubeMonkey * @create 2020-10-27 18:50 */ //Data Transfer Object --数据传输对象 public class GoodsDTO { private Goods goods = new Goods(); private Category category = new Category(); private String test; public Goods getGoods() { return goods; } public void setGoods(Goods goods) { this.goods = goods; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } public String getTest() { return test; } public void setTest(String test) { this.test = test; } } Goods.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 11:28 */ public class Goods { private Integer goodsId;//商品编号  private String title;//标题  private String subTitle;//子标题  private Float originalCost;//原始价格  private Float currentPrice;//当前价格  private Float discount;//折扣率  private Integer isFreeDelivery;//是否包邮，1-包邮 0-不包邮  private Integer categoryId;//分类编号  public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.goodsId = goodsId; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getSubTitle() { return subTitle; } public void setSubTitle(String subTitle) { this.subTitle = subTitle; } public Float getOriginalCost() { return originalCost; } public void setOriginalCost(Float originalCost) { this.originalCost = originalCost; } public Float getCurrentPrice() { return currentPrice; } public void setCurrentPrice(Float currentPrice) { this.currentPrice = currentPrice; } public Float getDiscount() { return discount; } public void setDiscount(Float discount) { this.discount = discount; } public Integer getIsFreeDelivery() { return isFreeDelivery; } public void setIsFreeDelivery(Integer isFreeDelivery) { this.isFreeDelivery = isFreeDelivery; } public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } } Category.java\npackage com.imooc.mybatis.entity; /** * @author CubeMonkey * @create 2020-10-27 19:12 */ public class Category { private Integer categoryId; private String categoryName; private Integer parentId; private Integer categoryLevel; private Integer categoryOrder; public Integer getCategoryId() { return categoryId; } public void setCategoryId(Integer categoryId) { this.categoryId = categoryId; } public String getCategoryName() { return categoryName; } public void setCategoryName(String categoryName) { this.categoryName = categoryName; } public Integer getParentId() { return parentId; } public void setParentId(Integer parentId) { this.parentId = parentId; } public Integer getCategoryLevel() { return categoryLevel; } public void setCategoryLevel(Integer categoryLevel) { this.categoryLevel = categoryLevel; } public Integer getCategoryOrder() { return categoryOrder; } public void setCategoryOrder(Integer categoryOrder) { this.categoryOrder = categoryOrder; } } 在goods.xml中添加如下信息\n\u0026lt;!--结果映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods\u0026#34; type=\u0026#34;com.imooc.mybatis.dto.GoodsDTO\u0026#34;\u0026gt; \u0026lt;!--设置主键字段与属性映射--\u0026gt; \u0026lt;id property=\u0026#34;goods.goodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!--设置非主键字段与属性映射--\u0026gt; \u0026lt;result property=\u0026#34;goods.title\u0026#34; column=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.originalCost\u0026#34; column=\u0026#34;original_cost\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.currentPrice\u0026#34; column=\u0026#34;current_price\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.discount\u0026#34; column=\u0026#34;discount\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.isFreeDelivery\u0026#34; column=\u0026#34;is_free_delivery\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryName\u0026#34; column=\u0026#34;category_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.parentId\u0026#34; column=\u0026#34;parent_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryLevel\u0026#34; column=\u0026#34;category_level\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryOrder\u0026#34; column=\u0026#34;category_order\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;test\u0026#34; column=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsDTO\u0026#34; resultMap=\u0026#34;rmGoods\u0026#34;\u0026gt; select g.*, c.*, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt;  MyBatis的写操作 Insert操作  在goods.xml中配置如下信息\n\u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId}) \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; MyBatisTestor.java 测试代码\n@Test public void testInsert() { SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(\u0026#34;测试用例标题\u0026#34;); goods.setSubTitle(\u0026#34;测试用例子标题\u0026#34;); goods.setOriginalCost(1f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(12); int num = session.insert(\u0026#34;goods.insert\u0026#34;, goods); session.commit();//这个很重要，不能忘记  if (num == 1) System.out.println(\u0026#34;插入成功\u0026#34;); else System.out.println(\u0026#34;插入失败\u0026#34;); System.out.println(goods.getGoodsId()); } catch (Exception e){ session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } }  selectKey与useGeneratedKey区别 selectKey: \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; useGeneratedKey: \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; keyColumn=\u0026#34;goods_id\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;/insert\u0026gt; 二者区别 - 显示与隐式  selectKey标签需要明确编写获取最新主键的SQL语句(不同的数据库驱动获取最新主键的SQL语句不同) useGeneratedKeys属性会自动根据驱动生成对应SQL语句  二者区别-应用场景不同  selectKey适用于所有的关系型数据库 useGeneratedKeys只支持“自增主键”类型的数据库  tip: ​\t不支持自增主键的数据库有：DB2， Oracle\n在oracle中selectKey的用法： \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; INSERT INTO 语句 \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;BEFORE\u0026#34;\u0026gt; select seq_goods.nextval as id from dual \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; 总结：  selectKey标签是通用方案，使用于所有数据库，但编写麻烦 useGeneratedKeys属性只支持“自增主键”数据库，使用简单  update操作  goods.xml:\n\u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; update t_goods set title = #{title}, sub_title = #{subTitle}, original_cost = #{originalCost}, current_price = #{currentPrice}, discount = #{discount}, is_free_delivery = #{isFreeDelivery}, category_id = #{categoryId} where goods_id = #{goodsId} \u0026lt;/update\u0026gt; MyBatisTestor.java\n@Test public void testUpdate(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = session.selectOne(\u0026#34;selectById\u0026#34;, 739); goods.setTitle(\u0026#34;更新测试商品\u0026#34;); int num = session.update(\u0026#34;goods.update\u0026#34;, goods); if (num == 1) System.out.println(\u0026#34;更新成功\u0026#34;); else System.out.println(\u0026#34;更新失败\u0026#34;); System.out.println(goods.getTitle()); session.commit(); } catch (Exception e) { session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } }  ​\ndelete操作  goods.xml\n\u0026lt;delete id=\u0026#34;delete\u0026#34; parameterType=\u0026#34;Integer\u0026#34;\u0026gt; delete from t_goods where goods_id = #{value} \u0026lt;/delete\u0026gt; MyBatisTestor.java\n@Test public void testDelete(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); int num = session.delete(\u0026#34;goods.delete\u0026#34;, 739); if (num == 1) System.out.println(\u0026#34;删除成功\u0026#34;); else System.out.println(\u0026#34;删除失败\u0026#34;); session.commit(); } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } }  MyBatis预防SQL注入攻击 SQL注入攻击  SQL注入是指攻击者利用SQL漏洞，绕过系统约束，越权获取数据的攻击方式  MyBatis俩种传值方式  ${}文本替换，未经任何处理对SQL文本替换（可以用于动态使用SQL语句，使用时绝对不能从外界输入） #{}预编译传值，使用预编译传值可以预防SQL注入  MyBatis工作流程 ","permalink":"https://rex0520.github.io/posts/back/jdbctool/mybatis%E5%9F%BA%E7%A1%80/","summary":"MyBatis基础入门 软件开发中的框架  框架是可被应用开发者定制的应用骨架 框架是一种规则，保证开发者遵循相同的方式开发程序 框架提倡“不要重复造轮子”，对基础功能进行封装  框架的优点  极大提高了开发效率 统一的编码规则，有利于团队管理 灵活配置的应用，拥有更好的维护性  SSM开发框架  S -\u0026gt; Spring S -\u0026gt; Spring MVC M -\u0026gt; MyBatis  什么是MyBatis  MyBatis是优秀的持久层框架 MyBatis使用XML将SQL与程序解耦，便于维护 MyBatis学习简单，执行高效，是JDBC的延展  MyBatis开发流程  引入MyBatis依赖 创建核心配置文件 创建实体(Entity)类 创建Mapper映射文件 初始化SessionFactory 利用SqlSession对象操作数据  MyBatis环境配置 mybatis-config.xml说明  MyBatis采用XML格式配置数据库环境信息 MyBatis环境配置标签 environment包含数据库驱动、URL、用户名于密码  mybatis-config.xml示例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--根据环境，不同的环境不同的id，dev-\u0026gt;开发环境 prd-\u0026gt;生产环境 --\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--采用JDBC方式对数据库事务进行commit/rollback--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!","title":"Mybatis基础"},{"content":"MyBatis进阶 什么是日志  日志文件是用于记录系统操作事件的记录文件或文件集合 日志保存历史数据，是诊断问题以及理解系统活动的重要依据  SLF4j与Logback 日志的使用:   引入logback依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   创建logback.xml，并写入如下代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别（优先级高到低） error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序允许的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;\u0026gt;\u0026lt;/appender-ref\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt;   动态SQL  动态SQL是指根据参数数据动态组织SQL的技术  代码示例：  goods.xml中加入如下sql语句\n\u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;currentPrice != null\u0026#34;\u0026gt; and current_price \u0026amp;lt; #{currentPrice} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; MyBatisTestor.java中使用dynamicSelect\n@Test public void testDynamicSQL(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); HashMap\u0026lt;String, Object\u0026gt; param = new HashMap\u0026lt;\u0026gt;(); param.put(\u0026#34;categoryId\u0026#34;, 44); param.put(\u0026#34;currentPrice\u0026#34;, 500); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.dynamicSelect\u0026#34;, param); for (Goods goods : list) { System.out.println(goods.getTitle()); } } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } }  MyBatis二级缓存  一级缓存默认开启，缓存范围SqlSession会话 二级缓存手动开启，属于Mapper Namespace  缓存的范围 二级缓存运行规则  二级开启后默认所有查询操作均使用缓存 写操作commit提交时对该namespace缓存强制清空 配置useCache=false可以不用缓存 配置flushCache=true代表强制清空缓存   二级缓存的使用：\ngoods.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goods\u0026#34;\u0026gt; \u0026lt;!--开启了二级缓存 1.LRU - 最近最久未使用：移除最长时间不被使用的对象 2.LFU - 最近最少使用：移除最近访问频率最低的对象 3.FIFO - 先进后出：按对象进入缓存的顺序来移除他们。 4.SOFT - 软引用：移除基于垃圾收集器状态和软引用规则的对象 5.WEAK - 弱引用：更积极的移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval 代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒 = 10分钟 size 缓存存储上限，用于保存对象或集合（1个集合算1个对象）的数量上限 readOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高 设置为false，代表每次取出的是缓存对象的“副本”，每一次取出的对象都是不同的，这种安全性较高 --\u0026gt; \u0026lt;cache eviction=\u0026#34;LRU\u0026#34; flushInterval=\u0026#34;600000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;!-- useCache=\u0026#34;false\u0026#34;代表不使用缓存--\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useCache=\u0026#34;false\u0026#34;\u0026gt; select * from t_goods order by goods_id desc limit 10 \u0026lt;/select\u0026gt; \u0026lt;!--单参数传递，使用parameterType指定参数的数据类型即可，SQL#{value}提取参数--\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where goods_id = #{value} \u0026lt;/select\u0026gt; \u0026lt;!--多参数传递时，使用parameterType指定java.util.Map, SQL中#{key提取参数}--\u0026gt; \u0026lt;select id=\u0026#34;selectByPriceRange\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limit} \u0026lt;/select\u0026gt; \u0026lt;!--利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值，字段类型根据表结构进行自动判断 优点：易于扩展，易于使用 缺点：太过灵活，无法进行编译时检查 --\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsMap\u0026#34; resultType=\u0026#34;java.util.LinkedHashMap\u0026#34; flushCache=\u0026#34;true\u0026#34;\u0026gt; select g.*, c.category_name, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; \u0026lt;!--结果映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods\u0026#34; type=\u0026#34;com.imooc.mybatis.dto.GoodsDTO\u0026#34;\u0026gt; \u0026lt;!--设置主键字段与属性映射--\u0026gt; \u0026lt;id property=\u0026#34;goods.goodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!--设置非主键字段与属性映射--\u0026gt; \u0026lt;result property=\u0026#34;goods.title\u0026#34; column=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.originalCost\u0026#34; column=\u0026#34;original_cost\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.currentPrice\u0026#34; column=\u0026#34;current_price\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.discount\u0026#34; column=\u0026#34;discount\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.isFreeDelivery\u0026#34; column=\u0026#34;is_free_delivery\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;goods.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryName\u0026#34; column=\u0026#34;category_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryId\u0026#34; column=\u0026#34;category_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.parentId\u0026#34; column=\u0026#34;parent_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryLevel\u0026#34; column=\u0026#34;category_level\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;category.categoryOrder\u0026#34; column=\u0026#34;category_order\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;test\u0026#34; column=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectGoodsDTO\u0026#34; resultMap=\u0026#34;rmGoods\u0026#34;\u0026gt; select g.*, c.*, \u0026#34;1\u0026#34; as test from t_goods g, t_category c where g.category_id = c.category_id \u0026lt;/select\u0026gt; \u0026lt;!--flushCache=\u0026#34;true\u0026#34;在sql执行后强制清空缓存--\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; keyColumn=\u0026#34;goods_id\u0026#34; flushCache=\u0026#34;true\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId}) \u0026lt;!--更新goods中的id--\u0026gt; \u0026lt;!--\u0026lt;selectKey resultType=\u0026#34;Integer\u0026#34; keyProperty=\u0026#34;goodsId\u0026#34; order=\u0026#34;AFTER\u0026#34;\u0026gt; select last_insert_id(); \u0026lt;/selectKey\u0026gt;--\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; update t_goods set title = #{title}, sub_title = #{subTitle}, original_cost = #{originalCost}, current_price = #{currentPrice}, discount = #{discount}, is_free_delivery = #{isFreeDelivery}, category_id = #{categoryId} where goods_id = #{goodsId} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;delete\u0026#34; parameterType=\u0026#34;Integer\u0026#34;\u0026gt; delete from t_goods where goods_id = #{value} \u0026lt;/delete\u0026gt; \u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;currentPrice != null\u0026#34;\u0026gt; and current_price \u0026amp;lt; #{currentPrice} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;  商品和详情对象关联查询 ​\t关联商品与商品详情信息\n代码案例（一对多）：  在Goods.java中添加goodDetail集合成员\n创建goods_detail.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;goodsDetail\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectByGoodsId\u0026#34; parameterType=\u0026#34;Integer\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.GoodsDetail\u0026#34;\u0026gt; select * from t_goods_detail where goods_id = #{value} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在mybatis-config.xml中添加goods_detail.xml的映射\n\u0026lt;mapper resource=\u0026#34;mappers/goods_detail.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; 在goods.xml编写select语句\n\u0026lt;!-- resultMap可用于说明一对多或者多对一的映射逻辑 id 是resultMap属性引用的标志 type 指向One的实体(Goods) --\u0026gt; \u0026lt;resultMap id=\u0026#34;rmGoods1\u0026#34; type=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; \u0026lt;!--映射Goods对象的主键到goods_id字段--\u0026gt; \u0026lt;id column=\u0026#34;goods_id\u0026#34; property=\u0026#34;goodsId\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!-- collection的含义是， 在select * from t_goods limit 0, 1得到结果后，对所有Goods对象遍历得到goods_id字段值， 并带入到goodsDetail命名空间的findByGoodsId的SQL中执行查询 将得到的“商品详情”集合赋值给goodsDetail List对象 --\u0026gt; \u0026lt;collection property=\u0026#34;goodsDetails\u0026#34; select=\u0026#34;goodsDetail.selectByGoodsId\u0026#34; column=\u0026#34;goods_id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectOneToMany\u0026#34; resultMap=\u0026#34;rmGoods1\u0026#34;\u0026gt; select * from t_goods limit 0,10 \u0026lt;/select\u0026gt; 在MyBatisUtils中编写测试代码\n@Test public void testOneToMany() throws Exception{ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;Goods\u0026gt; list = session.selectList(\u0026#34;goods.selectOneToMany\u0026#34;); for (Goods goods : list) { System.out.println(goods.getTitle()+\u0026#34;:\u0026#34;+goods.getGoodsDetails().size()); } }catch (Exception e){ throw e; }finally { MyBatisUtils.closeSession(session); } }  代码案例（多对一）：  在GoodsDetail.java中添加goods成员\n在goods_detail.xml中添加select语句\n\u0026lt;resultMap id=\u0026#34;rmGoodsDetail\u0026#34; type=\u0026#34;com.imooc.mybatis.entity.GoodsDetail\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;gd_id\u0026#34; property=\u0026#34;gdId\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;goods_id\u0026#34; property=\u0026#34;goodsId\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;goods\u0026#34; select=\u0026#34;goods.selectById\u0026#34; column=\u0026#34;goods_id\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectManyToOne\u0026#34; resultMap=\u0026#34;rmGoodsDetail\u0026#34;\u0026gt; select * from t_goods_detail limit 0, 100 \u0026lt;/select\u0026gt; 在MyBatisTestor.java中添加如下测试代码：\n@Test public void testManyToOne(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); List\u0026lt;GoodsDetail\u0026gt; list = session.selectList(\u0026#34;goodsDetail.selectManyToOne\u0026#34;); for (GoodsDetail goodsDetail : list) { System.out.println(goodsDetail.getGdPicUrl()+\u0026#34;:\u0026#34;+goodsDetail.getGoods().getTitle()); } } catch (Exception e) { throw e; } finally { MyBatisUtils.closeSession(session); } }  分页插件PageHelper 分页查询的麻烦事  当前页数据查询 - select * from tab limit 0, 10 总记录数查询 - select count(*) from tab 程序计算总页数、上一页码、下一页码  PageHelper使用流程   maven引入PageHelper与jsqlparser\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.jsqlparse\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsqlparser\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   mybatis-config.xml增加Plugin配置\n\u0026lt;!-- 启用PageHelper分页插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.PageInterceptor\u0026#34;\u0026gt; \u0026lt;!-- 设置数据库类型 --\u0026gt; \u0026lt;property name=\u0026#34;helperDialect\u0026#34; value=\u0026#34;mysql\u0026#34;/\u0026gt; \u0026lt;!-- 分页合理化 --\u0026gt; \u0026lt;property name=\u0026#34;reasonable\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;   代码中使用PageHelper.startPage()自动分页\n goods.xml中的查询语句\n\u0026lt;select id=\u0026#34;selectPage\u0026#34; resultType=\u0026#34;com.imooc.mybatis.entity.Goods\u0026#34;\u0026gt; select * from t_goods where current_price \u0026amp;lt; 1000 \u0026lt;/select\u0026gt; MyBatisTestor.java中的查询代码\n@Test public void testSelectPage(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); /*startPage方法会自动将下一次查询进行分页*/ PageHelper.startPage(2, 10); Page\u0026lt;Goods\u0026gt; page = (Page)session.selectList(\u0026#34;goods.selectPage\u0026#34;); System.out.println(\u0026#34;总页数：\u0026#34;+page.getPages()); System.out.println(\u0026#34;总记录数：\u0026#34;+page.getTotal()); System.out.println(\u0026#34;开始行号：\u0026#34;+page.getStartRow()); System.out.println(\u0026#34;结束行号：\u0026#34;+page.getEndRow()); System.out.println(\u0026#34;当前页码：\u0026#34;+page.getPageNum()); List\u0026lt;Goods\u0026gt; data = page.getResult(); for (Goods g : data) { System.out.println(g.getTitle()); } System.out.println(); } catch (Exception e) { throw e; } finally { MyBatisUtils.closeSession(session); } }    不同数据库分页的实现原理 MySQL分页 select * from table limit 10, 20; Oracle分页（商业数据库NO.1） selectt3.from(selectt2.*rownumasrownumfrom(select*fromtableorderbyidasc)t2whererownum\u0026lt;=20)t3where52.row_num\u0026gt;11SQL Server 2000 selecttop3*fromtablewhereidnotin(selecttop15idfromtable)SQL Server 2012+ ​\nselect*fromtableorderbyidoffset4rowsfetchnext5rowonlyMyBatis整合C3P0连接池   引入C3P0的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写C3P0DataSourceFactory继承自UnpooledDataSourceFactory\npackage com.imooc.mybatis.datasource; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory; /** * C3P0与MyBatis兼容使用的数据源工厂类 * @author CubeMonkey * @create 2020-10-29 20:04 */ public class C3P0DataSourceFactory extends UnpooledDataSourceFactory { public C3P0DataSourceFactory(){ this.dataSource = new ComboPooledDataSource(); } }   在mybatis-config.xml中配置c3p0数据库连接池\n\u0026lt;dataSource type=\u0026#34;com.imooc.mybatis.datasource.C3P0DataSourceFactory\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=GMT\u0026amp;amp;useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34; value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt;   MyBatis批处理 批量插入数据的局限：  无法获得插入数据的id 批量生成的SQL太长，可能会被服务器拒绝（可采用数据分段的方式）  批量插入：  goods.xml中的insert语句\n\u0026lt;insert id=\u0026#34;insertBatch\u0026#34; parameterType=\u0026#34;java.util.List\u0026#34;\u0026gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values \u0026lt;foreach collection=\u0026#34;list\u0026#34; separator=\u0026#34;,\u0026#34; item=\u0026#34;item\u0026#34; index=\u0026#34;index\u0026#34;\u0026gt; (#{item.title}, #{item.subTitle}, #{item.originalCost}, #{item.currentPrice}, #{item.discount}, #{item.isFreeDelivery}, #{item.categoryId}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; MyBatisTestor.java中testInsertBatch()\n@Test public void testInsertBatch(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); long st = new Date().getTime(); List\u0026lt;Goods\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; 1000; i++){ Goods goods = new Goods(); goods.setTitle(\u0026#34;测试商品\u0026#34;); goods.setSubTitle(\u0026#34;测试子标题\u0026#34;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); list.add(goods); } session.insert(\u0026#34;goods.insertBatch\u0026#34;, list); session.commit(); long et = new Date().getTime(); System.out.println(\u0026#34;执行时间：\u0026#34; + (et-st) + \u0026#34;毫秒\u0026#34;);//1179  } catch (Exception e) { if (session != null){ session.rollback(); } } finally { MyBatisUtils.closeSession(session); } }  批量删除：  goods.xml中delet语句：\n\u0026lt;delete id=\u0026#34;deleteBatch\u0026#34; parameterType=\u0026#34;java.util.List\u0026#34;\u0026gt; delete from t_goods where goods_id in \u0026lt;foreach collection=\u0026#34;list\u0026#34; index=\u0026#34;index\u0026#34; item=\u0026#34;item\u0026#34; separator=\u0026#34;, \u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{item} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; MyBatisTestor.java中testDeleteBatch()\n@Test public void testDeleteBatch(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); long st = new Date().getTime(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1920); list.add(1921); list.add(1922); session.insert(\u0026#34;goods.deleteBatch\u0026#34;, list); session.commit(); long et = new Date().getTime(); System.out.println(\u0026#34;执行时间：\u0026#34; + (et-st) + \u0026#34;毫秒\u0026#34;);//725毫秒  } catch (Exception e) { if (session != null){ session.rollback(); } } finally { MyBatisUtils.closeSession(session); } }  MyBatis注解 注解和xml配置的优点：  xml有更好的维护性，更适合大型的需要团队协作的项目 注解有更好的程序编码体验，更适合小型敏捷开发的工程  MyBatis常用注解    注解 对应XML 说明     @Insert  新增SQL   @Update  更新SQL   @Delect  删除SQL   @Select  查询SQL   @Param \u0026ndash; 参数映射   @Results  结果映射   @Result  字段映射    准备工作（不再使用之前用的工程）；   引入mybatis、logback日志、数据库驱动的依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置mybatis-config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- goods_id ==\u0026gt; goodsId 驼峰命名转换 --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--设置默认指向的数据库--\u0026gt; \u0026lt;environments default=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!--配置环境，不同的环境不同的id名字--\u0026gt; \u0026lt;environment id=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;!--采用连接池方式管理数据库连接--\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/babytun?useSSL=false\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt;   配置好logback.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;[%thread] %d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别(优先级高到低): error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序运行的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt;   在java目录下创建一个dao包，在dao下创建GoodsDAO\n  在mybatis-config.xml中配置mapper映射\n\u0026lt;mappers\u0026gt; \u0026lt;!--当有多个dao接口时，mapper不便于维护--\u0026gt; \u0026lt;!-- \u0026lt;mapper class=\u0026#34;com.imooc.mybatis.dao.GoodsDAO\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt;--\u0026gt; \u0026lt;package name=\u0026#34;com.imooc.mybatis.dao\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   按价格范围查询商品的代码：  在GoodsDAO下写入如下方法：\n@Select(\u0026#34;select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{limt}\u0026#34;) public List\u0026lt;Goods\u0026gt; selectByPriceRange(@Param(\u0026#34;min\u0026#34;) Float min, @Param(\u0026#34;max\u0026#34;) Float max, @Param(\u0026#34;limt\u0026#34;) Integer limt); 在MyBatisTestor中使用这个方法:\n@Test public void testSelectByPrice(){ SqlSession session = null; try { session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List\u0026lt;Goods\u0026gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20); System.out.println(list.size()); } catch (Exception e) { e.printStackTrace(); } finally { MyBatisUtils.closeSession(session); } }  插入商品的代码：  在GoodsDAO下写入如下方法：\n@Insert(\u0026#34;INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) values(#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId})\u0026#34;) @SelectKey(statement = \u0026#34;select last_insert_id()\u0026#34;, before = false, keyProperty = \u0026#34;goodsId\u0026#34;, resultType = Integer.class) public int insert(Goods goods); 在MyBatisTestor中使用这个方法:\n@Test public void testInsert() throws Exception { SqlSession session = null; try { session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(\u0026#34;测试商品\u0026#34;); goods.setSubTitle(\u0026#34;测试子标题\u0026#34;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); int num = goodsDAO.insert(goods); session.commit(); System.out.println(goods.getGoodsId()); } catch (Exception e) { if (session != null){ session.rollback(); } throw e; } finally { MyBatisUtils.closeSession(session); } }  结果映射的代码：  在GoodsDAO下写入如下方法：\n@Select(\u0026#34;select * from t_goods\u0026#34;) //\u0026lt;resultMap\u0026gt; @Results({ @Result(column = \u0026#34;goods_id\u0026#34;, property = \u0026#34;goodsId\u0026#34;, id = true), @Result(column = \u0026#34;title\u0026#34;, property = \u0026#34;title\u0026#34;), @Result(column = \u0026#34;current_price\u0026#34;, property = \u0026#34;currentPrice\u0026#34;) }) public List\u0026lt;GoodsDTO\u0026gt; selectAll(); 在MyBatisTestor中使用这个方法:\n@Test public void selectAll() throws Exception { SqlSession session = null; try { session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List\u0026lt;GoodsDTO\u0026gt; list = goodsDAO.selectAll(); System.out.println(list.size()); } catch (Exception e) { session.rollback(); throw e; } finally { MyBatisUtils.closeSession(session); } }  ","permalink":"https://rex0520.github.io/posts/back/jdbctool/mybatis%E8%BF%9B%E9%98%B6/","summary":"MyBatis进阶 什么是日志  日志文件是用于记录系统操作事件的记录文件或文件集合 日志保存历史数据，是诊断问题以及理解系统活动的重要依据  SLF4j与Logback 日志的使用:   引入logback依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   创建logback.xml，并写入如下代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;console\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 日志输出级别（优先级高到低） error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序允许的跟踪信息 --\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;\u0026gt;\u0026lt;/appender-ref\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt;   动态SQL  动态SQL是指根据参数数据动态组织SQL的技术  代码示例：  goods.xml中加入如下sql语句\n\u0026lt;select id=\u0026#34;dynamicSelect\u0026#34; parameterType=\u0026#34;java.","title":"Mybatis进阶"},{"content":"RESTful开发风格 REST与RESTful  REST(Representational State Transfer)-表现层状态转换，资源在网络中以某种表现形式进行状态转移 RESTful是基于REST理念的一套开发风格，是具体的开发规则  RESTful传输数据 RESTful开发规范  使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE-\u0026gt;查|增|改|删) 只返回数据(JSON|XML)，不包含任何展现  RESTful命名要求    URI 说明 修改建议     GET /articles?au=lily 正确用法    GET /a/1 URI必须具有语义 GET /student/1   POST /createArticle/1 URI必须使用名词 POST /article/1   GET /articles/author/1 URI扁平化，不超两级 GET /articles/author?id=1   DELETE /articles/1 URI名词区分单复数 GET /articles?au=lilyDELETE /article/1    开发第一个RESTful应用  RestfulController.java\npackage com.imooc.restful.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; /** * @author Rex * @create 2021-01-12 12:00 */ @Controller @RequestMapping(\u0026#34;/restful\u0026#34;) public class RestfulController { @GetMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doGetRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;返回查询结果\\\u0026#34;}\u0026#34;; } @PostMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPostRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据新建成功\\\u0026#34;}\u0026#34;; } @PutMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doPutRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据更新成功\\\u0026#34;}\u0026#34;; } @DeleteMapping(\u0026#34;/request\u0026#34;) @ResponseBody public String doDeleteRequest(){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据删除成功\\\u0026#34;}\u0026#34;; } } client.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;RESTful实验室\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./jquery-3.5.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026#34;#btnGet\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnPost\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;post\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnPut\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;put\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); $(\u0026#34;#btnDelete\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;delete\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Get请求\u0026#34; id=\u0026#34;btnGet\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Post请求\u0026#34; id=\u0026#34;btnPost\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Put请求\u0026#34; id=\u0026#34;btnPut\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;发送Delete请求\u0026#34; id=\u0026#34;btnDelete\u0026#34;/\u0026gt; \u0026lt;h1 id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 结果：\n为了解决json乱码问题需要在applicationContext对MediaTypes进行处理\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;text/html; charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;application/json; charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;  RestController注解 @RestController = @ResposneBody + @Controller, 默认将String向请求中输出，而不是将请求转发到该路径下\n路径变量(@PathVariable) 路径变量：存放在URI中可变的数值 代码示例：  RestfulController.java\n@PostMapping(\u0026#34;/request/{rid}\u0026#34;) public String doPostRequest(@PathVariable(\u0026#34;rid\u0026#34;) Integer requestId){ return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据新建成功\\\u0026#34;, \\\u0026#34;id\\\u0026#34;:\\\u0026#34;\u0026#34;+requestId+\u0026#34;\\\u0026#34;}\u0026#34;; } client.html\n$(\u0026#34;#btnPost\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request/100\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;post\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message + \u0026#34;:\u0026#34;+json.id); } }) }); 结果：\n 简单请求和非简单请求  简单请求是指标准结构的HTTP请求，对应GET/POST请求 非简单请求是指复杂要求的HTTP请求，指PUT/DELETE、扩展标准请求 两者最大区别是非简单请求发送前需要发送预检请求  非简单请求 非简单请求中参数传递 需要配置FormContentFilter过滤器\n代码示例：  web.xml\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;formContent\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.FormContentFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;formContent\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; RestfulController.java\n@PutMapping(\u0026#34;/request\u0026#34;) public String doPutRequest(Person person){ System.out.println(person.getName()+\u0026#34;:\u0026#34;+person.getAge()); return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;数据更新成功\\\u0026#34;}\u0026#34;; } client.html\n$(\u0026#34;#btnPut\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/request\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;put\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;data\u0026#34;:\u0026#34;name=lily\u0026amp;age=23\u0026#34;, \u0026#34;success\u0026#34;: function (json) { $(\u0026#34;#message\u0026#34;).text(json.message); } }) }); 结果：\n JSON序列化  引入jackson-core -\u0026gt; jack核心包 引入jackson-databind-\u0026gt;用于jackson与目标对象交互 引入jackson-annotations用于jackson的注解  tip：日期类型、数字类型、货币类型的处理需要加上@JsonFormat注解，如@JsonFormat(pattern=\u0026quot;\u0026quot;, timezone=\u0026ldquo;GMT+8\u0026rdquo;)\n使用示例：  RestController.java\n@GetMapping(\u0026#34;/persons\u0026#34;) public List\u0026lt;Person\u0026gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(\u0026#34;lily\u0026#34;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(\u0026#34;smith\u0026#34;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); return list; } Person.java\npackage com.imooc.restful.entity; import com.fasterxml.jackson.annotation.JsonFormat; import java.util.Date; /** * @author Rex * @create 2021-01-12 14:02 */ public class Person { private String name; private Integer age; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH-mm-ss\u0026#34;, timezone = \u0026#34;GMT+8\u0026#34;) private Date birthday; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } } client.html\n\u0026lt;script\u0026gt; //...  $(\u0026#34;#btnPersons\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;/restful/persons\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { console.log(json) // $(\u0026#34;#message\u0026#34;).text(json.message);  for (var i = 0; i \u0026lt; json.length; i++) { var p = json[i]; $(\u0026#34;#divPersons\u0026#34;).append(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34;+p.name+\u0026#34;-\u0026#34;+p.age+\u0026#34;-\u0026#34;+p.birthday+\u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;) } } }) }); \u0026lt;/script\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPersons\u0026#34; value=\u0026#34;查询所有人员\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;divPersons\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 结果：\n 浏览器的跨域访问 浏览器的同源策略  同源策略阻止从一个域加载的脚本去获取另一个域上的资源 只要协议、域名、端口号有任何一个不同，都被当作是不同的域 浏览器Console看到Access-Control-Allow-Origin就代表跨域了  同源策略示例    源URL 目标URL 直接访问？     http://imooc.com https://xxx.com:8080/test 不能   http://imooc.com https://imooc.com 不能   http://imooc.com http://abc.imooc.com 不能   http://imooc.com http://imooc.com:8080 不能   http://localhost http://127.0.0.1 不能   http://imooc.com http://imooc.com/user/test 可以    HTML中允许跨域的标签  \u0026lt;img\u0026gt; - 显示远程图片 \u0026lt;script\u0026gt; - 加载远程JS \u0026lt;link\u0026gt; - 加载远程CSS  SpringMVC跨域访问 CORS跨域资源访问  CORS是一种机制，使用额外的HTTP头通知浏览器可以访问其他域 URL响应头包含 Access-Control-*指明请求允许跨域  SpringMVC解决跨域访问   @CrossOrigin - Controller跨域注解\n代码示例：\n 80端口下的RestfulController.java：\npackage com.imooc.restful.controller; import com.imooc.restful.entity.Person; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * @author Rex * @create 2021-01-12 12:00 */ @RestController @RequestMapping(\u0026#34;/restful\u0026#34;) //@CrossOrigin(origins = {\u0026#34;http://localhost:8080\u0026#34;, \u0026#34;http://www.imooc.com\u0026#34;}) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600)//匹配每一个URL, maxAge-\u0026gt;设置预检请求的访问时间 public class RestfulController { //.... } 8080端口下的client.html\n$(\u0026#34;#btnPersons\u0026#34;).click(function () { $.ajax({ \u0026#34;url\u0026#34;:\u0026#34;http://localhost/restful/persons\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;dataType\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;success\u0026#34;: function (json) { console.log(json) // $(\u0026#34;#message\u0026#34;).text(json.message); for (var i = 0; i \u0026lt; json.length; i++) { var p = json[i]; $(\u0026#34;#divPersons\u0026#34;).append(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34;+p.name+\u0026#34;-\u0026#34;+p.age+\u0026#34;-\u0026#34;+p.birthday+\u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;) } } }) }); 结果：\n   \u0026lt;mvc:cors\u0026gt; - Spring MVC 全局跨域配置\n applicationContext.xml\n\u0026lt;mvc:cors\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/restful/**\u0026#34; allowed-origins=\u0026#34;http://localhost:8080, http://www.imooc.com\u0026#34; max-age=\u0026#34;3600\u0026#34;/\u0026gt; \u0026lt;/mvc:cors\u0026gt;    ","permalink":"https://rex0520.github.io/posts/back/framework/springmvc/restful/","summary":"RESTful开发风格 REST与RESTful  REST(Representational State Transfer)-表现层状态转换，资源在网络中以某种表现形式进行状态转移 RESTful是基于REST理念的一套开发风格，是具体的开发规则  RESTful传输数据 RESTful开发规范  使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE-\u0026gt;查|增|改|删) 只返回数据(JSON|XML)，不包含任何展现  RESTful命名要求    URI 说明 修改建议     GET /articles?au=lily 正确用法    GET /a/1 URI必须具有语义 GET /student/1   POST /createArticle/1 URI必须使用名词 POST /article/1   GET /articles/author/1 URI扁平化，不超两级 GET /articles/author?id=1   DELETE /articles/1 URI名词区分单复数 GET /articles?au=lilyDELETE /article/1    开发第一个RESTful应用  RestfulController.java\npackage com.imooc.restful.controller; import org.springframework.stereotype.Controller; import org.","title":"Restful开发风格"},{"content":"Spring MVC Spring MVC介绍 MVC是什么 Spring MVC  Spring MVC是Spring体系的轻量级WEB MVC框架 Spring MVC的核心Controller控制器，用于处理请求，产生响应 Spring MVC基于Spring IoC容器运行，所有对象被IoC管理  Spring 5.X版本变化  Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+) Spring 5.x支持JDK8/9,可以使用新特性 Spring 5.x最重要的新特性支持响应式编程  Spring MVC环境配置  Maven依赖spring-webmvc web.xml配置DispatcherServlet 配置applicationContext的mvc标记 开发Controller控制器  简单示例：  applicationContext.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mv=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中，自动创建并管理com.imooc.springmvc及子包 拥有以下注解的对象 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc.springmvc\u0026#34;/\u0026gt; \u0026lt;!--启用Spring MVC的注解开发模式--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--将图片/JS/CSS等静态资源排除在外，可提高执行效率--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;/beans\u0026gt; web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\u0026#34; version=\u0026#34;3.1\u0026#34;\u0026gt; \u0026lt;!--DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- DispatcherServlet是Spring MVC最核心的对象 DispatcherServlet用于拦截Http请求, 并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理 --\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--applicationContext.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 在Web应用启动时自动创建Spring IOC容器, 并初始化DispatcherServlet --\u0026gt; \u0026lt;load-on-startup\u0026gt;0\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!--\u0026#34;/\u0026#34; 代表拦截所有请求--\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; TestController.java\npackage com.imooc.springmvc.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; /** * @author Rex * @create 2021-01-08 16:59 */ @Controller public class TestController { @GetMapping(\u0026#34;/t\u0026#34;) @ResponseBody //直接向响应输出字符串数据，不跳转页面  public String test(){ return \u0026#34;HELLO WORLD\u0026#34;; } } 结果：  Spring MVC数据绑定 URL Mapping  URL Mapping指将URL与Controller方法绑定 通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务  URL Mapping注解  @RequestMapping - 通用绑定 @GetMapping - 绑定Get请求 @PostMapping - 绑定Post请求  接受请求参数的常用做法  使用Controller方法参数接受（@RequestParam） 使用Java Bean接受数据  接受表单复合数据  利用数组或者List接受请求中给的复合数据 利用@RequestParam为参数设置默认值 使用Map对象接受请求参数及注意事项  关联对象赋值 日期类型转换   @DateTimeFormat\n  自定义转换器\n MyDateConverter.java\npackage com.imooc.springmvc.converter; import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-09 10:34 */ public class MyDateConverter implements Converter\u0026lt;String, Date\u0026gt; { @Override public Date convert(String s) { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); try { Date d = sdf.parse(s); return d; } catch (ParseException e) { return null; } } } applicationContext.xml\n\u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;conversionService\u0026#34; class=\u0026#34;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;converters\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;bean class=\u0026#34;com.imooc.springmvc.converter.MyDateConverter\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  tip: @DateTimeFormat和自定义转换器最好不要同时使用，spring会优先使用自定义转换器\n  解决中文乱码问题 Web应用的中文乱码由来  Tomcat默认使用字符集ISO-8859-1，属于西欧字符集 解决乱码的核心思路是将ISO-8859-1转换为UTF-8 Controller中请求与响应都需要设置UTF-8字符集  中文乱码的配置   Get请求乱码-server.xml增加URIEncoding属性\n  Post请求乱码-web.xml配置CharacterEncodingFilter\n  Response响应乱码-Spring配置StringHttpMessageConverter\n示例代码：\n web.xml\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; applicationContext.xml\n\u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;!--response.setContentType(\u0026#34;text/html; charset=utf-8\u0026#34;)--\u0026gt; \u0026lt;value\u0026gt;text/html;charset=utf-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;    响应输出 响应中产生结果  @ResponseBody - 产生响应文本 ModelAndView - 利用模板引擎渲染输出  @ResponseBody  @ResponseBody直接产生响应体的数据，过程中不产生任何视图 @ResponseBody可产生标准字符串/JSON/XML等格式数据 @ResponseBody被StringHttpMessageConverty所影响  ModelAndView概述  ModelAndView是指“模型(数据)与视图(界面)”对象 通过ModelAndView可将数据对象与模板引擎进行绑定 SpringMVC中默认的View是JSP，也可以配置其他模板引擎  使用示例：  URLMappingController.java\n@GetMapping(\u0026#34;/view\u0026#34;) public ModelAndView showView(Integer userId){ ModelAndView mav = new ModelAndView(\u0026#34;/view.jsp\u0026#34;); User user = new User(); if (userId == 1){ user.setUsername(\u0026#34;lily\u0026#34;); }else if(userId == 2){ user.setUsername(\u0026#34;smith\u0026#34;); }else if(userId == 3){ user.setUsername(\u0026#34;lina\u0026#34;); } mav.addObject(\u0026#34;u\u0026#34;, user); return mav; } view.jsp\n\u0026lt;%-- Created by IntelliJ IDEA. User: CubeMonkey Date: 2021/1/9 Time: 11:27 Email:2192231938@qq.com To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;View\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;I\u0026#39;m view page\u0026lt;/h1\u0026gt;\u0026lt;hr/\u0026gt; \u0026lt;h2\u0026gt;Username:${u.username}\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ModelAndView方法  mav.addObject()方法设置的属性默认存放在当前请求中 默认ModelAndView使用请求转发(forward)至页面 重定向使用new ModelAndView(\u0026ldquo;redirect:/index.jsp\u0026rdquo;)  String+ModelMap 实现ModelAndView（常见） 示例代码: //String 与 ModelMap //Controller方法返回String的情况 //1. 方法被@ResponseBody描述，SpringMVC直接响应String字符串本身 //2. 方法不存在@ResponseBody，则SpringMVC处理String指代的视图(页面) @GetMapping(\u0026#34;/xxxx\u0026#34;) @ResponseBody public String showView1(Integer userId, ModelMap modelMap){ String view = \u0026#34;/view.jsp\u0026#34;; User user = new User(); if (userId == 1){ user.setUsername(\u0026#34;lily\u0026#34;); }else if(userId == 2){ user.setUsername(\u0026#34;smith\u0026#34;); }else if(userId == 3){ user.setUsername(\u0026#34;lina\u0026#34;); } modelMap.addAttribute(\u0026#34;u\u0026#34;, user); return view; } SpringMVC整合Freemarker   pom.xml引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   启用Freemarker模板引擎(FreeMarkerViewResolver)\n\u0026lt;bean id=\u0026#34;ViewReslover\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\u0026#34;\u0026gt; \u0026lt;!--向客户端输出内容的时候设置的字符集--\u0026gt; \u0026lt;property name=\u0026#34;contentType\u0026#34; value=\u0026#34;text/html;charset=utf-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.ftl\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   配置Freemarker参数(FreemarkerConfigurer)\n\u0026lt;bean id=\u0026#34;freemarkerConfig\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;templateLoaderPath\u0026#34; value=\u0026#34;/WEB-INF/ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;freemarkerSettings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!--为产生结果的时候的字符集--\u0026gt; \u0026lt;prop key=\u0026#34;defaultEnocding\u0026#34;\u0026gt;UTF-8\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   使用Freemarker\n test.ftl\n\u0026lt;h1\u0026gt;${u.username}\u0026lt;/h1\u0026gt; FreemarkerController.java\npackage com.imooc.springmvc.controller; import com.imooc.springmvc.entity.User; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; /** * @author Rex * @create 2021-01-09 14:25 */ @Controller @RequestMapping(\u0026#34;/fm\u0026#34;) public class FreemarkerController { @GetMapping(\u0026#34;/test\u0026#34;) public ModelAndView showTest(){ ModelAndView mav = new ModelAndView(\u0026#34;/test\u0026#34;); User user = new User(); user.setUsername(\u0026#34;andy\u0026#34;); mav.addObject(\u0026#34;u\u0026#34;, user); return mav; } }    ","permalink":"https://rex0520.github.io/posts/back/framework/springmvc/springmvc%E5%9F%BA%E7%A1%80/","summary":"Spring MVC Spring MVC介绍 MVC是什么 Spring MVC  Spring MVC是Spring体系的轻量级WEB MVC框架 Spring MVC的核心Controller控制器，用于处理请求，产生响应 Spring MVC基于Spring IoC容器运行，所有对象被IoC管理  Spring 5.X版本变化  Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+) Spring 5.x支持JDK8/9,可以使用新特性 Spring 5.x最重要的新特性支持响应式编程  Spring MVC环境配置  Maven依赖spring-webmvc web.xml配置DispatcherServlet 配置applicationContext的mvc标记 开发Controller控制器  简单示例：  applicationContext.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mv=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中，自动创建并管理com.imooc.springmvc及子包 拥有以下注解的对象 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc.springmvc\u0026#34;/\u0026gt; \u0026lt;!--启用Spring MVC的注解开发模式--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!","title":"SpringMVC基础"},{"content":"SpringMVC拦截器 拦截器-Interceptor  拦截器(Interveptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring AOP面向切面编程实现  拦截器开发流程   Maven依赖servlet-api\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   实现HandlerInterceptor\npackage com.imooc.restful.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author Rex * @create 2021-01-12 17:55 */ public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-准备执行\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-目标处理成功\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-响应内容已产生\u0026#34;); } }   applicationContext配置过滤地址\n\u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.imooc.restful.interceptor.MyInterceptor\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   执行结果\n  HandlerInterceptor接口  preHandle - 前置执行处理 postHandle - 目标资源已被Spring MVC框架处理 afterCompletion - 响应文本已经产生  多Interceptor执行先后顺序 ","permalink":"https://rex0520.github.io/posts/back/framework/springmvc/springmvc%E6%8B%A6%E6%88%AA%E5%99%A8/","summary":"SpringMVC拦截器 拦截器-Interceptor  拦截器(Interveptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring AOP面向切面编程实现  拦截器开发流程   Maven依赖servlet-api\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   实现HandlerInterceptor\npackage com.imooc.restful.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author Rex * @create 2021-01-12 17:55 */ public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+\u0026#34;-准备执行\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.","title":"SpringMVC拦截器"},{"content":"Redis入门 Redis介绍  Redis是Key-Value型NoSQL数据库 Redis将数据存储在内存中，同时也能持久化到磁盘 Redis常用于缓存，利用内存的高效提高程序的处理速度  Redis特点  速度快 持久化 主从复制 广泛的语言支持 多种数据结构 分布式与高可用  Redis的安装与使用 在Linux系统中安装Redis  https://redis.io/download\n 在windows系统中安装Redis  https://github.com/microsoftarchive/redis/releases\n Redis的常用基本配置    配置项 示例 说明     daemonize daemonize yes 是否启用后台允许，默认no   port port 6379 设置端口号，默认6379   logfile logfile 日志文件 设置日志文件   databases databases 255 设置redis数据库总量   dir dir数据文件目录 设置数据文件存储目录   requirepass requirepass 12345 设置使用密码    Redis通用命令    命令 示例 说明     select select 0 选择0号数据库   set set name lily 设置key=name,value=lily   get get hello 获得key=hello结果   keys keys he* 根据Pattern表达式查询符合条件的Key   dbsize dbsize 返回key的总数   exists exists a 检查key=a是否存在   del del a 删除key=a的数据   expire expire hello 20 设置key=hello 20秒后过期   ttl ttl 查看key=a的过期剩余时间    Redis数据类型  String - 字符串类型 Hash - Hash类型 List - 列表类型 Set - 集合类型 Zset - 有序集合类型  String字符串类型   String最大512mb 建议单个kv不超过100kb\n  字符串命令\n   命令 示例 说明     get get hello 获得key=hello结果   set set hello world 设置key=hello，value=hello   msetmget mset hello world java bestmget hello java 一次性设置或者获取多个值   del del hello 删除key=hello   incr/decr incr countdecr count key值自增/自减1   incrby/decrby incrby count 99decrby count 99 自增自减指定步长      Hash键值类型  Hash类型用于存储结构化数据 Hash命令     命令 示例 说明     hget hget emp:1 age 获取hash中key=age的值   hset hset emp:1 age 23 设置hash中age=23   hmsethmgethgetall hmset emp:1 age 30 name kakahmget emp:1 age namehgetall emp:1 name 设置hash多个值获取hash多个值获取hash所有值   hdel hdel emp:1 age 删除emp:1的age   hexists hexists emp:1 name 检查是否存在   hlen hlen emp:1 获取指定长度    List列表类型   List列表就是一系列字符串的“数组”，按插入顺序排序\n  List列表最大长度为2的32次方-1，可以包含40亿个元素\n  List命令\n​\n   命令 示例 说明     rpush rpush listkey c b a 右侧插入   lpush lpush listkey f e d 左侧插入   rpop rpop listkey 右侧插入   lpop lpop listkey 左侧插入      Set与Zset集合类型  Set集合是字符串的无序集合，集合成员是唯一的 Zset集合是字符串的有序集合，集合成员是唯一的  Java客户端-Jedis  Jedis是Java语言开发的Redis客户端工具包 Jedis只是对Redis命令的封装，掌握Redis命令便可轻易上手  ","permalink":"https://rex0520.github.io/posts/nosql/redis%E5%9F%BA%E7%A1%80/","summary":"Redis入门 Redis介绍  Redis是Key-Value型NoSQL数据库 Redis将数据存储在内存中，同时也能持久化到磁盘 Redis常用于缓存，利用内存的高效提高程序的处理速度  Redis特点  速度快 持久化 主从复制 广泛的语言支持 多种数据结构 分布式与高可用  Redis的安装与使用 在Linux系统中安装Redis  https://redis.io/download\n 在windows系统中安装Redis  https://github.com/microsoftarchive/redis/releases\n Redis的常用基本配置    配置项 示例 说明     daemonize daemonize yes 是否启用后台允许，默认no   port port 6379 设置端口号，默认6379   logfile logfile 日志文件 设置日志文件   databases databases 255 设置redis数据库总量   dir dir数据文件目录 设置数据文件存储目录   requirepass requirepass 12345 设置使用密码    Redis通用命令    命令 示例 说明     select select 0 选择0号数据库   set set name lily 设置key=name,value=lily   get get hello 获得key=hello结果   keys keys he* 根据Pattern表达式查询符合条件的Key   dbsize dbsize 返回key的总数   exists exists a 检查key=a是否存在   del del a 删除key=a的数据   expire expire hello 20 设置key=hello 20秒后过期   ttl ttl 查看key=a的过期剩余时间    Redis数据类型  String - 字符串类型 Hash - Hash类型 List - 列表类型 Set - 集合类型 Zset - 有序集合类型  String字符串类型   String最大512mb 建议单个kv不超过100kb","title":"Redis基础"},{"content":"Spring Boot学习 SpringBoot概述 Spring Boot诞生历史  Spring的缺点：配置过于繁琐 Spring Boot开发团队：Pivotal  Spring Boot简洁  简化初始搭建以及开发过程 不再需要定义样板化的配置 快速应用开发领域 天下武功，唯快不破  Spring、Spring MVC和Spring Boot  Spring最初利用IOC和AOP解耦 按照这种模式搞了MVC框架 写很多样板代码很麻烦，就有了Spring Boot Spring Cloud是在Spring Boot基础上诞生的  Spring Boot核心特点  开箱即用 约定优于配置  Spring Boot版本介绍  CURRENT ：最新的GA版本 GA(General Availability)：发布版本 SNAPSHOP（快照）：该版本的内容会被随时的修改  Spring Boot 2.0都更新了什么  环境升级:java 8+, tomcat 8+，Thymeleaf 3,，Hibernate 5.2 默认的软件优化: Spring Security 新的功能:http2.0的支持 https://github.com/spring-projects/spring-boot/wiki/spring-boot-2.0-release-notes  ","permalink":"https://rex0520.github.io/posts/back/framework/springboot/springboot%E8%AE%B0%E5%BD%95/","summary":"Spring Boot学习 SpringBoot概述 Spring Boot诞生历史  Spring的缺点：配置过于繁琐 Spring Boot开发团队：Pivotal  Spring Boot简洁  简化初始搭建以及开发过程 不再需要定义样板化的配置 快速应用开发领域 天下武功，唯快不破  Spring、Spring MVC和Spring Boot  Spring最初利用IOC和AOP解耦 按照这种模式搞了MVC框架 写很多样板代码很麻烦，就有了Spring Boot Spring Cloud是在Spring Boot基础上诞生的  Spring Boot核心特点  开箱即用 约定优于配置  Spring Boot版本介绍  CURRENT ：最新的GA版本 GA(General Availability)：发布版本 SNAPSHOP（快照）：该版本的内容会被随时的修改  Spring Boot 2.0都更新了什么  环境升级:java 8+, tomcat 8+，Thymeleaf 3,，Hibernate 5.2 默认的软件优化: Spring Security 新的功能:http2.0的支持 https://github.com/spring-projects/spring-boot/wiki/spring-boot-2.0-release-notes  ","title":"SpringBoot记录"},{"content":"Spring JDBC与事务管理 Spring JDBC  Spring JDBC是Spring框架用于处理关系型数据库的模块 Spring JDBC对JDBC API进行封装，极大简化开发工作量 JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法  Spring JDBC的使用步骤  Maven工程引入依赖spring-jdbc applicationContext.xml配置DataSource数据源 在Dao注入JdbcTemplate对象，实现数据CRUD  JdbcTemplate实现增删改查 Spring JDBC配置过程代码示例：  applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate提供CRUD的API--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.dao.EmployeeDao\u0026#34;\u0026gt; \u0026lt;!--为Dao注入JdbcTemplate对象--\u0026gt; \u0026lt;property name=\u0026#34;jdbcTemplate\u0026#34; ref=\u0026#34;jdbcTemplate\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Employee.java\npackage com.imooc.spring.jdbc.entity; import java.util.Date; /** * @author Rex * @create 2021-01-05 14:44 */ public class Employee { private Integer eno; private String ename; private Float salary; private String dname; private Date hiredate; public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } public Date getHiredate() { return hiredate; } public void setHiredate(Date hiredate) { this.hiredate = hiredate; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;eno=\u0026#34; + eno + \u0026#34;, ename=\u0026#39;\u0026#34; + ename + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#34;, dname=\u0026#39;\u0026#34; + dname + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, hiredate=\u0026#34; + hiredate + \u0026#39;}\u0026#39;; } } EmployeeDao.java\npackage com.imooc.spring.jdbc.dao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; /** * @author Rex * @create 2021-01-05 14:46 */ @Repository public class EmployeeDao { private JdbcTemplate jdbcTemplate; public Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public JdbcTemplate getJdbcTemplate() { return jdbcTemplate; } public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } } SpringApplication.java\npackage com.imooc.spring.jdbc; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-05 14:52 */ public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); EmployeeDao employeeDao = context.getBean(\u0026#34;employeeDao\u0026#34;, EmployeeDao.class); Employee employee = employeeDao.findById(3308); System.out.println(employee); } }  JDBC Template的数据查询代码示例：  EmployeeDao.java\npublic Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; //查询单条数据  Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public List\u0026lt;Employee\u0026gt; findByDname(String dname){ String sql = \u0026#34;select * from Employee where dname = ?\u0026#34;; //查询复合数据  List\u0026lt;Employee\u0026gt; list = jdbcTemplate.query(sql, new Object[]{dname}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return list; } public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; findMapByDname(String dname){ String sql = \u0026#34;select eno as empno, salary as s from employee where dname=?\u0026#34;; //将查询结果作为Map进行封装  List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; maps = jdbcTemplate.queryForList(sql, new Object[]{dname}); return maps; } 单条查询测试\n@Test public void testFindById(){ Employee employee = employeeDao.findById(3308); System.out.println(employee); } 查询结果：\n[Employee{eno=3308, ename=\u0026#39;张三\u0026#39;, salary=6000.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2011-05-08 00:00:00.0}, Employee{eno=3420, ename=\u0026#39;李四\u0026#39;, salary=8700.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2006-11-11 00:00:00.0}] 多条记录查询测试\n@Test public void testFindByDname(){ List\u0026lt;Employee\u0026gt; list = employeeDao.findByDname(\u0026#34;研发部\u0026#34;); System.out.println(list); } 查询结果：\nEmployee{eno=3308, ename=\u0026#39;张三\u0026#39;, salary=6000.0, dname=\u0026#39;研发部\u0026#39;, hiredate=2011-05-08 00:00:00.0} 将查询结果以Map作为封装测试\n@Test public void testFindMapByDname(){ System.out.println(employeeDao.findMapByDname(\u0026#34;研发部\u0026#34;)); } 查询结果：\n[{empno=3308, s=6000.0}, {empno=3420, s=8700.0}]  JdbcTemplate数据写入代码示例  数据新增：\npublic int insert(Employee employee){ String sql = \u0026#34;insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)\u0026#34;; //利用update方法实现数据写入操作  return jdbcTemplate.update(sql, new Object[]{employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()}); } 测试代码：\n@Test public void testInsert(){ Employee employee = new Employee(); employee.setEno(8888); employee.setEname(\u0026#34;赵六\u0026#34;); employee.setSalary(6666f); employee.setDname(\u0026#34;研发部\u0026#34;); employee.setHiredate(new Date()); int count = employeeDao.insert(employee); System.out.println(\u0026#34;本次新增\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次插入1条数据 数据修改：\npublic int update(Employee employee){ String sql = \u0026#34;update employee set ename = ?, salary = ?, dname = ?, hiredate = ? where eno = ?\u0026#34;; int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()}); return count; } 测试代码：\n@Test public void testUpdate(){ Employee employee = employeeDao.findById(8888); employee.setSalary(employee.getSalary()+1000f); int count = employeeDao.update(employee); System.out.println(\u0026#34;本次更新\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次更新1条数据 数据删除：\npublic int delete(Integer eno){ String sql = \u0026#34;delete from employee where eno = ?\u0026#34;; return jdbcTemplate.update(sql, new Object[]{eno}); } 测试代码：\n@Test public void testDelete(){ int count = employeeDao.delete(8888); System.out.println(\u0026#34;本次删除\u0026#34;+count+\u0026#34;条数据\u0026#34;); } 测试结果：\n本次删除1条数据  Spring编程式事务 什么是事务  事务以一种可靠的、一致的方式，访问和造作数据库的程序单元 说人话：要么把事情做完，要么什么都不做，不要做一半 事务依赖于数据库实现，MySQL通过事务区作为数据缓冲地带  编程式事务  编程式事务是指通过代码手动提交回滚事务的事务控制方法 SpringJDBC通过TransactionManage事务管理器实现事务控制 事务管理器提供commit/rollback方法进行事务提交与回滚  代码示例：  ApplicationContext.xml\n\u0026lt;bean id=\u0026#34;employeeService\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.service.EmployeeService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;employeeDao\u0026#34; ref=\u0026#34;employeeDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.TransactionDefinition; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.DefaultTransactionDefinition; import java.util.Date; /** * @author Rex * @create 2021-01-05 16:31 */ public class EmployeeService { private EmployeeDao employeeDao; private DataSourceTransactionManager transactionManager; public void batchImport(){ //定义了事务默认的标准配置  TransactionDefinition definition = new DefaultTransactionDefinition(); //开始一个事务  TransactionStatus status = transactionManager.getTransaction(definition); try { for (int i = 0; i \u0026lt; 10; i++) { if ( i == 3) { throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } // //提交事务  transactionManager.commit(status); }catch (RuntimeException e){ transactionManager.rollback(status); throw e; } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } public DataSourceTransactionManager getTransactionManager() { return transactionManager; } public void setTransactionManager(DataSourceTransactionManager transactionManager) { this.transactionManager = transactionManager; } } JdbcTemplateTestor.java\n@Test public void testBatchImport(){ employeeService.batchImport(); System.out.println(\u0026#34;批量导入成功\u0026#34;); } 测试结果：\n... 16:55:40.411 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.490 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.405\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.498 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update 16:55:40.498 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.502 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.498\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.502 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update 16:55:40.503 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno, ename, salary, dname, hiredate) values(?, ?, ?, ?, ?)] 16:55:40.507 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state \u0026#39;22007\u0026#39;, error code \u0026#39;1292\u0026#39;, message [Incorrect date value: \u0026#39;2021-01-05 16:55:40.502\u0026#39; for column \u0026#39;hiredate\u0026#39; at row 1] 16:55:40.507 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback 16:55:40.507 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@3646a422] 16:55:40.521 [main] DEBUG ... java.lang.RuntimeException: 意料之外的异常...  Spring声明式事务 声明式事务  声明式事务指在不修改源码情况下通过配置形式自动实现事务控制，声明式事务本质就是AOP环绕通知 当目标方法执行成功时，自动提交事务 当目标方法抛出运行时异常时，自动事务回滚  配置过程  配置TransactionManager事务管理器 配置事务通知与事务属性 为事务通知绑定PointCut切点  代码示例：  applicationContext.xml\n\u0026lt;!--1.事务管理器，用于创建事务/提交/回滚--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--2.事务通知配置，决定哪些方法使用事务，哪些方法不使用事务--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--目标方法名为batchImport时，启用声明式事务，成功提交，运行时异常回滚--\u0026gt; \u0026lt;tx:method name=\u0026#34;batchImport\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;batch*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;\u0026gt;\u0026lt;/tx:method\u0026gt; \u0026lt;!--设置所有findXXX方法不需要使用事务--\u0026gt; \u0026lt;tx:method name=\u0026#34;find*\u0026#34; propagation=\u0026#34;NOT_SUPPORTED\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;get*\u0026#34; propagation=\u0026#34;NOT_SUPPORTED\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--3.定义声明式事务的作用范围--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(public * com.imooc..*Service.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; \u0026lt;/aop:config\u0026gt; EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import java.util.Date; public class EmployeeService { private EmployeeDao employeeDao; public void batchImport() { for (int i = 1; i \u0026lt;= 10; i++) { if(i == 3){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } 执行结果： 同上\n 事务传播行为  事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式 XML：\u0026lt;tx:method name=\u0026quot;\u0026hellip;\u0026quot; propagation=\u0026ldquo;REQUIRED\u0026rdquo;\u0026gt; 注解：@Transactional(propagation=Propagation.REQUIRED)  事务传播行为七种类型    事务传播类型 说明     PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务，加入到这个事务中。这是最常见的选择   PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行   PROPAGATION_MANADATORY 使用当前的事务，如果当前没有事务，就抛出异常   PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，就把当前事务挂起   PROPAGATION_NOT_SUPPORT 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起   PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常   PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作    Spring注解配置声明式事务 代码示例  applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;/\u0026gt; \u0026lt;!--数据源--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;usePublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--启用注解形式声明式事务--\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionManager\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; Employee.java\npackage com.imooc.spring.jdbc.entity; import java.util.Date; public class Employee { private Integer eno; private String ename; private Float salary; private String dname; private Date hiredate; public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } public Date getHiredate() { return hiredate; } public void setHiredate(Date hiredate) { this.hiredate = hiredate; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;eno=\u0026#34; + eno + \u0026#34;, ename=\u0026#39;\u0026#34; + ename + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#34;, dname=\u0026#39;\u0026#34; + dname + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, hiredate=\u0026#34; + hiredate + \u0026#39;}\u0026#39;; } } EmployeeDao.java\npackage com.imooc.spring.jdbc.dao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import javax.annotation.Resource; import java.util.List; import java.util.Map; @Repository public class EmployeeDao { @Resource private JdbcTemplate jdbcTemplate; public Employee findById(Integer eno){ String sql = \u0026#34;select * from employee where eno = ?\u0026#34;; //查询单条数据  Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return employee; } public List\u0026lt;Employee\u0026gt; findByDname(String dname){ String sql = \u0026#34;select * from employee where dname = ?\u0026#34;; //查询复合数据  List\u0026lt;Employee\u0026gt; list = jdbcTemplate.query(sql, new Object[]{dname}, new BeanPropertyRowMapper\u0026lt;Employee\u0026gt;(Employee.class)); return list; } public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; findMapByDname(String dname){ String sql = \u0026#34;select eno as empno , salary as s from employee where dname = ?\u0026#34;; //将查询结果作为Map进行封装  List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; maps = jdbcTemplate.queryForList(sql, new Object[]{dname}); return maps; } public void insert(Employee employee){ String sql = \u0026#34;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)\u0026#34;; //利用update方法实现数据写入操作  jdbcTemplate.update(sql,new Object[]{ employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate() }); } public int update(Employee employee){ String sql = \u0026#34;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?\u0026#34;; int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()}); return count; } public int delete(Integer eno){ String sql = \u0026#34;delete from employee where eno = ?\u0026#34;; return jdbcTemplate.update(sql, new Object[]{eno}); } public JdbcTemplate getJdbcTemplate() { return jdbcTemplate; } public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } } BatchService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service @Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true) public class BatchService { @Resource private EmployeeDao employeeDao; @Transactional(propagation = Propagation.REQUIRES_NEW) public void importJob1(){ for (int i = 1; i \u0026lt;= 10; i++) { Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;研发部员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;研发部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } @Transactional(propagation = Propagation.REQUIRES_NEW) public void importJob2(){ for (int i = 1; i \u0026lt;= 10; i++) { Employee employee = new Employee(); employee.setEno(9000 + i); employee.setEname(\u0026#34;市场部员工\u0026#34; + i); employee.setSalary(4500f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } EmployeeService.java\npackage com.imooc.spring.jdbc.service; import com.imooc.spring.jdbc.dao.EmployeeDao; import com.imooc.spring.jdbc.entity.Employee; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service //声明式事务核心注解 //放在类上，将声明式事务配置应用于当前类所有方法，默认事务传播为REQUIRED @Transactional public class EmployeeService { @Resource private EmployeeDao employeeDao; @Resource private BatchService batchService; @Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true) public Employee findById(Integer eno){ return employeeDao.findById(eno); } public void batchImport() { for (int i = 1; i \u0026lt;= 10; i++) { /*if(i==3){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); }*/ Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(\u0026#34;员工\u0026#34; + i); employee.setSalary(4000f); employee.setDname(\u0026#34;市场部\u0026#34;); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public void startImportJob(){ batchService.importJob1(); if(1==1){ throw new RuntimeException(\u0026#34;意料之外的异常\u0026#34;); } batchService.importJob2(); System.out.println(\u0026#34;批量导入成功\u0026#34;); } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } public BatchService getBatchService() { return batchService; } public void setBatchService(BatchService batchService) { this.batchService = batchService; } }  ","permalink":"https://rex0520.github.io/posts/back/framework/spring/springjdbc/","summary":"Spring JDBC与事务管理 Spring JDBC  Spring JDBC是Spring框架用于处理关系型数据库的模块 Spring JDBC对JDBC API进行封装，极大简化开发工作量 JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法  Spring JDBC的使用步骤  Maven工程引入依赖spring-jdbc applicationContext.xml配置DataSource数据源 在Dao注入JdbcTemplate对象，实现数据CRUD  JdbcTemplate实现增删改查 Spring JDBC配置过程代码示例：  applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/imooc?useSSL=false\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--JdbcTemplate提供CRUD的API--\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.jdbc.dao.EmployeeDao\u0026#34;\u0026gt; \u0026lt;!--为Dao注入JdbcTemplate对象--\u0026gt; \u0026lt;property name=\u0026#34;jdbcTemplate\u0026#34; ref=\u0026#34;jdbcTemplate\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Employee.","title":"Springjdbc"},{"content":"Spring 框架概述 1、Spring 是轻量级的开源的JavaEE框架 2、Spring 解决企业应用开发的复杂性 3、Spring有两个核心的部分：IOC和AOP （1）IOC：控制反转，把创建对象的过程交给Spring进行管理 （2）AOP：面向切面，不修改源代码进行功能增强 4、Spring特点 （1）方便解耦，简化开发 （2）AOP编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低API的开发难度 Core Container  Beans Core Context Expression  ","permalink":"https://rex0520.github.io/posts/back/framework/spring/spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/","summary":"Spring 框架概述 1、Spring 是轻量级的开源的JavaEE框架 2、Spring 解决企业应用开发的复杂性 3、Spring有两个核心的部分：IOC和AOP （1）IOC：控制反转，把创建对象的过程交给Spring进行管理 （2）AOP：面向切面，不修改源代码进行功能增强 4、Spring特点 （1）方便解耦，简化开发 （2）AOP编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低API的开发难度 Core Container  Beans Core Context Expression  ","title":"Spring框架概述"},{"content":"Spring AOP面向切面编程 Spring AOP  Spring AOP - Aspect Oriented Programming 面向切面编程 AOP的做法是将通用、于业务无关的功能抽象封装为切面类 切面可配置在目标方法的执行前、后运行，真正做到即插即用  Spring AOP  用到的依赖dependency：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; applicationContext.xml中schema依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- bean definitions here --\u0026gt; \u0026lt;/beans\u0026gt;  Spring AOP概念 Spring AOP与AspectJ的关系  Eclipse AspectJ，一种基于Java平台的面向切面编程的语言 Spring AOP使用AspectJWeaver实现类与方法的匹配 Spring AOP利用代理模式实现对象运行时功能扩展  几个关键概念    注解 说明     Aspect 切面，具体的可插拔组件功能类，通常一个切面只实现一个通用功能   Target Class/Method 目标类、目标方法，指真正要执行与业务相关的方法   PointCut 切入点，使用execution表达式说明切面要作用在系统的哪些类上   JoinPoint 连接点，切面运行过程中时包括了目标类/方法元数据的对象   Advice 通知，说明具体的切面的执行时机，Spring包含了五种不同类型通知    AOP配置过程  依赖AspectJ 实现切面类/方法 配置Aspect Bean 定义PointCut 配置Advice  JoinPoint核心方法    注解 说明     Object getTarget() 获取IoC容器内目标对象   Signature getSignature() 获取目标方法   Object[] getArgs() 获取目标方法参数    PointCut切点表达式 通知 五种通知类型    注解 说明     Before Advice 前置通知，目标方法运行前执行   After Returning Advice 返回后通知，目标方法返回数据后执行   After Throwing Advice 异常通知，目标方法抛出异常后执行   After Advice 后置通知，目标方法运行   Around Advice 最强大通知，自定义通知执行时机，可决定目标方法是否运行    特殊的“通知”-引介增强  引介增强(Introduction Interceptor)是对类的增强，而非方法 引介增强允许在运行时为目标类增加新属性或方法 引介增强允许在运行时改变类的行为，让类随运行环境动态变更  Spring AOP实现原理  Spring基于代理模式实现功能动态扩展，包含俩种形式 目标类拥有接口，通过JDK动态代理实现功能扩展 目标类没有接口，通过CGLib组件实现功能扩展  代理模式：  代理模式通过代理对象对原对象的实现功能扩展  静态代理示例：  UserService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public interface UserService { public void createUser(); } UserService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println(\u0026#34;执行创建用户业务逻辑\u0026#34;); } } UserServiceProxy.java\npackage com.imooc.spring.aop.service; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-05 11:49 */ //静态代理是指必须手动创建代理类的代理模式使用方式 public class UserServiceProxy implements UserService{ //持有委托类的对象  private UserService userService; public UserServiceProxy(UserService userService){ this.userService = userService; } @Override public void createUser() { System.out.println(\u0026#34;======\u0026#34; + new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;).format(new Date()) +\u0026#34;==========\u0026#34;); this.userService.createUser(); } } UserServiceProxy1.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:54 */ public class UserServiceProxy1 implements UserService { private UserService userService; public UserServiceProxy1(UserService userService){ this.userService = userService; } @Override public void createUser() { userService.createUser(); System.out.println(\u0026#34;=======后置扩展功能======\u0026#34;); } } 运行结果：\n======2021-01-05 12:28:08 008========== 执行创建用户业务逻辑 =======后置扩展功能======  动态代理示例  UserSerivce.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public interface UserService { public void createUser(); } UserServiceImpl.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 11:47 */ public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println(\u0026#34;执行创建用户业务逻辑\u0026#34;); } } EmployeeService.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 12:20 */ public interface EmployeeService { public void createEmployee(); } EmployeeServiceImpl.java\npackage com.imooc.spring.aop.service; /** * @author Rex * @create 2021-01-05 12:20 */ public class EmployeeServiceImpl implements EmployeeService{ @Override public void createEmployee() { System.out.println(\u0026#34;执行创建员工实现类\u0026#34;); } } ProxyInvocationHandler.java\npackage com.imooc.spring.aop.service; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.text.SimpleDateFormat; import java.util.Date; /** * InvocationHandler是JDK提供的反射类，用于在JDK动态代理中对目标方法进行增强 * InvocationHandler实现类与切面类的的环绕通知类似 * @author Rex * @create 2021-01-05 12:06 */ public class ProxyInvocationHandler implements InvocationHandler { private Object target; //目标对象  private ProxyInvocationHandler(Object target){ this.target = target; } /** * 在invoke()方法对目标方法进行增强 * @param proxy 代理类对象 * @param method 目标方法对象 * @param args 目标方法实参 * @return 目标方法运行后返回值 * @throws Throwable 目标方法抛出的异常 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;======\u0026#34; +new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;).format(new Date()) + \u0026#34;======\u0026#34;); Object ret = method.invoke(target, args);//调用目标方法， ProceedingJoinPoint.proceed()  return ret; } public static void main(String[] args) { UserService userService = new UserServiceImpl(); ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler(userService); //动态创建代理类  UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), proxyInvocationHandler); userServiceProxy.createUser(); //动态代理，必须实现接口才可以运行  EmployeeService employeeService = new EmployeeServiceImpl(); EmployeeService employeeServiceProxy = (EmployeeService) Proxy.newProxyInstance(employeeService.getClass().getClassLoader(), employeeService.getClass().getInterfaces(), new ProxyInvocationHandler(employeeService)); employeeServiceProxy.createEmployee(); } } 运行结果：\n======2021-01-05 12:23:20 020====== 执行创建用户业务逻辑 ======2021-01-05 12:23:20 020====== 执行创建员工实现类  CGLib实现代理类  CGLib是运行时字节码增强技术 Spring AOP扩展无接口类使用CGLib AOP会运行时生成目标继承类字节码的方式进行行为扩展  AOP代码实例： XML形式  applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.imooc.spring.aop.dao.UserDao\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeDao\u0026#34; class=\u0026#34;com.imooc.spring.aop.dao.EmployeeDao\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.imooc.spring.aop.service.UserService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;employeeService\u0026#34; class=\u0026#34;com.imooc.spring.aop.service.EmployeeService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;employeeDao\u0026#34; ref=\u0026#34;employeeDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;methodChecker\u0026#34; class=\u0026#34;com.imooc.spring.aop.aspect.MethodChecker\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.imooc..*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;methodChecker\u0026#34;\u0026gt; \u0026lt;aop:around method=\u0026#34;check\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:around\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; UserDao.java\npackage com.imooc.spring.aop.dao; /** * 用户表Dao */ public class UserDao { public void insert(){ System.out.println(\u0026#34;新增用户数据\u0026#34;); } } EmployeeDao.java\npackage com.imooc.spring.aop.dao; /** * 员工表Dao * @author Rex * @create 2021-01-04 23:20 */ public class EmployeeDao { public void insert(){ System.out.println(\u0026#34;新增员工数据\u0026#34;); } } Userervice.java\npackage com.imooc.spring.aop.service; import com.imooc.spring.aop.dao.UserDao; /** * 用户服务 * @author Rex * @create 2021-01-04 22:46 */ public class UserService { private UserDao userDao; public void createUser(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;执行员工入职业务逻辑\u0026#34;); userDao.insert(); } public String generateRandomPassword(String type, Integer length){ System.out.println(\u0026#34;按\u0026#34; + type + \u0026#34;方式生成\u0026#34; + length + \u0026#34;位随机密码\u0026#34;); return \u0026#34;Zxcquil\u0026#34;; } public UserDao getUserDao() { return userDao; } public void setUserDao(UserDao userDao) { this.userDao = userDao; } } EmployeeService.java\npackage com.imooc.spring.aop.service; import com.imooc.spring.aop.dao.EmployeeDao; /** * 员工服务 * @author Rex * @create 2021-01-04 23:20 */ public class EmployeeService { private EmployeeDao employeeDao; public void entry(){ System.out.println(\u0026#34;执行员工入职业务逻辑\u0026#34;); employeeDao.insert(); } public EmployeeDao getEmployeeDao() { return employeeDao; } public void setEmployeeDao(EmployeeDao employeeDao) { this.employeeDao = employeeDao; } } MethodCheck.java\npackage com.imooc.spring.aop.aspect; import org.aspectj.lang.ProceedingJoinPoint; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Rex * @create 2021-01-04 23:07 */ public class MethodChecker { //ProceedingJoinPoint是JoinPoint的升级版，在原有功能外，还可以控制目标方法是否执行  public Object check(ProceedingJoinPoint pjp) throws Throwable { try { long startTime = new Date().getTime(); Object ret = pjp.proceed();//执行目标方法  long endTime = new Date().getTime(); long duration = endTime - startTime; if (duration \u0026gt;= 1000){ String className = pjp.getTarget().getClass().getName(); String methodName = pjp.getSignature().getName(); SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss sss\u0026#34;); String now = sdf.format(new Date()); System.out.println(\u0026#34;===========\u0026#34;+now+\u0026#34;:\u0026#34;+className+\u0026#34;.\u0026#34;+methodName + \u0026#34;(\u0026#34; + duration+\u0026#34;ms)======\u0026#34;); } return ret; } catch (Throwable throwable) { System.out.println(\u0026#34;Exception message:\u0026#34;+throwable.getMessage()); throw throwable; } } } SpringContext.java\npackage com.imooc.spring.aop; import com.imooc.spring.aop.service.UserService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-04 23:20 */ public class SpringContext { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); userService.createUser(); } } 执行结果：\n执行员工入职业务逻辑 新增用户数据 ===========2021-01-05 14:15:17 017:com.imooc.spring.aop.service.UserService.createUser(3046ms)======  注解形式  applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;/beans\u0026gt; BookShop.java\npackage com.imooc.spring.aop.entity; import org.springframework.stereotype.Component; /** * @author Rex * @create 2021-01-05 10:53 */ @Component public class BookShop { public void sellingBooks(){ System.out.println(\u0026#34;卖出一本java基础书籍\u0026#34;); } } MethodPro.java\npackage com.imooc.spring.aop.aspect; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; /** * @author Rex * @create 2021-01-05 10:54 */ @Component @Aspect public class MethodPro { // @Around(\u0026#34;execution(public * com.imooc..*.*())\u0026#34;)  public void welcome(ProceedingJoinPoint pjd) throws Throwable { System.out.println(\u0026#34;欢迎光临慕课小店\u0026#34;); pjd.proceed(); System.out.println(\u0026#34;欢迎再次光临\u0026#34;); } @Before(\u0026#34;execution(public * com.imooc..*.*(..))\u0026#34;) public void preSales(){ System.out.println(\u0026#34;=====售前服务=====\u0026#34;); } @After(\u0026#34;execution(public * com.imooc..*.*(..))\u0026#34;) public void afterSale(){ System.out.println(\u0026#34;=====售后服务======\u0026#34;); } } SpringApplication.java\npackage com.imooc.spring.aop; import com.imooc.spring.aop.entity.BookShop; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author Rex * @create 2021-01-05 11:03 */ @ComponentScan public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); BookShop bookShop = context.getBean(\u0026#34;bookShop\u0026#34;, BookShop.class); bookShop.sellingBooks(); } } 执行结果：\n=====售前服务===== 卖出一本java基础书籍 =====售后服务======  ","permalink":"https://rex0520.github.io/posts/back/framework/spring/springaop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/","summary":"Spring AOP面向切面编程 Spring AOP  Spring AOP - Aspect Oriented Programming 面向切面编程 AOP的做法是将通用、于业务无关的功能抽象封装为切面类 切面可配置在目标方法的执行前、后运行，真正做到即插即用  Spring AOP  用到的依赖dependency：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; applicationContext.xml中schema依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- bean definitions here --\u0026gt; \u0026lt;/beans\u0026gt;  Spring AOP概念 Spring AOP与AspectJ的关系  Eclipse AspectJ，一种基于Java平台的面向切面编程的语言 Spring AOP使用AspectJWeaver实现类与方法的匹配 Spring AOP利用代理模式实现对象运行时功能扩展  几个关键概念    注解 说明     Aspect 切面，具体的可插拔组件功能类，通常一个切面只实现一个通用功能   Target Class/Method 目标类、目标方法，指真正要执行与业务相关的方法   PointCut 切入点，使用execution表达式说明切面要作用在系统的哪些类上   JoinPoint 连接点，切面运行过程中时包括了目标类/方法元数据的对象   Advice 通知，说明具体的切面的执行时机，Spring包含了五种不同类型通知    AOP配置过程  依赖AspectJ 实现切面类/方法 配置Aspect Bean 定义PointCut 配置Advice  JoinPoint核心方法    注解 说明     Object getTarget() 获取IoC容器内目标对象   Signature getSignature() 获取目标方法   Object[] getArgs() 获取目标方法参数    PointCut切点表达式 通知 五种通知类型    注解 说明     Before Advice 前置通知，目标方法运行前执行   After Returning Advice 返回后通知，目标方法返回数据后执行   After Throwing Advice 异常通知，目标方法抛出异常后执行   After Advice 后置通知，目标方法运行   Around Advice 最强大通知，自定义通知执行时机，可决定目标方法是否运行    特殊的“通知”-引介增强  引介增强(Introduction Interceptor)是对类的增强，而非方法 引介增强允许在运行时为目标类增加新属性或方法 引介增强允许在运行时改变类的行为，让类随运行环境动态变更  Spring AOP实现原理  Spring基于代理模式实现功能动态扩展，包含俩种形式 目标类拥有接口，通过JDK动态代理实现功能扩展 目标类没有接口，通过CGLib组件实现功能扩展  代理模式：  代理模式通过代理对象对原对象的实现功能扩展  静态代理示例：  UserService.","title":"Springaop面向切面编程"},{"content":"Spring IoC与Bean管理 Spring快速入门 IoC控制反转  IoC控制反转，全称Inverse of Control，是一种设计理念，把对象创建和对象之间的调用过程，交给spring进行管理 由代理人来创建与管理对象，消费者通过代理人来获取对象 IoC的目的是降低对象之间直接耦合 加入IoC容器将对象统一管理，让对象关联变为弱耦合  DI依赖注入  IoC是设计理念，是现代程序设计遵循的标准，是宏观目标 DI(Dependency Injection)是具体技术实现，是微观实现 DI在Java中利用反射技术实现对象注入（Injection）  Spring Spring的含义  Spring可从狭义与广义俩个角度看待 狭义的Spring是指Spring框架（Spring Framework） 广义的Spring是指Spring生态体系  狭义的Spring  Spring框架是企业开发复杂性的一站式解决方案 Spring框架的核心是IoC容器与AOP面向切面变成 Spring IoC负责创建与管理系统对象，并在此基础上扩展功能  传统开发方式  对象直接引用导致对象硬性关联，程序难以扩展维护  Spring IoC  IoC容器是Spring生态的地基用于统一创建与管理对象依赖  Spring IoC容器职责  对象的控制器交由第三方统一管理（IoC控制反转） 利用Java反射技术实现运行时对象创建与关联（DI依赖注入） 基于配置提高应用程序的可维护性与扩展性  IOC底层原理：  xml解析、工厂模式、反射  IOC(接口)   IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n  Spring提供IOC容器实现两种方式：（两个接口）\n  BeanFactory：IOC容器基本实现方式，是Spring内部的使用的接口，不提供给开发人员使用\n特点：\n​\t加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\n  ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能， 一般由开发人员进行使用\n特点：加载配置文件时候就会把配置文件对象进行创建\n    ApplicationContext接口\n  代码示例：  需要引入的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Apple.java\npackage com.imooc.spring.ioc.entity; /** * @author CubeMonkey * @create 2020-11-27 23:57 */ public class Apple { private String title; private String color; private String origin; public Apple() { } public Apple(String title, String color, String origin) { this.title = title; this.color = color; this.origin = origin; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public String getOrigin() { return origin; } public void setOrigin(String origin) { this.origin = origin; } } applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中--\u0026gt; \u0026lt;bean id=\u0026#34;sweetApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;sourApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;青苹果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中亚\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;绿色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;softApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;金帅\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中国\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;金色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;rdApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;蛇果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;美国\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;lily\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;莉莉\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;softApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;andy\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;安迪\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;rdApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;luna\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;露娜\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;sweetApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; SpringApplication.java\npackage com.imooc.spring.ioc; import com.imooc.spring.ioc.entity.Apple; import com.imooc.spring.ioc.entity.Child; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; /** * @author CubeMonkey * @create 2020-11-30 16:14 */ public class SpringApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); Apple sweetApple = context.getBean(\u0026#34;sweetApple\u0026#34;, Apple.class); System.out.println(sweetApple.getTitle()); //从Ioc容器中提取beanId = lily的对象  Child lily = context.getBean(\u0026#34;lily\u0026#34;, Child.class); lily.eat(); Child andy = context.getBean(\u0026#34;andy\u0026#34;, Child.class); andy.eat(); Child luna = context.getBean(\u0026#34;luna\u0026#34;, Child.class); luna.eat(); } }  XML管理对象(Bean) 三种配置方式 1. 基于XML配置Bean 实例化Bean的三种方式   基于构造方法对象实例化\n核心代码：\n applicationContext.xml\n\u0026lt;bean id=\u0026#34;apple2\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;    基于静态工厂实例化\n核心代码：\n applicationContext.xml\n\u0026lt;!--利用静态工厂获取对象--\u0026gt; \u0026lt;bean id=\u0026#34;apple4\u0026#34; class=\u0026#34;com.imooc.spring.ioc.factory.AppleStaticFactory\u0026#34; factory-method=\u0026#34;createSweetApple\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; ​\tAppleStaticFactory.java\npackage com.imooc.spring.ioc.factory; import com.imooc.spring.ioc.entity.Apple; /** * 静态工厂通过静态方法创建对象，隐藏创建对象的细节 * @author CubeMonkey * @create 2020-12-01 18:50 */ public class AppleStaticFactory { public static Apple createSweetApple(){ //logger.info(\u0026#34;\u0026#34;)  Apple apple = new Apple(); apple.setTitle(\u0026#34;红富士\u0026#34;); apple.setOrigin(\u0026#34;欧洲\u0026#34;); apple.setColor(\u0026#34;红色\u0026#34;); return apple; } }    基于工厂实例方法实例化\n核心代码：\n applicationContext.xml\n\u0026lt;!--利用工厂实例方法获取对象--\u0026gt; \u0026lt;bean id=\u0026#34;factoryInstance\u0026#34; class=\u0026#34;com.imooc.spring.ioc.factory.AppleFactoryInstance\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;apple5\u0026#34; factory-bean=\u0026#34;factoryInstance\u0026#34; factory-method=\u0026#34;createSweetApple\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; AppleFactoryInstance.java\npackage com.imooc.spring.ioc.factory; import com.imooc.spring.ioc.entity.Apple; /** * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程 * @author CubeMonkey * @create 2020-12-01 18:56 */ public class AppleFactoryInstance { public Apple createSweetApple(){ Apple apple = new Apple(); apple.setTitle(\u0026#34;红富士\u0026#34;); apple.setOrigin(\u0026#34;欧洲\u0026#34;); apple.setColor(\u0026#34;红色\u0026#34;); return apple; } }    2. 基于注解配置Bean 3. 基于Java代码配置Bean 从IoC容器获取bean 方法：  Apple apple4 = context.getBean(\u0026#34;apple4\u0026#34;, Apple.class);//推荐 System.out.println(apple4.getTitle()); Apple apple3 = (Apple)context.getBean(\u0026#34;apple3\u0026#34;); System.out.println(apple3.getTitle());  id与name属性相同点  bean id 与name都是设置对象在IoC容器中唯一标识 两者在同一配置文件中都不允许出现重复 两者允许在多个配置文件中出现重复，新对象覆盖旧对象  id与name属性区别  id要求更为严格，一次只能定义一个对象标识（推荐） name更为宽松，一次允许定义多个对象标识 tips:id与name的命名有意义，按驼峰命名书写  路径表达式 加载单个配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;classpath:applicationContext.xml\u0026#34;); 加载多配置文件 String[] configLocations = new String[]{\u0026#34;classpath:applicationContext.xml\u0026#34;, {\u0026#34;classpath:applicationContext-1.xml\u0026#34;}}; ApplicationContext context = new ClassPathXmlApplicationContext(configLocations) 路径表达式说明    表达式实例 说明     classpath:config.xml 扫描classpath根路径(不包含jar)的config.xml   classpath:com/imooc/config.xml 扫描classpath下(不包含jar)com.imooc包中的config.xml   classpath*:com/imooc/config.xml 扫描classpath下(包含jar)com.imooc包中的config.xml   classpath:config-*.xml 扫描classpath根路径下所有以config-开头的XML文件   classpath:com/**/config.xml 扫描com包下(包含任何子包)的config.xml   file:c/config.xml 扫描c盘根路径config.xml    依赖注入 对象依赖注入   依赖注入是指运行时将容器内对象利用反射赋给其他对象的操作\n  基于setter方法注入对象\n\u0026lt;bean name=\u0026#34;sweetApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;!-- IoC容器自动利用反射机制运行时调用setXxx方法为属性赋值--\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;红富士\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;红色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;欧洲\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;123\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean name=\u0026#34;lily\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;莉莉\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--利用ref注入依赖对象--\u0026gt; \u0026lt;property name=\u0026#34;apple\u0026#34; ref=\u0026#34;sweetApple\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   基于构造方法注入对象\n\u0026lt;bean id=\u0026#34;sourApple\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Apple\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;title\u0026#34; value=\u0026#34;青苹果\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;绿色\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;origin\u0026#34; value=\u0026#34;中亚\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;price\u0026#34; value=\u0026#34;9.8\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;andy\u0026#34; class=\u0026#34;com.imooc.spring.ioc.entity.Child\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;安迪\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;apple\u0026#34; ref=\u0026#34;sourApple\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;   集合依赖注入 注入List \u0026lt;bean id = \u0026#34;...\u0026#34; class = \u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;具体值\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Set \u0026lt;bean id = \u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someSet\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;具体值\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Map \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;someMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;k1\u0026#34; value=\u0026#34;v1\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;k2\u0026#34; value-ref=\u0026#34;beanId\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注入Properties \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;properties name=\u0026#34;someProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;k1\u0026#34;\u0026gt;v1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;k2\u0026#34;\u0026gt;v2\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/bean\u0026gt; 查看容器内对象 String[] beanNames = context.getBeanDefinitionNames(); bean scope属性  bean scope属性用于决定对象何时被创建与作用范围 bean scope配置将影响容器内对象的数量 bean scope默认值singleton(单例)，指全局共享同一个对象实例  bean scope属性清单    scope属性 说明     singleton 单例(默认值)，每一个容器有且只有唯一的实例，实例被全局共享   prototype 多例，每次使用时都是创建一个实例   request web环境下，每一次独立请求存在唯一实例   session web环境下，每一个session存在有唯一实例   applicaiton web环境下，每一个ServletContext存在唯一实例   websocket 每一次WebSocket连接中存在唯一实例    singleton与prototype对比     singleton prototype     对象数量 全局唯一 存在多个   实例化时机 IoC容器启动时 getBean()或对象注入时   线程安全问题 存在 不存在   执行效率 高 低    bean生命周期 Ioc容器极简实现 示例代码： package com.imooc.spring.ioc.context; import org.dom4j.Document; import org.dom4j.Element; import org.dom4j.Node; import org.dom4j.io.SAXReader; import java.io.File; import java.lang.reflect.Method; import java.net.URLDecoder; import java.util.HashMap; import java.util.List; import java.util.Locale; import java.util.Map; /** * @author Rex * @create 2020-12-31 16:08 */ public class ClassPathXmlApplicationContext implements ApplicationContext{ private Map iocContainer = new HashMap(); public ClassPathXmlApplicationContext(){ try { String filePath = this.getClass().getResource(\u0026#34;/applicationContext.xml\u0026#34;).getPath(); filePath = new URLDecoder().decode(filePath, \u0026#34;utf-8\u0026#34;); SAXReader reader = new SAXReader(); Document document = reader.read(new File(filePath)); List\u0026lt;Node\u0026gt; nodes = document.getRootElement().selectNodes(\u0026#34;bean\u0026#34;); for (Node node : nodes) { Element ele = (Element) node; String id = ele.attributeValue(\u0026#34;id\u0026#34;); String className = ele.attributeValue(\u0026#34;class\u0026#34;); Class\u0026lt;?\u0026gt; c = Class.forName(className); Object obj = c.newInstance(); List\u0026lt;Node\u0026gt; properties = ele.selectNodes(\u0026#34;property\u0026#34;); for (Node p : properties) { Element property = (Element) p; String propName = property.attributeValue(\u0026#34;name\u0026#34;); String propValue = property.attributeValue(\u0026#34;value\u0026#34;); String setMethodName = \u0026#34;set\u0026#34;+propName.substring(0, 1).toUpperCase() + propName.substring(1); System.out.println(\u0026#34;准备执行\u0026#34;+setMethodName+\u0026#34;方法注入数据\u0026#34;); Method setMethod = c.getMethod(setMethodName, String.class); setMethod.invoke(obj, propValue); } iocContainer.put(id, obj); } System.out.println(iocContainer); System.out.println(\u0026#34;IOC容器初始化完毕\u0026#34;); }catch (Exception e){ e.printStackTrace(); } } @Override public Object getBean(String beanId) { return iocContainer.get(beanId); } } ","permalink":"https://rex0520.github.io/posts/back/framework/spring/springioc%E4%B8%8Ebean%E7%AE%A1%E7%90%86/","summary":"Spring IoC与Bean管理 Spring快速入门 IoC控制反转  IoC控制反转，全称Inverse of Control，是一种设计理念，把对象创建和对象之间的调用过程，交给spring进行管理 由代理人来创建与管理对象，消费者通过代理人来获取对象 IoC的目的是降低对象之间直接耦合 加入IoC容器将对象统一管理，让对象关联变为弱耦合  DI依赖注入  IoC是设计理念，是现代程序设计遵循的标准，是宏观目标 DI(Dependency Injection)是具体技术实现，是微观实现 DI在Java中利用反射技术实现对象注入（Injection）  Spring Spring的含义  Spring可从狭义与广义俩个角度看待 狭义的Spring是指Spring框架（Spring Framework） 广义的Spring是指Spring生态体系  狭义的Spring  Spring框架是企业开发复杂性的一站式解决方案 Spring框架的核心是IoC容器与AOP面向切面变成 Spring IoC负责创建与管理系统对象，并在此基础上扩展功能  传统开发方式  对象直接引用导致对象硬性关联，程序难以扩展维护  Spring IoC  IoC容器是Spring生态的地基用于统一创建与管理对象依赖  Spring IoC容器职责  对象的控制器交由第三方统一管理（IoC控制反转） 利用Java反射技术实现运行时对象创建与关联（DI依赖注入） 基于配置提高应用程序的可维护性与扩展性  IOC底层原理：  xml解析、工厂模式、反射  IOC(接口)   IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n  Spring提供IOC容器实现两种方式：（两个接口）\n  BeanFactory：IOC容器基本实现方式，是Spring内部的使用的接口，不提供给开发人员使用\n特点：\n​\t加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\n  ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能， 一般由开发人员进行使用","title":"Springioc与bean管理"},{"content":"Spring Test与JUnit4整合 Spring Test测试模块  Spring Test是Spring中用于测试的模块 Sprint Test对JUnit单元测试框架有良好的整合 通过Spring Test可在JUnit在单元测试时自动初始化IoC容器  Spring与JUnit4整合过程  Maven工程依赖spring-test 利用@RunWith与@ContextConfiguration描述测试用例类 测试用例类从容器获取对象完成测试用例的执行  ","permalink":"https://rex0520.github.io/posts/back/framework/spring/springtest%E4%B8%8Ejunit4%E6%95%B4%E5%90%88/","summary":"Spring Test与JUnit4整合 Spring Test测试模块  Spring Test是Spring中用于测试的模块 Sprint Test对JUnit单元测试框架有良好的整合 通过Spring Test可在JUnit在单元测试时自动初始化IoC容器  Spring与JUnit4整合过程  Maven工程依赖spring-test 利用@RunWith与@ContextConfiguration描述测试用例类 测试用例类从容器获取对象完成测试用例的执行  ","title":"Springtest与junit4整合"},{"content":"基于Java Config配置的IoC容器 基于Java Config的优势  完全摆脱XML的束缚，使用独立Java类管理对象与依赖 注解配置相对分散，利用Java Config可对配置集中管理 可以在编译时进行依赖检查，不容易出错  Java Config核心注解    注解 说明     @Configuration 描述类，说明当前类是Java Config配置类，完全替代XML文件   @Bean 描述方法，方法返回对象将被IoC容器管理，beanId默认为方法名   @ImportResource 描述类，加载静态文件，可使用@Value注解获取   @CompoenentScan 描述类，同XML的context:component-scan标签    ","permalink":"https://rex0520.github.io/posts/back/framework/spring/%E5%9F%BA%E4%BA%8Ejavaconfig%E9%85%8D%E7%BD%AE%E7%9A%84ioc%E5%AE%B9%E5%99%A8/","summary":"基于Java Config配置的IoC容器 基于Java Config的优势  完全摆脱XML的束缚，使用独立Java类管理对象与依赖 注解配置相对分散，利用Java Config可对配置集中管理 可以在编译时进行依赖检查，不容易出错  Java Config核心注解    注解 说明     @Configuration 描述类，说明当前类是Java Config配置类，完全替代XML文件   @Bean 描述方法，方法返回对象将被IoC容器管理，beanId默认为方法名   @ImportResource 描述类，加载静态文件，可使用@Value注解获取   @CompoenentScan 描述类，同XML的context:component-scan标签    ","title":"基于javaconfig配置的ioc容器"},{"content":"基于注解配置IoC容器 基于注解的优势  摆脱繁琐的XML形式的bean与依赖注入配置 基于“声明式”的原则，更适合轻量级的现代企业应用 让代码可读性变得更好，让研发人员拥有更好的开发体验  三类注解  组件类型注解-声明当前类的功能与职责 自动装配注解-根据属性特征自动注入对象 元数据注解-更细化的辅助IoC容器管理对象的 注解  组件类型注解： 四种组件类型注解    注解 说明     @Component 组件注解，通用注解，被该注解描述的类将被IoC容器管理并实例化   @Controller xA语义注解，说明当前类是MVC应用中的控制器类   @Service 语义注解，说明当前类是Service业务服务类   @Repository 语义注解，说明当前类用于业务持久层，通常描述对应Dao类    开启组件扫描： \u0026lt;!--XML配置开启组件扫描，才能使用注解--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;regex\u0026#34; expression=\u0026#34;com.imooc.exl.*\u0026#34;\u0026gt; \u0026lt;/context:exclude-filter\u0026gt; \u0026lt;/context:component-scan\u0026gt; 基于注解初始化IoC容器 ​\tapplicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--在IoC容器初始化时自动扫描四种组件类型注解并完成实例化 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 自动装配注解： 两类自动装配注解：    分类 注解 说明     按类型装配 @Autowired 按容器内对象类型动态注入属性，由Spring机构提供    @Inject 基于JSR-330(Dependency Injection for Java)标准，其他同@Autowired,但不支持request属性   按名称装配 @Named 与@Inject配合使用，JSR-330规范，按属性名自动装配属性    @Resource 基于JSR-250规范，优先按名称，再按类型智能匹配    Autowired: pring IoC容器会自动通过反射技术将属性private修饰符自动改为public，直接进行赋值, 不再执行set方法。如果装配注解放在set方法上，则自动按类型/名称对set方法参数进行注入\nResource:  @Resource设置name属性，则按照name在IoC容器中将bean注入 @Resource未设置name属性  2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配注入 2.2 按属性名未匹配，则按类型进行匹配，同autowired，需加入@Primary解决冲突 使用建议：在使用@Resource对象时，推荐设置name或保证属性名与bean名称一致  元数据注解    注解 说明     @Primary 按类型装配时出现多个相同类型对象，拥有此注解对象优先被注入   @PostConstruct 描述方法，相当于XML中init-method配置的注解版本   @PreDestory 描述方法，相当于XML中destroy-method配置的注解版本   @Scope 设置对象的scope属性   @Value 为属性注入静态数据    ","permalink":"https://rex0520.github.io/posts/back/framework/spring/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEioc%E5%AE%B9%E5%99%A8/","summary":"基于注解配置IoC容器 基于注解的优势  摆脱繁琐的XML形式的bean与依赖注入配置 基于“声明式”的原则，更适合轻量级的现代企业应用 让代码可读性变得更好，让研发人员拥有更好的开发体验  三类注解  组件类型注解-声明当前类的功能与职责 自动装配注解-根据属性特征自动注入对象 元数据注解-更细化的辅助IoC容器管理对象的 注解  组件类型注解： 四种组件类型注解    注解 说明     @Component 组件注解，通用注解，被该注解描述的类将被IoC容器管理并实例化   @Controller xA语义注解，说明当前类是MVC应用中的控制器类   @Service 语义注解，说明当前类是Service业务服务类   @Repository 语义注解，说明当前类用于业务持久层，通常描述对应Dao类    开启组件扫描： \u0026lt;!--XML配置开启组件扫描，才能使用注解--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.imooc\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;regex\u0026#34; expression=\u0026#34;com.imooc.exl.*\u0026#34;\u0026gt; \u0026lt;/context:exclude-filter\u0026gt; \u0026lt;/context:component-scan\u0026gt; 基于注解初始化IoC容器 ​\tapplicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--在IoC容器初始化时自动扫描四种组件类型注解并完成实例化 @Repository @Service @Controller @Component --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.","title":"基于注解配置ioc容器"},{"content":"反射Reflect 什么是反射  反射(Reflect)是在运行时动态访问类与对象的技术 反射是JDK1.2版本后的高级特性，隶属于java.lang.reflect 大多是Java框架都基于反射实现参数、动态注入等特性  反射的核心类  Class类 Constructor构造方法类 Method方法类 Field成员变量类  Class类  Class是JVM中代表\u0026quot;类和接口\u0026quot;类 Class对象具体包含了某个特定类的结构信息 通过Class对象可获取对应类的构造方法/方法/成员变量  Class核心方法    方法 用途     Class.forName() 静态方法，用于获取指定Class对象   classObj.newInstance() 通过默认构造方法创建新的对象   classObj.getConstructor() 获得指定的public修饰构造方法Construct对象   classObj.getMethod() 获取指定的public修饰方法Method对象   classObj.getField() 获取指定的public修饰成员变量的Field对象    使用案例：  Employee.java\npackage com.imooc.reflect.entity; /** * 员工实体类 * @author CubeMonkey * @create 2020-10-21 16:01 */ public class Employee { static{ System.out.println(\u0026#34;Employee已被加载到内存中，并已初始化\u0026#34;); } private Integer eno; private String ename; private Float salary; private String dname; public Employee(){ System.out.println(\u0026#34;Employee默认构造方法已被执行\u0026#34;); } public Integer getEno() { return eno; } public void setEno(Integer eno) { this.eno = eno; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } } ClassSample.java\npackage com.imooc.reflect; import com.imooc.reflect.entity.Employee; /** * @author CubeMonkey * @create 2020-10-21 16:03 */ public class ClassSample { public static void main(String[] args) { try { //Class.forName()方法将指定的类加载到jvm中，并返回对应Class对象  Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); System.out.println(\u0026#34;Employee已被加载到jvm\u0026#34;); //newInstance通过默认构造方法创建新的对象  Employee employee = (Employee) employeeClass.newInstance(); System.out.println(employee); } catch (ClassNotFoundException e) { //类名与类路径书写错误时抛出“ClassNotFoundException”异常  e.printStackTrace(); } catch (IllegalAccessException e) { //非法访问异常，当在作用域外访问对象方法或成员变量时抛出  e.printStackTrace(); } catch (InstantiationException e) { //对象无法被实例化，抛出“InstantiationException”异常  e.printStackTrace(); } } }  Constructor构造器类  Constructor类是对Java类中的构造方法的抽象 Constructor对象包含了具体类的某个具体构造方法的声明 通过Constructor对象调用带参构造方法创建对象  Constructor类核心方法    方法 用途     classObj.getConstructor() 获取指定public修饰的构造方法对象   constructorObj.newInstance() 通过对应的构造方法创建对象    使用案例：  ConstructorSample.java\npackage com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /** * 利用带参构造方法创建对象 * @author CubeMonkey * @create 2020-10-22 15:08 */ public class ConstructorSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李雷\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); System.out.println(employee); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { //没有找到与之对应格式的方法  e.printStackTrace(); } catch (IllegalAccessException e) { //非法访问  e.printStackTrace(); } catch (InstantiationException e) { //实例化异常（接口、抽象类）  e.printStackTrace(); } catch (InvocationTargetException e) { //当被调用的方法的内部抛出了异常而没有被捕获时  e.printStackTrace(); } } }  Method方法类  Method对象指代某个类中的方法的描述 Method对象使用classObj.getMethod()方法获取 通过Method对象调用指定对象的对应方法  Method类核心方法    方法 用途     classObj.getMethod() 获取指定public修饰的方法对象   methodObj.invoke() 调用指定对象的方法    使用案例： package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * 利用Method方法类调用 * @author CubeMonkey * @create 2020-10-22 15:29 */ public class MethodSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李雷\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Method updateSalaryMethod = employeeClass.getMethod(\u0026#34;updateSalry\u0026#34;, Float.class); Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, 1000f); System.out.println(employee1); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } Field成员变量类  Field对应某个具体类中的成员变量的声明 Field对象使用classObj.getField()方法获取 通过Field对象可为某对象成员变量赋值/取值（运行时）  Field类核心方法 ​\n   方法 用途     classObj.getField() 获取指定public修饰的成员变量   fieldObj.set() 为某对象指定成员变量赋值   fieldObj.get() 获取某对象指定成员变量数值    使用案例 package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; /** * @author CubeMonkey * @create 2020-10-23 9:45 */ public class FieldSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李磊\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Field enameField = employeeClass.getField(\u0026#34;ename\u0026#34;); enameField.set(employee, \u0026#34;李雷\u0026#34;); String ename = (String) enameField.get(employee); System.out.println(\u0026#34;ename：\u0026#34;+ename); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { //没有找到对应成员变量  e.printStackTrace(); } } } getDeclare系列方法  getDeclaredConstructor(s) | Method(s) | Field(s) 获取对应对象 getConstructor | Method | Field 只能获取public对象 访问非作用域内构造方法、方法、成员变量、会抛出异常  使用案例： package com.imooc.reflect; import com.imooc.reflect.entity.Employee; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author CubeMonkey * @create 2020-10-23 10:02 */ public class GetDeclareSample { public static void main(String[] args) { try { Class employeeClass = Class.forName(\u0026#34;com.imooc.reflect.entity.Employee\u0026#34;); Constructor constructor = employeeClass.getConstructor(Integer.class, String.class, Float.class, String.class); Employee employee = (Employee) constructor.newInstance(100, \u0026#34;李磊\u0026#34;, 3000f, \u0026#34;研发部\u0026#34;); Field[] fields = employeeClass.getDeclaredFields(); for (Field field : fields){ // System.out.println(field.getName());  if (field.getModifiers() == 1){//public修饰  Object val = field.get(employee); System.out.println(val); }else if(field.getModifiers() == 2){//private  String methodName = \u0026#34;get\u0026#34;+field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1); Method getMethod = employeeClass.getMethod(methodName); Object ret = getMethod.invoke(employee); System.out.println(ret); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } 反射在项目中的应用（I18N）  I18N.java接口\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 12:55 */ public interface I18N { public String say(); } Zhcn.java类\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 12:56 */ public class Zhcn implements I18N{ @Override public String say() { return \u0026#34;生命不息奋斗不止\u0026#34;; } } En.java类\npackage com.imooc.i18n; /** * @author CubeMonkey * @create 2020-10-23 13:05 */ public class En implements I18N { @Override public String say() { return \u0026#34;Cease to the struggle and cease to the life\u0026#34;; } } config.properties\nlanguage=com.imooc.i18n.En Application.java\npackage com.imooc.i18n; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.Properties; /** * @author CubeMonkey * @create 2020-10-23 12:59 */ public class Application { public static void say(){ Properties properties = new Properties(); String configPath = Application.class.getResource(\u0026#34;/config.properties\u0026#34;).getPath(); try { configPath = new URLDecoder().decode(configPath, \u0026#34;utf-8\u0026#34;); properties.load(new FileInputStream(configPath)); String language = properties.getProperty(\u0026#34;language\u0026#34;); I18N i18n = (I18N) Class.forName(language).newInstance(); System.out.println(i18n.say()); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static void main(String[] args) { Application.say(); } }  ","permalink":"https://rex0520.github.io/posts/back/java/reflect/","summary":"反射Reflect 什么是反射  反射(Reflect)是在运行时动态访问类与对象的技术 反射是JDK1.2版本后的高级特性，隶属于java.lang.reflect 大多是Java框架都基于反射实现参数、动态注入等特性  反射的核心类  Class类 Constructor构造方法类 Method方法类 Field成员变量类  Class类  Class是JVM中代表\u0026quot;类和接口\u0026quot;类 Class对象具体包含了某个特定类的结构信息 通过Class对象可获取对应类的构造方法/方法/成员变量  Class核心方法    方法 用途     Class.forName() 静态方法，用于获取指定Class对象   classObj.newInstance() 通过默认构造方法创建新的对象   classObj.getConstructor() 获得指定的public修饰构造方法Construct对象   classObj.getMethod() 获取指定的public修饰方法Method对象   classObj.getField() 获取指定的public修饰成员变量的Field对象    使用案例：  Employee.java\npackage com.imooc.reflect.entity; /** * 员工实体类 * @author CubeMonkey * @create 2020-10-21 16:01 */ public class Employee { static{ System.","title":"Reflect"},{"content":"Emos项目学习记录 学习点：   加密算法\n 这里采用的是IBM开发的AES算法。这种对称加密算法在加密和解密数据的时候，使用相同的密钥。也就是说密钥既可以用来加密数据，也可以解密数据。关于AES算法的优点我这里不展开说明了，大家可以自己百度查阅资料。MySQL数据库提供了内置的DES加密和解密的函数，我们只需要调用即可。加密的函数叫做AES_ENCRPT()，解密的函数叫做AES_DECRPT()\n   ​\t数据库：登录sql，若查询记录结果只有一条，可以加limit 1加快查询个数\n\u0026lt;select id=\u0026#34;login\u0026#34; parameterType=\u0026#34;com.example.emos.api.emos.model.form.LoginForm\u0026#34; resultType=\u0026#34;Integer\u0026#34;\u0026gt; SELECT id FROM tb_user WHERE username = #{username} AND password = HEX(AES_ENCRYPT(#{password}, #{username})) LIMIT 1; \u0026lt;/select\u0026gt;   数据库：数据库查询操作的返回值用封装类，防止结果为null值不能赋给一般数据类型；若是增删改返回结果肯定为数字且不为null，表示影响的记录个数，可以用一般数据类型\n  数据库：要不要用MySQL方言？，可能会存在可移植性差\n  后端：不能随意删除记录，需要查询有没有相关的引用\n  数据库：写sql的时候需要注意状态字段(status)\n  后端：分页查询的时候限制分页的start(1, +∞)，size(10, 50)\n  数据库：灵活使用数据库中的json字段\n  后端工作流中采用了QuartZ定时器引起、Activeti引擎\n  业务：审批会议前需注意：1.结束时间必须大于开始时间 2.会议开始时间不能早于当前时间\n  前端：可用day.js转换日期格式\n  数据库：数据类型的数据范围、\n日期格式： datetime: 8字节\ntimestamp：4字节 表示范围有限：~2038年就满了\n  甘特图：用于描述任务\n  工作流：通过工作流来控制审批系统\n  bug解决:   移除springdoc-openapi-spring-boot-2-webmvc依赖中的jackson-dataformat-xml，否则会使controller返回结果为xml格式\n  重复新增用户的提示不友好\n  会议室中，删除模块的bug\n  ","permalink":"https://rex0520.github.io/posts/proj/emos/emos%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","summary":"Emos项目学习记录 学习点：   加密算法\n 这里采用的是IBM开发的AES算法。这种对称加密算法在加密和解密数据的时候，使用相同的密钥。也就是说密钥既可以用来加密数据，也可以解密数据。关于AES算法的优点我这里不展开说明了，大家可以自己百度查阅资料。MySQL数据库提供了内置的DES加密和解密的函数，我们只需要调用即可。加密的函数叫做AES_ENCRPT()，解密的函数叫做AES_DECRPT()\n   ​\t数据库：登录sql，若查询记录结果只有一条，可以加limit 1加快查询个数\n\u0026lt;select id=\u0026#34;login\u0026#34; parameterType=\u0026#34;com.example.emos.api.emos.model.form.LoginForm\u0026#34; resultType=\u0026#34;Integer\u0026#34;\u0026gt; SELECT id FROM tb_user WHERE username = #{username} AND password = HEX(AES_ENCRYPT(#{password}, #{username})) LIMIT 1; \u0026lt;/select\u0026gt;   数据库：数据库查询操作的返回值用封装类，防止结果为null值不能赋给一般数据类型；若是增删改返回结果肯定为数字且不为null，表示影响的记录个数，可以用一般数据类型\n  数据库：要不要用MySQL方言？，可能会存在可移植性差\n  后端：不能随意删除记录，需要查询有没有相关的引用\n  数据库：写sql的时候需要注意状态字段(status)\n  后端：分页查询的时候限制分页的start(1, +∞)，size(10, 50)\n  数据库：灵活使用数据库中的json字段\n  后端工作流中采用了QuartZ定时器引起、Activeti引擎\n  业务：审批会议前需注意：1.结束时间必须大于开始时间 2.会议开始时间不能早于当前时间\n  前端：可用day.js转换日期格式\n  数据库：数据类型的数据范围、\n日期格式： datetime: 8字节\ntimestamp：4字节 表示范围有限：~2038年就满了","title":"Emos项目学习记录"},{"content":"emos项目准备 项目结构 已有项目：  工作流项目(emos-workflow) 小程序项目(emos-wx) 小程序后端项目(emos-wx-api)  待开发项目  Web办公系统前端项目(emos-vue) Web办公系统后端项目(emos-api)  数据表分类：    序号 类型 特征 备注     1 工作流数据表 以 act_ 开头 存储工作流的各项数据   2 定时器数据表 以 qrtz_ 开头 存储QuartZ定时器数据   3 业务表 以 tb_ 开头 保存业务数据   4 系统表 以 sys_ 开头 保存系统配置信息    后端： 依赖库：   Lombok \u0026ndash; 生成对象的Get/Set方法\n  Spring Web \u0026ndash; spring的web开发框架\n  MyBatis Framework \u0026ndash; mybatis的开发框架\n  MySQL Driver \u0026ndash; MySQL数据库驱动\n  Spring Data Redis(Access + Driver) \u0026ndash; Redis连接+驱动工具\n  Spring Data MongoDB \u0026ndash; MongoDB连接工具\n  Spring for RabbitMQ \u0026ndash; RabbitMQ消息队列连接工具\n  WebSocket \u0026ndash; 网络工具\n  Java Mail Sender \u0026ndash; 发送邮件工具\n  Jettty \u0026ndash; 因为本项目中用到了WebSocket，而且Jetty本身的IO就是非阻塞式的，所以在高并发的WebSocket环境下，Jetty比Tomcat更加适合。\n  druid \u0026ndash; mysql数据库连接池\n  springdoc \u0026ndash; 接口文档生成工具\n  Sa-Token \u0026ndash; 轻量级权限认证框架\n\u0026lt;!--核心库--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--用Redis缓存授权信息--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-dao-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--注解式权限验证--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.dev33\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sa-token-spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.20.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   项目配置 server:# jetty线程池配置jetty:threads:acceptors:4selectors:8port:8090servlet:context-path:/emos-api# 文件上传大小配置multipart:max-request-size:10MBmax-file-size:2MBspring:# 数据库连接池datasource:# 数据库池类型type:com.alibaba.druid.pool.DruidDataSourcedruid:driver-class-name:com.mysql.cj.jdbc.Driverurl:jdbc:mysql://localhost:3306/emos?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;nullCatelogMeansCurrent=trueusername:rootpassword:root# 初始连接数量initial-size:2# 最大活跃数max-active:4# 最小空闲值min-idle:4# 最大等待值max-wait:60000# 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。test-while-idle:true# 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。test-on-borrow:false# 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能test-on-return:false# Redis配置redis:database:0host:localhostport:6379password:jedis:pool:# 连接池最大连接数（使用负值表示没有限制）max-active:1000# 连接池中的最大阻塞等待时间（使用负值表示没有限制）max-wait:-1ms# 连接池中的最大空闲连接max-idle:16# 连接池中的最小空闲连接min-idle:8# MongoDB配置data:mongodb:host:localhostport:27017database:emos# 身份验证# authentication-database: admin# username:# password:sa-token:# token名称 (同时也是cookie名称)token-name:token# token有效期，单位s 默认30天, -1代表永不过期timeout:2592000# token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒activity-timeout:-1# 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录)allow-concurrent-login:true# 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token)is-share:false# token风格token-style:uuid# 配置MyBatismybatis:# mapper文件地址映射mapper-locations:classpath*:mapper/*.xml# 配置xml文件中resultType返回值的包位置type-aliases-package:com.example.emos.wx.db.pojoconfiguration:# 开启日志log-impl:org.apache.ibatis.logging.stdout.StdOutImpl# 开启驼峰转换map-underscore-to-camel-case:true# 日志配置logging:# 日志级别level:root:infocom.example.emos.wx.db.dao:warnpattern:# 日志格式console:\u0026#34;%d{yyyy/MM/dd HH:mm:ss} %-5level %msg%n\u0026#34;# 接口文档工具配置springdoc:api-docs:# 启用接口文档工具enabled:true# 配置接口文档urlpath:/doc-api.html# 用swagger来美化文档swagger-ui:# 配置swagger接口文档urlpath:/swagger-ui.htmldisable-swagger-default-url:on工具库    序号 工具库 备注     1 hutool 通用工具库   2 commons-io 文件IO通用工具库   3 zxing 生成二维码图片   4 httpcore HTTP状态码    基础配置   统一Web响应结果\npackage com.example.emos.api.common.dto; import lombok.Data; import org.apache.http.HttpStatus; import java.io.Serializable; import java.sql.ResultSet; /** * Description: 统一Web响应结果 * * @author Rex * @date 2021-09-09 10:27 */ @Data public class Result\u0026lt;T\u0026gt; implements Serializable { private static final long serialVersionUID = 1L; /** * 响应码 */ private Integer code; /** * 响应信息 */ private String msg; /** * 响应数据 */ private T data; public Result() { this.code = HttpStatus.SC_OK; this.msg = \u0026#34;success\u0026#34;; } public Result(String msg) { this(); this.msg = msg; } public Result(Integer code, String msg) { this.code = code; this.msg = msg; } public Result(Integer code, String msg, T data) { this(code, msg); this.data = data; } public static Result\u0026lt;Void\u0026gt; success(){ return new Result\u0026lt;\u0026gt;(); } public static Result\u0026lt;Void\u0026gt; success(String msg){ return new Result\u0026lt;\u0026gt;(msg); } public static \u0026lt;R\u0026gt;Result\u0026lt;R\u0026gt; success(R data){ Result\u0026lt;R\u0026gt; result = new Result\u0026lt;\u0026gt;(); result.setData(data); return result; } public static Result\u0026lt;Void\u0026gt; error(int code, String msg){ return new Result\u0026lt;\u0026gt;(code, msg); } public static Result\u0026lt;Void\u0026gt; error(String msg){ return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg); } public static Result error(){ return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, \u0026#34;未知异常，请联系管理员\u0026#34;); } }   整合SpringDoc\npackage com.example.emos.api.config; import io.swagger.v3.oas.annotations.OpenAPIDefinition; import io.swagger.v3.oas.annotations.enums.SecuritySchemeType; import io.swagger.v3.oas.annotations.info.Info; import io.swagger.v3.oas.annotations.security.SecurityScheme; import org.springframework.context.annotation.Configuration; /** * Description: 配置SpringDoc * * @author Rex * @date 2021-09-09 11:02 */ @Configuration @OpenAPIDefinition( info = @Info( title = \u0026#34;emos-api\u0026#34;, description = \u0026#34;Emos管理系统后端Java项目\u0026#34;, version = \u0026#34;1.0\u0026#34; ) ) @SecurityScheme( name = \u0026#34;token\u0026#34;, type = SecuritySchemeType.HTTP, bearerFormat = \u0026#34;JWT\u0026#34;, scheme = \u0026#34;bearer\u0026#34; ) public class SpringDocConfig { }   整合权限验证和授权\n在com.example.emos.api.config包中创建StpInterfaceImpl.java类，这个Java类就是Sa-Token框架拦截HTTP请求之后调用的类。在这个类中，我们一共要声明两个方法分别用来查询用户实际的权限和角色。然后Sa-Token框架的@SaCheckPermission或者@SaCheckRole注解会根据查询出来的权限和角色，跟注解要求的权限或者角色做匹配。\nTbUserDao.xml\n\u0026lt;select id=\u0026#34;searchUserPermissions\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;String\u0026#34;\u0026gt; SELECT DISTINCT p.permission_name FROM tb_user u JOIN tb_role r ON JSON_CONTAINS(u.role, CAST(r.id AS CHAR)) JOIN tb_permission p ON JSON_CONTAINS(r.permissions, CAST(p.id AS CHAR)) WHERE u.id=#{userId} AND u.status=1; \u0026lt;/select\u0026gt; TbUserDao.java\n@Mapper public interface TbUserDao { …… public Set\u0026lt;String\u0026gt; searchUserPermissions(int userId); } StpInterfaceImpl.java\npackage com.example.emos.api.config; import cn.dev33.satoken.stp.StpInterface; import com.example.emos.api.db.dao.TbUserDao; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.ArrayList; import java.util.List; import java.util.Set; @Component public class StpInterfaceImpl implements StpInterface { @Autowired private TbUserDao userDao; /** * 返回一个用户所拥有的权限集合 */ @Override public List\u0026lt;String\u0026gt; getPermissionList(Object loginId, String loginKey) { int userId = Integer.parseInt(loginId.toString()); Set\u0026lt;String\u0026gt; permissions = userDao.searchUserPermissions(userId); ArrayList list = new ArrayList(); list.addAll(permissions); return list; } /** * 返回一个用户所拥有的角色标识集合 */ @Override public List\u0026lt;String\u0026gt; getRoleList(Object loginId, String loginKey) { //因为本项目不需要用到角色判定，所以这里就返回一个空的ArrayList对象  ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); return list; } }   跨域配置\npackage com.example.emos.api.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * Description: 跨域请求配置 * * @author Rex * @date 2021-09-09 12:55 */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowCredentials(true) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;PATCH\u0026#34;) .maxAge(3600); } }   异常\n  自定义业务异常\npackage com.example.emos.api.common.dto.exception; import lombok.Data; import lombok.EqualsAndHashCode; /** * Description: 业务异常 * * @author Rex * @date 2021-09-09 14:22 */ @EqualsAndHashCode(callSuper = true) @Data public class EmosException extends RuntimeException{ private String msg; private Integer code = 500; public EmosException(String msg){ super(msg); this.msg = msg; } public EmosException(String msg, Integer code){ super(msg); this.msg = msg; this.code = code; } }   统一异常处理\npackage com.example.emos.api.config; import cn.dev33.satoken.exception.NotLoginException; import com.example.emos.api.common.dto.Result; import com.example.emos.api.common.exception.EmosException; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; import org.springframework.web.bind.annotation.RestControllerAdvice; /** * Description: 统一异常处理 * * @author Rex * @date 2021-09-09 14:26 */ @Slf4j @RestControllerAdvice public class GlobalExceptionHandler { /** * 处理全局异常信息 * @param e 全局异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public Result\u0026lt;Void\u0026gt; exceptionHandler(Exception e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(); } /** * 处理后端验证失败产生的异常 * @param e 校验异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(MethodArgumentNotValidException.class) public Result\u0026lt;Void\u0026gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(e.getBindingResult().getFieldError().getDefaultMessage()); } /** * 处理业务异常 * @param e 业务异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(EmosException.class) public Result\u0026lt;Void\u0026gt; emosExceptionHandler(EmosException e){ log.error(\u0026#34;执行异常\u0026#34;, e); return Result.error(e.getMsg()); } /** * 处理未登录异常 * @param e 未登录异常 * @return 返回异常信息 */ @ResponseBody @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(NotLoginException.class) public Result\u0026lt;Void\u0026gt; unLoginHandler(NotLoginException e){ return Result.error(e.getMessage()); } }     开启Java异步执行\n为什么要给Java语言增添异步执行？其实很简单，在一个业务流程中，有时候会有一些耗费时间的分支任务，如果把这些琐碎且不重要的任务用异步来执行，那么就可以减轻当前线程的执行压力。\n举个例子吧，例如有个电商网站为了吸引新用户注册，给出了赠送一年优酷会员的优惠。如果我们采用同步的执行方式，用户帐户开通之后，当前线程还要调用优酷系统的接口，开通会员帐户，并且充值一年会员。整个流程加起来还是挺耗费时间的，让新注册用户等待一两分钟才能收到注册成功的通知，用户心里肯定会怀疑：这是什么破电商网站，注册个会员就要好几分钟，我要是买东西不得卡成翔啊。\n如果我们采取异步执行的方式，电商帐户开通之后，我们把开通优酷会员的任务交给其他线程去做，当前线程就不用负责了，直接返回给用户注册成功即可。当其他线程开通优酷会员之后，给用户的手机发一个短信通知即可。你看，采用了异步执行以后，新用户注册的体验更好了。其实我这里说的异步执行就是由SpringBoot自动把任务交给线程池中某个线程去执行。你以前自己创建线程分配任务的方式，也属于异步执行。只不过有了SpringBoot之后，任务的分配更加自动了。\n关于电商网站新用户注册的例子，有的同学可能还有疑问：不用异步执行，我用消息队列来分配任务是不是也行？当然是可行的。刚才我说的异步执行陷于同一个系统中，把分支任务交给其他线程去执行。如果你用的是分布式架构，A系统想要把分支任务分配个B系统去执行，通过消息队列来分配任务完全是可行的，这也算是一种异步执行的方式。\n创建线程池：\npackage com.example.emos.api.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.task.AsyncTaskExecutor; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import java.util.concurrent.ThreadPoolExecutor; /** * Description: 线程池配置类 * * @author Rex * @date 2021-09-09 14:46 */ @Configuration public class ThreadPoolConfig { @Bean(\u0026#34;AsyncTaskExecutor\u0026#34;) public AsyncTaskExecutor taskExecutor(){ ThreadPoolTaskExecutor executorThread = new ThreadPoolTaskExecutor(); // 设置核心线程数  executorThread.setCorePoolSize(8); // 设置最大线程数  executorThread.setMaxPoolSize(16); // 设置队列容量  executorThread.setQueueCapacity(32); // 设置线程活跃时间(秒)  executorThread.setKeepAliveSeconds(60); // 设置默认线程名称  executorThread.setThreadNamePrefix(\u0026#34;task-\u0026#34;); // 设置拒绝策略  executorThread.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executorThread.initialize(); return executorThread; } } 开启SpringBoot异步执行\n​\t我们在项目的主类EmosApiApplication.java声明上面加上@EnableAsync注解即可。等将来我们发送邮件的时候，再去编写任务类。\n  预防XSS攻击\n防御XSS攻击的办法很简单，那就是对所有用户的数据先做转义处理，然后再保存到数据库里面。转义之后的信息，将来被加载到网页上面就丧失了作为脚本执行的能力。比如说上面文本框里面的脚本，经过转义之后就变成了\u0026lt;script\u0026gt;alert(\u0026quot;HelloWorld\u0026quot;)\u0026lt;/script\u0026gt;这个样子。就拿\u0026lt;script\u0026gt;来说吧，它会被渲染成\u0026lt;script\u0026gt;字符串，而不是当做脚本标签来执行。\n实现XSS内容转义\npackage com.example.emos.api.config.xss; import cn.hutool.core.util.StrUtil; import cn.hutool.http.HtmlUtil; import cn.hutool.json.JSONUtil; import javax.servlet.ReadListener; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.util.LinkedHashMap; import java.util.Map; /** * Description: httpServletRequest请求转义封装类 * 转义请求返回的结果 * @author Rex * @date 2021-09-09 15:36 */ public class XssHttpSevletRequestWrapper extends HttpServletRequestWrapper { public XssHttpSevletRequestWrapper(HttpServletRequest request) { super(request); } @Override public String getParameter(String name) { String value = super.getParameter(name); if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } return value; } @Override public String[] getParameterValues(String name) { String[] values = super.getParameterValues(name); if (values != null) { for (int i = 0; i \u0026lt; values.length; i++) { String value = values[i]; if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } values[i] = value; } } return values; } @Override public Map\u0026lt;String, String[]\u0026gt; getParameterMap() { Map\u0026lt;String, String[]\u0026gt; parameterMap = super.getParameterMap(); LinkedHashMap\u0026lt;String, String[]\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); if (parameterMap != null) { for (String key : parameterMap.keySet()) { String[] values = parameterMap.get(key); for (int i = 0; i \u0026lt; values.length; i++) { String value = values[i]; if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } values[i] = value; } map.put(key, values); } } return map; } @Override public String getHeader(String name) { String value = super.getHeader(name); if (!StrUtil.hasEmpty(value)){ value = HtmlUtil.cleanHtmlTag(value); } return value; } @Override public ServletInputStream getInputStream() throws IOException { ServletInputStream in = super.getInputStream(); InputStreamReader reader = new InputStreamReader(in, StandardCharsets.UTF_8); BufferedReader buffer = new BufferedReader(reader); StringBuilder body = new StringBuilder(); String line = buffer.readLine(); while (line != null){ body.append(line); line = buffer.readLine(); } buffer.close(); reader.close(); in.close(); Map\u0026lt;String, Object\u0026gt; map = JSONUtil.parseObj(body.toString()); Map\u0026lt;String, Object\u0026gt; result = new LinkedHashMap\u0026lt;\u0026gt;(); for (String key : map.keySet()) { Object value = map.get(key); if (value instanceof String){ if (!StrUtil.hasEmpty(value.toString())){ result.put(key, HtmlUtil.cleanHtmlTag(value.toString())); } }else { result.put(key, value); } } String json = JSONUtil.toJsonStr(result); ByteArrayInputStream bain = new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)); return new ServletInputStream() { @Override public boolean isFinished() { return false; } @Override public boolean isReady() { return false; } @Override public void setReadListener(ReadListener readListener) { } @Override public int read() throws IOException { return bain.read(); } }; } }   过滤请求\npackage com.example.emos.api.config.xss; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; /** * Description: xss过滤器 * 拦截所有的HTTP请求， * 然后调用上面创建的XssHttpServletRequestWrapper类 * * @author Rex * @date 2021-09-09 16:06 */ public class XssFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; XssHttpSevletRequestWrapper wrapper = new XssHttpSevletRequestWrapper(request); filterChain.doFilter(wrapper, servletResponse); } @Override public void destroy() { } }     自定义分页对象\npackage com.example.emos.api.common.dto; import java.io.Serializable; import java.util.List; /** * Description: 自定义分页 * * @author Rex * @date 2021-09-09 16:20 */ public class Pageination\u0026lt;T\u0026gt; implements Serializable { private static final long serialVersionUID = 1L; /** * 总记录数 */ private Long totalCount; /** * 每页记录数 */ private Integer pageSize; /** * 总页数 */ private Integer totalPage; /** * 当前页数 */ private Integer pageIndex; /** * 列表数据 */ private List\u0026lt;T\u0026gt; list; public Pageination(List\u0026lt;T\u0026gt; list, Long totalCount, Integer pageIndex, Integer pageSize){ this.list = list; this.totalCount = totalCount; this.pageSize = pageSize; this.pageIndex = pageIndex; this.totalPage = (int) Math.ceil((double) totalCount / pageSize); } }   用MybatixX插件自动生成pojo、dao、mapper\n  自定义模板\n.meta.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;templates\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;domain\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;domain.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.java\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;${domain.basePackage}.domain\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;${domain.basePath}\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;mapperInterface\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;mapperInterface.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}Dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.java\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;${domain.basePackage}.dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;${domain.basePath}\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;property name=\u0026#34;configName\u0026#34; value=\u0026#34;mapperXml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configFile\u0026#34; value=\u0026#34;mapperXml.ftl\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;fileName\u0026#34; value=\u0026#34;${domain.fileName}Dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packageName\u0026#34; value=\u0026#34;mapper\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;encoding\u0026#34; value=\u0026#34;${domain.encoding}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;basePath\u0026#34; value=\u0026#34;src/main/resources\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/templates\u0026gt; domain.ftl\npackage ${domain.packageName}; import lombok.Data; import javax.validation.constraints.NotBlank; import javax.validation.constraints.Size; import javax.validation.constraints.NotNull; import java.io.Serializable; \u0026lt;#list tableClass.importList as fieldType\u0026gt;${\u0026#34;\\n\u0026#34;}import ${fieldType};\u0026lt;/#list\u0026gt; /** * Description: ${tableClass.remark!} * * @TableName ${tableClass.tableName} * @author Rex */ @Data public class ${tableClass.shortClassName} implements Serializable { \u0026lt;#list tableClass.allFields as field\u0026gt; /** * ${field.remark!} */\u0026lt;#if !field.nullable || field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#if !field.nullable\u0026gt;\u0026lt;#if field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;@NotBlank(message=\u0026#34;[${field.remark!}]不能为空\u0026#34;)\u0026lt;#else\u0026gt;@NotNull(message=\u0026#34;[${field.remark!}]不能为空\u0026#34;)\u0026lt;/#if\u0026gt;\u0026lt;/#if\u0026gt;\u0026lt;#if field.jdbcType==\u0026#34;VARCHAR\u0026#34;\u0026gt;\u0026lt;#if !field.nullable\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;@Size(max= ${field.columnLength?c},message=\u0026#34;编码长度不能超过${field.columnLength?c}\u0026#34;)\u0026lt;/#if\u0026gt; private ${field.shortTypeName} ${field.fieldName}; \u0026lt;/#list\u0026gt; } mapperInterface.ftl\npackage ${mapperInterface.packageName}; import ${tableClass.fullClassName}; import org.apache.ibatis.annotations.Mapper; /** * Description: TODO * * @author Rex */ @Mapper public interface ${mapperInterface.fileName} { /** * 根据主键编号删除用户信息 * @param id 主键编号 * @return 影响记录数 */ int deleteByPrimaryKey(Long id); /** * 插入一条记录 * @param record 待插入的记录 * @return 影响记录数 */ int insert(${tableClass.shortClassName} record); /** * 插入指定字段，未指定的用默认值 * @param record 待插入的记录 * @return 影响记录数 */ int insertSelective(${tableClass.shortClassName} record); /** * 根据主键查询记录 * @param id 主键编号 * @return 记录对象 */ ${tableClass.shortClassName} selectByPrimaryKey(Long id); /** * 根据主键更新字段（不包括null） * @param record 待更新的记录 * @return 影响记录数 */ int updateByPrimaryKeySelective(${tableClass.shortClassName} record); /** * 根据主键更新字段（包括null） * @param record 待更新的记录 * @return 影响记录数 */ int updateByPrimaryKey(${tableClass.shortClassName} record); } mapperXml.ftl\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;${mapperInterface.packageName}.${baseInfo.fileName}\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; \u0026lt;#list tableClass.pkFields as field\u0026gt; \u0026lt;id property=\u0026#34;${field.fieldName}\u0026#34; column=\u0026#34;${field.columnName}\u0026#34; jdbcType=\u0026#34;${field.jdbcType}\u0026#34;/\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;#list tableClass.baseFields as field\u0026gt; \u0026lt;result property=\u0026#34;${field.fieldName}\u0026#34; column=\u0026#34;${field.columnName}\u0026#34; jdbcType=\u0026#34;${field.jdbcType}\u0026#34;/\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt;${field.columnName}\u0026lt;#sep\u0026gt;,\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;selectByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;Base_Column_List\u0026#34; /\u0026gt; from ${tableClass.tableName} where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;delete id=\u0026#34;deleteByPrimaryKey\u0026#34; parameterType=\u0026#34;java.lang.Long\u0026#34;\u0026gt; delete from ${tableClass.tableName} where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026lt;#if (tableClass.pkFields?size==1)\u0026gt; keyColumn=\u0026#34;${tableClass.pkFields[0].columnName}\u0026#34; keyProperty=\u0026#34;${tableClass.pkFields[0].fieldName}\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026lt;/#if\u0026gt;\u0026gt; insert into ${tableClass.tableName} ( \u0026lt;#list tableClass.allFields as field\u0026gt;${field.columnName}\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt;) values (\u0026lt;#list tableClass.allFields as field\u0026gt;${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}\u0026lt;#if field_index%3==2\u0026gt;${\u0026#34;\\n \u0026#34;}\u0026lt;/#if\u0026gt;\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt;) \u0026lt;/insert\u0026gt; \u0026lt;insert id=\u0026#34;insertSelective\u0026#34;\u0026lt;#if (tableClass.pkFields?size==1)\u0026gt; keyColumn=\u0026#34;${tableClass.pkFields[0].columnName}\u0026#34; keyProperty=\u0026#34;${tableClass.pkFields[0].fieldName}\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34;\u0026lt;/#if\u0026gt;\u0026gt; insert into ${tableClass.tableName} \u0026lt;trim prefix=\u0026#34;(\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt;${field.fieldName},\u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026#34;values (\u0026#34; suffix=\u0026#34;)\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;#list tableClass.allFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt;${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}},\u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKeySelective\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; update ${tableClass.tableName} \u0026lt;set\u0026gt; \u0026lt;#list tableClass.baseBlobFields as field\u0026gt; \u0026lt;if test=\u0026#34;${field.fieldName} != null\u0026#34;\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}, \u0026lt;/if\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/set\u0026gt; where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;update id=\u0026#34;updateByPrimaryKey\u0026#34; parameterType=\u0026#34;${tableClass.fullClassName}\u0026#34;\u0026gt; update ${tableClass.tableName} set \u0026lt;#list tableClass.baseBlobFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}}\u0026lt;#sep\u0026gt;,\u0026lt;/#list\u0026gt; where \u0026lt;#list tableClass.pkFields as field\u0026gt; ${field.columnName} = ${\u0026#39;#\u0026#39;}{${field.fieldName},jdbcType=${field.jdbcType}} \u0026lt;#if field_has_next\u0026gt;AND\u0026lt;/#if\u0026gt;\u0026lt;/#list\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt;   配置\n    ","permalink":"https://rex0520.github.io/posts/proj/emos/emos%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","summary":"emos项目准备 项目结构 已有项目：  工作流项目(emos-workflow) 小程序项目(emos-wx) 小程序后端项目(emos-wx-api)  待开发项目  Web办公系统前端项目(emos-vue) Web办公系统后端项目(emos-api)  数据表分类：    序号 类型 特征 备注     1 工作流数据表 以 act_ 开头 存储工作流的各项数据   2 定时器数据表 以 qrtz_ 开头 存储QuartZ定时器数据   3 业务表 以 tb_ 开头 保存业务数据   4 系统表 以 sys_ 开头 保存系统配置信息    后端： 依赖库：   Lombok \u0026ndash; 生成对象的Get/Set方法\n  Spring Web \u0026ndash; spring的web开发框架","title":"Emos项目搭建"}]