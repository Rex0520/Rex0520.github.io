[{"content":"腾讯视频会议的使用-TRTC技术 概述：  TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n 后端的准备  首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n 用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n1 2 3 4  //UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥  usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire)))   关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148  package com.example.emos.api.config.tencet; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import org.bson.internal.Base64; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.zip.Deflater; /** * Description: 腾讯TRTC工具 * * @author Rex * @date 2021-09-29 10:48 */ import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; @Component public class TRTCUtil { @Value(\u0026#34;${tencent.trtc.appId}\u0026#34;) private int appId; @Value(\u0026#34;${tencent.trtc.expire}\u0026#34;) private int expire; @Value(\u0026#34;${tencent.trtc.secretKey}\u0026#34;) private String secretKey; /** * 计算UserSig签名 * 函数内部使用HMAC-SHA256 非对称加密算法，对SdkAppId、userID和ExpireTime进行加密。 * @param userId 用户id * @return 用户签名 */ public String genUserSig(String userId) { return GenTLSSignature(appId, userId, expire, null, secretKey); } /** * 生成TLS票据 * @param sdkappid 应用的id * @param userId 用户id * @param expire 有效期，单位是秒 * @param userbuf 默认填写null * @param priKeyContent 生成tls票据使用的私钥内容 * @return 如果出错，会返回为空，或者有异常打印，成功返回有效的票据 */ private String GenTLSSignature(long sdkappid, String userId, long expire, byte[] userbuf, String priKeyContent) { if (StrUtil.isEmpty(priKeyContent)) { return \u0026#34;\u0026#34;; } long currTime = System.currentTimeMillis() / 1000; JSONObject sigDoc = new JSONObject(); sigDoc.set(\u0026#34;TLS.ver\u0026#34;, \u0026#34;2.0\u0026#34;); sigDoc.set(\u0026#34;TLS.identifier\u0026#34;, userId); sigDoc.set(\u0026#34;TLS.sdkappid\u0026#34;, sdkappid); sigDoc.set(\u0026#34;TLS.expire\u0026#34;, expire); sigDoc.set(\u0026#34;TLS.time\u0026#34;, currTime); String base64UserBuf = null; if (null != userbuf) { base64UserBuf = Base64.encode(userbuf); sigDoc.set(\u0026#34;TLS.userbuf\u0026#34;, base64UserBuf); } String sig = hmacsha256(sdkappid, userId, currTime, expire, priKeyContent, base64UserBuf); if (sig.length() == 0) { return \u0026#34;\u0026#34;; } sigDoc.set(\u0026#34;TLS.sig\u0026#34;, sig); Deflater compressor = new Deflater(); compressor.setInput(sigDoc.toString().getBytes(Charset.forName(\u0026#34;UTF-8\u0026#34;))); compressor.finish(); byte[] compressedBytes = new byte[2048]; int compressedBytesLength = compressor.deflate(compressedBytes); compressor.end(); return new String(base64EncodeUrl(Arrays.copyOfRange(compressedBytes, 0, compressedBytesLength))); } /** * 用HmacSHA256算法进行加密 * @param sdkappid 应用id * @param userId 用户id * @param currTime 当前时间戳 * @param expire 有效期，单位秒 * @param priKeyContent 密钥内容 * @param base64Userbuf 默认填写null * @return 加密结果 */ private static String hmacsha256(long sdkappid, String userId, long currTime, long expire, String priKeyContent, String base64Userbuf) { String contentToBeSigned = \u0026#34;TLS.identifier:\u0026#34; + userId + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.sdkappid:\u0026#34; + sdkappid + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.time:\u0026#34; + currTime + \u0026#34;\\n\u0026#34; + \u0026#34;TLS.expire:\u0026#34; + expire + \u0026#34;\\n\u0026#34;; if (null != base64Userbuf) { contentToBeSigned += \u0026#34;TLS.userbuf:\u0026#34; + base64Userbuf + \u0026#34;\\n\u0026#34;; } try { byte[] byteKey = priKeyContent.getBytes(\u0026#34;UTF-8\u0026#34;); Mac hmac = Mac.getInstance(\u0026#34;HmacSHA256\u0026#34;); SecretKeySpec keySpec = new SecretKeySpec(byteKey, \u0026#34;HmacSHA256\u0026#34;); hmac.init(keySpec); byte[] byteSig = hmac.doFinal(contentToBeSigned.getBytes(\u0026#34;UTF-8\u0026#34;)); return Base64.encode(byteSig); } catch (UnsupportedEncodingException e) { return \u0026#34;\u0026#34;; } catch (NoSuchAlgorithmException e) { return \u0026#34;\u0026#34;; } catch (InvalidKeyException e) { return \u0026#34;\u0026#34;; } } /** * 将base64字符串转换成URL格式的字符串 * @param input base64数据 * @return url可接受的base64数据 */ private static byte[] base64EncodeUrl(byte[] input) { byte[] base64 = Base64.encode(input).getBytes(); for (int i = 0; i \u0026lt; base64.length; ++i) switch (base64[i]) { case \u0026#39;+\u0026#39;: base64[i] = \u0026#39;*\u0026#39;; break; case \u0026#39;/\u0026#39;: base64[i] = \u0026#39;-\u0026#39;; break; case \u0026#39;=\u0026#39;: base64[i] = \u0026#39;_\u0026#39;; break; default: break; } return base64; } }   将UserSig返回给前端 接下的工作就非常简单了，将userId、appId、userSig生成返回给前端，接下来的写法就不多做说明，下面贴上返回的json格式\n1 2 3 4 5 6 7 8 9  { \u0026#34;code\u0026#34;:200, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;userSig\u0026#34;:\u0026#34;eJyrVgrxCdZLrSjILEpVsrIwMzEw0AELlaUWKVkpGekZKEH4xSnZiQUFmSlKVoZANaZmlgZGUJWZKal5JZlpmRANJjD1melArmdhWUV6bnGZa3pVWZV5uXaqRZFbZlBJSopjuWNEYpZ-hllZqltiQEaUV7ktVGNJZi7QJYZmxiYGhuYmZqa1AFiAMM0_\u0026#34;, \u0026#34;userId\u0026#34;:24, \u0026#34;appId\u0026#34;:\u0026#34;1400569020\u0026#34; } }   前端 检查环境  Trtc.checkSystemRequirements() ，这个函数用于判断当前浏览器系统是否可以满足trtc的使用环境，在创建trtc之前要用这个方法检查一下，这个函数是异步的，要使用同步可以用\n1 2 3  trtc.checkSystemRequirements().then(()=\u0026gt;{ // 同步的函数 })    日志  Trtc.Logger.setLogLevel(Trtc.Logger.LogLevel.ERROR)，设置trtc的日志输出级别\n 创建TrtcClient  Trtc.createClient()，需要传入mode、sdkAppId、userId、userSig\n 使用示例:\n1 2 3 4 5 6  let client = TRTC.createClient({ mode: \u0026#39;rtc\u0026#39;, sdkAppId: that.appId, userId: that.userId + \u0026#39;\u0026#39;, userSig: that.userSig });   监听新增远端流  client.on(\u0026ldquo;stream-add\u0026rdquo;, event=\u0026gt;{})，当远端用户发布流后触发，一般在这个回调函数里要订阅远端流。通过远端流来获取新增的用户id，再更新到用户列表里；订阅远端流需要调用client.subscribe(remoteStream)，这里的remote可以由remote.stream调用获取。订阅好了remoteStream，就可以通过remoteStream.getUserId()获取用户信息。以下是代码示例：\n 1 2 3 4 5 6 7 8  client.on(\u0026#39;stream-added\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //订阅远端流  client.subscribe(remoteStream); //从远端流获得远程用户userId(创建TrtcClient对象时候的参数)  let userId = remoteStream.getUserId(); that.stream[userId] = remoteStream; });   监听远端流订阅成功  client.on(\u0026ldquo;stream-subscribed\u0026rdquo;, event=\u0026gt;{}), 若检测到客户端也调用了subscribe()，订阅了远端流，则触发该回调函数。下面是使用示例，remoteStream.play(userId + \u0026ldquo;\u0026quot;)会播放该用户id的音视频讯号\n 1 2 3 4 5 6 7 8  client.on(\u0026#39;stream-subscribed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; let userId = remoteStream.getUserId(); //找到视频墙中某个远端用户的格子，把其中用于显示视频的DIV，置顶覆盖用户信息  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: 1 }); //在这个置顶的DIV中播放远端音视频讯号  remoteStream.play(userId + \u0026#39;\u0026#39;); });   监听远端删除流  client.on(\u0026ldquo;stream-remove\u0026rdquo;, event=\u0026gt;{}),当远端用户退出的时候调用该回调函数。一般的，再这个函数里会关闭和该用户有关的信息，以下是代码示例\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; //取消订阅该远端流  client.unsubscribe(remoteStream); let userId = remoteStream.getUserId(); //TODO 在页面右侧的用户列表中删除该用户  //停止播放远端流视频，并且关闭远端流  remoteStream.stop(); remoteStream.close(); //删除模型层JSON中保存的远端流对象  delete that.stream[userId]; //把视频墙中该用户格子的视频DIV控件置底，显示用户基本信息  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); });   加入会议室  client.join({ roomId: that.roomId})，加入会议，这个roomId一般由后端生成获得。因为这个函数也是异步函数，所以要进入会议室后创建本地流、播放本地音视频、配置信息之类的要在client.join({ roomId: that.roomId}).then()的then里面调用，以下是代码示例\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  client .join({ roomId: that.roomId }) .then(() =\u0026gt; { //成功进入会议室，然后创建本地流  let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: true, video: true }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); //设置分辨率  //初始化本地音视频流  localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }).then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //视频墙中第一个格子中的视频DIV置顶  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); //播放本地音视频流  localStream.play(\u0026#39;localStream\u0026#39;); //向远端用户推送本地流  client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }).catch(error =\u0026gt; { console.error(\u0026#39;进入房间失败: \u0026#39; + error); });   订阅语音音量事件  client.on(\u0026ldquo;audio-volumn\u0026rdquo;, event=\u0026gt;{})，可以监听本地和远端的麦克风音量变化，一般会配合client.enableAudioVolumeEvaluation(30)使用，他会指定每隔一段事件调用这个事件，这里是30ms。下面是使用示例\n 1 2 3 4 5 6 7 8 9 10 11 12 13  //订阅语音事件（无论本地还是远端说话，都会触发这个事件） client.on(\u0026#39;audio-volume\u0026#39;, event =\u0026gt; { event.result.forEach(({ userId, audioVolume, stream }) =\u0026gt; { //说话声音超过5，就设置话筒音量动画  if (audioVolume \u0026gt; 5) { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `${100 - audioVolume * 3}%`); } else { $(\u0026#39;#mic-\u0026#39; + userId).css(\u0026#39;top\u0026#39;, `100%`); } }); }); // 开启音量回调函数，并设置每 30ms 触发一次事件 client.enableAudioVolumeEvaluation(30);   监听远断流删除流  client.on(\u0026lsquo;stream-removed\u0026rsquo;, event-\u0026gt;{})，这个是监听到远端退出会议的时候调用的方法，以下是使用示例\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //订阅远端删除流事件（远端用户退出会议室） client.on(\u0026#39;stream-removed\u0026#39;, event =\u0026gt; { let remoteStream = event.stream; client.unsubscribe(remoteStream); //取消订阅该远端流的所有事件  let userId = remoteStream.getUserId(); //上线用户列表中删除该用户  let i = that.userList.findIndex(function(one) { return one.userId == userId; }); that.userList.splice(i, 1); //停止播放远端流视频，并且关闭远端流  remoteStream.stop(); remoteStream.close(); //把远端流从stream中删除  delete that.stream[userId]; //把远端视频播放界面设置为-1层  $(\u0026#39;#\u0026#39; + userId).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#\u0026#39; + userId).html(\u0026#39;\u0026#39;); });   退出视频会议室  client.unpublish()，这也是一个异步函数，要在退出后清除一些信息也要在then方法里。下面是使用示例,里面的client.leave是离开里面的会议室\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //获取当前本地使用的流，有可能是本地流或者共享流 let stream = that.getStream(); that.client.unpublish(stream).then(() =\u0026gt; { // 取消发布本地流成功  that.client .leave() .then(() =\u0026gt; { console.log(\u0026#39;成功退出会议室\u0026#39;); //关闭本地流或者共享流  stream.stop(); stream.close(); //清空模型层的本地流  that.localStream = null; that.shareStream = null; //清空模型层的远端流  that.stream = {}; //销毁TrtcClient对象  that.client = null; that.userList = []; //清空用户列表  that.videoStatus = true; that.micStatus = true; that.shareStatus = false; //视频墙上本地流DIV区域置底  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: \u0026#39;-1\u0026#39; }); $(\u0026#39;#localStream\u0026#39;).html(\u0026#39;\u0026#39;); //TODO 如果是播放大屏视频的时候退出会议，退出会议后需要隐藏大屏  }) .catch(error =\u0026gt; { console.error(\u0026#39;成功退出会议室失败\u0026#39; + error); }); });    打开/关闭摄像头：  localStream.unmuteVideo()/localStream.muteVideo()，localStream是本地流,在创建会议的时候生成\n 打开/关闭麦克风  stream.unmuteAudio()/stream.muteAudio()，stream是本地流或共享流\n 检测是否满足屏幕共享环境  TRTC.isScreenShareSupported()，与checkSystemRequirements类似\n 创建屏幕共享  同样的也是调用TRTC.createStream创建共享流，需要传入screen:true参数，下面是使用示例\n 1 2 3 4 5  let shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId });   设置屏幕的分辨率  shareStream.setScreenProfile(\u0026lsquo;1080p\u0026rsquo;);\n 下面是屏幕共享的使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  shareHandle: function() { let that = this; //判断用户是否进入视频会议室  if (!that.meetingStatus) { that.$alert(\u0026#39;请先进入视频会议才能共享屏幕\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } //检查浏览器是否支持屏幕共享  if (!TRTC.isScreenShareSupported()) { //提示当前浏览器不支持在线视频会议  this.$alert(\u0026#39;当前浏览器不支持屏幕共享\u0026#39;, \u0026#39;提示信息\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39; }); return; } that.shareStatus = !that.shareStatus; //开启屏幕共享  if (that.shareStatus) { //创建共享流  let shareStream = TRTC.createStream({ audio: that.micStatus, screen: true, userId: that.userId }); shareStream.setScreenProfile(\u0026#39;1080p\u0026#39;); that.shareStream = shareStream; shareStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始共享流失败 \u0026#39; + error); }) .then(() =\u0026gt; { //取消推送本地视频流  that.client.unpublish(that.localStream).then(() =\u0026gt; { that.localStream.close(); //关闭本地流  that.localStream = null; //本地流设置为空  //隐藏本地视频窗口  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: -1 }); that.client.publish(shareStream); //向远端推送共享流  }); }); } //关闭屏幕共享  else { //重建本地视频流  let localStream = TRTC.createStream({ userId: that.userId + \u0026#39;\u0026#39;, audio: that.micStatus, video: that.videoStatus }); that.localStream = localStream; localStream.setVideoProfile(\u0026#39;480p\u0026#39;); localStream .initialize() .catch(error =\u0026gt; { console.error(\u0026#39;初始化本地流失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;初始化本地流成功\u0026#39;); //取消共享流的推流  that.client.unpublish(that.shareStream).then(() =\u0026gt; { that.shareStream.close(); //关闭共享流  that.shareStream = null; //共享流设置为空  //显示本地视频窗口  $(\u0026#39;#localStream\u0026#39;).css({ \u0026#39;z-index\u0026#39;: 1 }); localStream.play(\u0026#39;localStream\u0026#39;); //播放本地流  //向远端推送本地视频流  that.client .publish(localStream) .catch(error =\u0026gt; { console.error(\u0026#39;本地流发布失败 \u0026#39; + error); }) .then(() =\u0026gt; { console.log(\u0026#39;本地流发布成功\u0026#39;); }); }); }); } },   ","permalink":"https://rex0520.github.io/posts/video/%E8%85%BE%E8%AE%AFtrtc/","summary":"腾讯视频会议的使用-TRTC技术 概述：  TRTC全称(Tencent Real-Time Communication) 即腾讯实时音视频服务，定位是解决实时通信的云服务，主要功能就是通过互联网，接受、处理、转发和保存大流量的音视频流数据，主要用于直播、视频会议场景。本文简略说明TRTC技术的使用，案例基于前端-vue，后端-java的springboot框架，具体的内容参考一下文档\n 后端的准备  首先前端调用TRTC服务需要创建TrtcClient对象来管理，创建TrtcClient需要用到三个参数，分别是AppID，用户UserId，还有用户签名(UserSig)。而这里的用户签名是用Trtc的AppID和密钥，任意开发者查看HTML都能看到这些信息，所以生成用户签名的工作不能在前端完成，正确的做法应该是在后端项目生成用户签名\n 用户签名(UserSig) （UserSig）是腾讯云设计的一种安全保护签名，使用HMAC SHA256加密算法计算得出。\n1 2 3 4  //UserSig 计算公式，其中 secretkey 为计算 usersig 用的加密密钥  usersig = hmacsha256(secretkey, (userid + sdkappid + currtime + expire + base64(userid + sdkappid + currtime + expire)))   关于userSig的各种语言生成方法在腾讯云的官方文档都有介绍\n这边我使用的springboot框架，所以用是java生成userSig的方式，需要在项目中创建一个TrtcUtil.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148  package com.","title":"腾讯TRTC"}]